<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qtnetworkauth-oauth2-overview.qdoc -->
  <meta name="description" content="An overview of QtNetworkAuth OAuth2">
  <title>Qt OAuth2 Overview | Qt Network Authorization | Qt 6.9.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li>Qt 6.9</li>
<li><a href="qtnetworkauth-index.html">Qt Network Authorization</a></li>
<li>Qt OAuth2 Overview</li>
<li id="buildversion"><a href="qtnetworkauth-index.html">Qt Network Authorization | Commercial or GPLv3</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#oauth2">OAuth2</a></li>
<li class="level1"><a href="#qt-oauth2-classes">Qt OAuth2 Classes</a></li>
<li class="level1"><a href="#authorization-code-flow">Authorization Code Flow</a></li>
<li class="level2"><a href="#stages">Stages</a></li>
<li class="level2"><a href="#details-and-customization">Details and Customization</a></li>
<li class="level2"><a href="#choosing-a-reply-handler">Choosing A Reply Handler</a></li>
<li class="level1"><a href="#device-authorization-flow">Device Authorization Flow</a></li>
<li class="level2"><a href="#device-authorization-flow-stages-7">Stages</a></li>
<li class="level2"><a href="#device-authorization-flow-details-and-customization-8">Details and Customization</a></li>
<li class="level1"><a href="#refreshing-tokens">Refreshing Tokens</a></li>
<li class="level1"><a href="#qt-openid-connect-support">Qt OpenID Connect Support</a></li>
<li class="level2"><a href="#getting-an-id-token">Getting an ID Token</a></li>
<li class="level2"><a href="#validating-an-id-token">Validating an ID Token</a></li>
<li class="level2"><a href="#reading-id-token-values">Reading ID Token Values</a></li>
<li class="level2"><a href="#openid-connect-discovery">OpenID Connect Discovery</a></li>
<li class="level2"><a href="#openid-userinfo-endpoint">OpenID UserInfo Endpoint</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">Qt OAuth2 Overview</h1>
<!-- $$$qt-oauth2-overview.html-description -->
<div class="descr" id="details">
<h2 id="oauth2">OAuth2</h2>
<p><a href="https://datatracker.ietf.org/doc/html/rfc6749">RFC 6749 OAuth 2.0</a> defines an authorization framework which enables resource authorization without exposing sensitive user credentials such as passwords.</p>
<p>The OAuth2 framework defines several client types (public and confidential) as well as flows (implicit, authorization code, and several others). For typical Qt applications the client type should be considered as <i>public native</i> application. The <i>public</i> implies that the application isn't trusted to hold secrets, such as passwords, embedded within the shipped binary.</p>
<p><a href="https://datatracker.ietf.org/doc/html/rfc8252">RFC 8252 OAuth 2.0 for Native Apps</a> further defines the best practices for such applications. Among other things, it defines the <a href="https://datatracker.ietf.org/doc/html/rfc8252#section-6">Authorization Code Flow</a> as the recommended flow, and therefore <a href="qtnetworkauth-module.html" translate="no">QtNetworkAuth</a> provides a concrete implementation of this flow.</p>
<p>Since Qt 6.9, <a href="qtnetworkauth-module.html" translate="no">QtNetworkAuth</a> also provides support for <a href="https://datatracker.ietf.org/doc/html/rfc8628">RFC 8628 OAuth 2.0 Device Authorization Grant</a>. This <i>device flow</i> is intended for connected devices that have limited input capabilities, or where using a user-agent or browser is not practical. Examples of such devices include televisions, media consoles, machine HMIs, and IoT devices.</p>
<p>The following table highlights the main aspects of the two concrete OAuth2 flows supported by <a href="qtnetworkauth-module.html" translate="no">QtNetworkAuth</a> module:</p>
<div class="table"><table class="generic">
 <thead><tr class="qt-style"><th >Aspect</th><th >Authorization Code Flow</th><th >Device Authorization Flow</th></tr></thead>
<tr valign="top" class="odd"><td >Network Connection</td><td >Yes</td><td >Yes</td></tr>
<tr valign="top" class="even"><td >User Interaction</td><td >Browser / user-agent on the same device</td><td >Browser / user-agent on a different device</td></tr>
<tr valign="top" class="odd"><td >Redirect Handling Required</td><td >Yes</td><td >No</td></tr>
<tr valign="top" class="even"><td >Input Capability On Device</td><td >Rich input capabilities</td><td >Limited or no input capability</td></tr>
<tr valign="top" class="odd"><td >Targets</td><td >Desktop and Mobile Apps</td><td >TVs, Consoles, HMIs, IoT Devices</td></tr>
</table></div>
<p>OAuth2 requires using a user-agent which is typically a browser. For further information, see <a href="qt-oauth2-browsersupport.html">Qt OAuth2 Browser Support</a>.</p>
<h2 id="qt-oauth2-classes">Qt OAuth2 Classes</h2>
<p><a href="qtnetworkauth-module.html" translate="no">QtNetworkAuth</a> provides both concrete and abstract OAuth2 classes. The abstract classes are intended for implementing custom flows, while the concrete classes provide a concrete implementation.</p>
<p><a href="qtnetworkauth-module.html" translate="no">QtNetworkAuth</a> has two abstract classes for implementing OAuth2 flows:</p>
<ul>
<li>An <i>OAuth2 flow implementation</i> class provides the main API, and is the orchestrator of the flow. The abstract class is <a href="qabstractoauth2.html" translate="no">QAbstractOAuth2</a>, and the concrete implementations are <a href="qoauth2authorizationcodeflow.html" translate="no">QOAuth2AuthorizationCodeFlow</a> and <a href="qoauth2deviceauthorizationflow.html" translate="no">QOAuth2DeviceAuthorizationFlow</a>.</li>
<li>A <i>Reply handler</i> class which handles redirects and replies from an authorization server. The reply handler abstract class is <a href="qabstractoauthreplyhandler.html" translate="no">QAbstractOAuthReplyHandler</a>, and the concrete classes are <a href="qoauthhttpserverreplyhandler.html" translate="no">QOAuthHttpServerReplyHandler</a> and <a href="qoauthurischemereplyhandler.html" translate="no">QOAuthUriSchemeReplyHandler</a>. The main difference between reply handlers is what kind of redirects they are designed to handle. <a href="qoauth2authorizationcodeflow.html" translate="no">QOAuth2AuthorizationCodeFlow</a> relies on having a reply handler to handle the redirects, whereas <a href="qoauth2deviceauthorizationflow.html" translate="no">QOAuth2DeviceAuthorizationFlow</a>, which is not based on redirects, does not use reply handlers.</li>
</ul>
<h2 id="authorization-code-flow">Authorization Code Flow</h2>
<p>The <a href="https://datatracker.ietf.org/doc/html/rfc6749#section-1.3.1">authorization code flow</a> is the <a href="https://datatracker.ietf.org/doc/html/rfc8252#section-6">recommended OAuth2 flow</a> for native applications like Qt applications.</p>
<p>The following code snippet provides an example setup:</p>
<pre class="cpp" translate="no">
 QOAuth2AuthorizationCodeFlow m_oauth;
 <span class="type"><a href="qoauthurischemereplyhandler.html" translate="no">QOAuthUriSchemeReplyHandler</a></span> m_handler;

 m_oauth<span class="operator">.</span>setAuthorizationUrl(<span class="type"><a href="../qtcore/qurl.html" translate="no">QUrl</a></span>(authorizationUrl));
 m_oauth<span class="operator">.</span>setTokenUrl(<span class="type"><a href="../qtcore/qurl.html" translate="no">QUrl</a></span>(accessTokenUrl));
 m_oauth<span class="operator">.</span>setClientIdentifier(clientIdentifier);
 m_oauth<span class="operator">.</span>setRequestedScopeTokens({scope});

 connect(<span class="operator">&amp;</span>m_oauth<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="qabstractoauth.html" translate="no">QAbstractOAuth</a></span><span class="operator">::</span>authorizeWithBrowser<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="../qtgui/qdesktopservices.html" translate="no">QDesktopServices</a></span><span class="operator">::</span>openUrl);
 connect(<span class="operator">&amp;</span>m_oauth<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="qabstractoauth.html" translate="no">QAbstractOAuth</a></span><span class="operator">::</span>granted<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">[</span><span class="keyword">this</span><span class="operator">]</span>() {
     <span class="comment">// Here we use QNetworkRequestFactory to store the access token</span>
     m_api<span class="operator">.</span>setBearerToken(m_oauth<span class="operator">.</span>token()<span class="operator">.</span>toLatin1());
     m_handler<span class="operator">.</span>close();
 });

 m_handler<span class="operator">.</span>setRedirectUrl(<span class="type"><a href="../qtcore/qurl.html" translate="no">QUrl</a></span>{<span class="string">&quot;com.example.myqtapp://oauth2redirect&quot;</span>_L1});
 m_oauth<span class="operator">.</span>setReplyHandler(<span class="operator">&amp;</span>m_handler);

 <span class="comment">// Initiate the authorization</span>
 <span class="keyword">if</span> (m_handler<span class="operator">.</span>listen()) {
     m_oauth<span class="operator">.</span>grant();
 }
</pre>
<h3 id="stages">Stages</h3>
<p>The Authorization Code Flow has two main stages: resource authorization (including any necessary user authentication) followed up by an access token request. These are optionally followed by access token usage and access token refreshing. The following figure illustrates these stages:</p>
<p class="centerAlign"><img src="images/oauth2-codeflow-stages.webp" alt="" /></p><ul>
<li>In authorization stage, the user is authenticated, and the user authorizes the access to resources. This requires browser interaction by the user.</li>
<li>After the authorization the received authorization code is used to request an access token, and optionally a refresh token.</li>
<li>Once the access token is acquired, the application uses it to access the resources of interest. The access token is included in the resource requests, and it is up to the resource server to verify the token's validity. <a href="https://datatracker.ietf.org/doc/html/rfc6750">There are several ways to include the token as part of the requests</a>, but including it in the <a href="https://datatracker.ietf.org/doc/html/rfc6750#section-2.1">HTTP <code translate="no">Authorization</code> header</a> is arguably the most common.</li>
<li>Access token refreshing. Access tokens typically expire relatively quickly, say in one hour. If the application received a refresh token in addition to the access token, the refresh token can be used to request a new access token. Refresh tokens are long-lived and applications can persist them to avoid the need for a new authorization stage (and thus another browser interaction).</li>
</ul>
<h3 id="details-and-customization">Details and Customization</h3>
<p>OAuth2 flows are dynamic and following the details can be tricky at first. The figure below illustrates the main details of a successful authorization code flow.</p>
<p class="centerAlign"><img src="images/oauth2-codeflow-details.webp" alt="" /></p><p>For clarity the figure omits some less used signals, but altogether illustrates the details and main customization points. The customization points are the various signals/slots the application can catch (and call), as well as the callbacks which are settable with <a href="qabstractoauth.html#setModifyParametersFunction" translate="no">QAbstractOAuth::setModifyParametersFunction</a>() and <a href="qabstractoauth2.html#setNetworkRequestModifier" translate="no">QAbstractOAuth2::setNetworkRequestModifier</a>().</p>
<h3 id="choosing-a-reply-handler">Choosing A Reply Handler</h3>
<p>The decision on which reply hander to use, or to implement, is dependent on the <a href="https://datatracker.ietf.org/doc/html/rfc6749#appendix-A.6">redirect_uri</a> used. The <code translate="no">redirect_uri</code> is where the browser is redirected upon concluding the authorization stage.</p>
<p>In the context of native applications, <a href="https://datatracker.ietf.org/doc/html/rfc8252#section-7">RFC 8252 outlines three main types of URI schemes</a>: <code translate="no">loopback</code>, <code translate="no">https</code>, and private-use.</p>
<ul>
<li><a href="https://datatracker.ietf.org/doc/html/rfc8252#section-7.1">Private-use URIs</a>: Can be used if the OS allows an application to register a custom URI scheme. An attempt to open an URL with such custom scheme will open the related native application. See <a href="qoauthurischemereplyhandler.html" translate="no">QOAuthUriSchemeReplyHandler</a>.</li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc8252#section-7.2">HTTPS URIs</a>: Can be used if the OS allows the application to register a custom HTTPS URL. An attempt to open this URL will open the related native application. This scheme is recommended if the OS supports it. See <a href="qoauthurischemereplyhandler.html" translate="no">QOAuthUriSchemeReplyHandler</a>.</li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc8252#section-7.3">Loopback Interfaces</a>: These are commonly used for desktop applications, and applications during development. The <a href="qoauthhttpserverreplyhandler.html" translate="no">QOAuthHttpServerReplyHandler</a> is designed to handle these URIs by setting up a local server to handle the redirection.</li>
</ul>
<p>The choice depends on several factors such as:</p>
<ul>
<li>Redirect URIs supported by the authorization server vendor. The support varies from vendor to vendor, and is often specific to a particular client type and operating system. Also, the support may vary depending on whether the application is published or not.</li>
<li>Redirect URI schemes supported by the target platform(s).</li>
<li>Application-specific usability, security, and other requirements.</li>
</ul>
<blockquote><p><a href="https://datatracker.ietf.org/doc/html/rfc8252#section-7.2">RFC 8252 recommends using the <code translate="no">https</code> scheme</a> for security and usability advantages over the other methods.</p>
</blockquote>
<h2 id="device-authorization-flow">Device Authorization Flow</h2>
<p>The Device Authorization Flow is intended for connected devices that are limited in terms of input capabilities, or where user-agent/browser usage is not practical.</p>
<p>The following code snippet provides an example setup:</p>
<pre class="cpp" translate="no">
 m_deviceFlow<span class="operator">.</span>setAuthorizationUrl(<span class="type"><a href="../qtcore/qurl.html" translate="no">QUrl</a></span>(authorizationUrl));
 m_deviceFlow<span class="operator">.</span>setTokenUrl(<span class="type"><a href="../qtcore/qurl.html" translate="no">QUrl</a></span>(accessTokenUrl));
 m_deviceFlow<span class="operator">.</span>setRequestedScopeTokens({scope});
 m_deviceFlow<span class="operator">.</span>setClientIdentifier(clientIdentifier);
 <span class="comment">// The need for a client secret depends on the authorization server</span>
 m_deviceFlow<span class="operator">.</span>setClientIdentifierSharedKey(clientSecret);

 connect(<span class="operator">&amp;</span>m_deviceFlow<span class="operator">,</span> <span class="operator">&amp;</span>QOAuth2DeviceAuthorizationFlow<span class="operator">::</span>authorizeWithUserCode<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span>
     <span class="operator">[</span><span class="operator">]</span>(<span class="keyword">const</span> <span class="type"><a href="../qtcore/qurl.html" translate="no">QUrl</a></span> <span class="operator">&amp;</span>verificationUrl<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> <span class="operator">&amp;</span>userCode<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="../qtcore/qurl.html" translate="no">QUrl</a></span> <span class="operator">&amp;</span>completeVerificationUrl) {
         <span class="keyword">if</span> (completeVerificationUrl<span class="operator">.</span>isValid()) {
             <span class="comment">// If the authorization server provided a complete URL</span>
             <span class="comment">// that already contains the necessary data as part of the URL parameters,</span>
             <span class="comment">// you can choose to use that</span>
             <a href="../qtcore/qtlogging.html#qDebug" translate="no">qDebug</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;Complete verification uri:&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> completeVerificationUrl;
         } <span class="keyword">else</span> {
             <span class="comment">// Authorization server provided only verification URL; use that</span>
             <a href="../qtcore/qtlogging.html#qDebug" translate="no">qDebug</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;Verification uri and usercode:&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> verificationUrl <span class="operator">&lt;</span><span class="operator">&lt;</span> userCode;
         }
     }
 );

 connect(<span class="operator">&amp;</span>m_deviceFlow<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="qabstractoauth.html" translate="no">QAbstractOAuth</a></span><span class="operator">::</span>granted<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">[</span><span class="keyword">this</span><span class="operator">]</span>(){
     <span class="comment">// Here we use QNetworkRequestFactory to store the access token</span>
     m_api<span class="operator">.</span>setBearerToken(m_deviceFlow<span class="operator">.</span>token()<span class="operator">.</span>toLatin1());
 });
 m_deviceFlow<span class="operator">.</span>grant();
</pre>
<h3 id="device-authorization-flow-stages-7">Stages</h3>
<p>Device Authorization Flow has three main stages: initializing the authorization, polling for tokens, and completing the authorization. These are optionally followed by token usage and token refreshing. The following figure illustrates these stages:</p>
<p class="centerAlign"><img src="images/oauth2-deviceflow-stages.webp" alt="" /></p><ul>
<li>Authorization is initialized by sending a HTTP request to the authorization server. The authorization server provides a user code, verification URL(s), and a device code in response.</li>
<li>After authorization is initialized, user is provided with a user code and verification URL(s) for completing the authorization. Providing the information for the user is <a href="https://datatracker.ietf.org/doc/html/rfc8628#section-3.3">use-case specific</a>: it can be a visible URL on the screen, QR code, an email, and so on.</li>
<li>While waiting for a user to complete the authorization, the device flow polls the authorization server for tokens. The device code received in the previous step is used to match the authorization session. The poll interval is decided by the authorization server, and is typically 5 seconds.</li>
<li>Once user has accepted (or denied) the authorization, the authorization server responds to a poll request with the requested tokens or an error code (in case of denial), and the authorization is complete.</li>
</ul>
<h3 id="device-authorization-flow-details-and-customization-8">Details and Customization</h3>
<p>The following figure illustrates the flow in more detail. The figure illustrates also the main customization points, which may sometimes be needed (for instance proprietary parameters, or additional authentication credentials).</p>
<p class="centerAlign"><img src="images/oauth2-deviceflow-details.webp" alt="" /></p><h2 id="refreshing-tokens">Refreshing Tokens</h2>
<p>A full OAuth2 flow requires user interaction, which can be intrusive to the user experience. To minimize these interactions, tokens can be <a href="https://datatracker.ietf.org/doc/html/rfc6749#section-6">silently refreshed</a> from user's perspective.</p>
<p>Refreshing tokens requires that the authorization server provide a <a href="https://datatracker.ietf.org/doc/html/rfc6749#section-1.5">refresh token</a> during authorization. Providing a refresh token is up to the authorization server: some servers provide it always, some never, and some provide it if a specific <a href="qabstractoauth2.html#requestedScopeTokens-prop" translate="no">scope</a> was present in the authorization request.</p>
<p>The following figure illustrates the token refresh in more detail:</p>
<p class="centerAlign"><img src="images/oauth2-refresh-details.webp" alt="" /></p><p>As shown in the figure above, the usual customization points are also available when refreshing tokens.</p>
<p>To refresh the tokens after an application startup, the application needs to persist the refresh token securely, and set it with <a href="qabstractoauth2.html#setRefreshToken" translate="no">QAbstractOAuth2::setRefreshToken</a>(). <a href="qabstractoauth2.html#refreshTokens" translate="no">QAbstractOAuth2::refreshTokens</a>() can then be called to request new tokens.</p>
<p>Since Qt 6.9, applications can also use refresh convenience functionality to automatically refresh the tokens - see <a href="qabstractoauth2.html#accessTokenAboutToExpire" translate="no">QAbstractOAuth2::accessTokenAboutToExpire</a>(), <a href="qabstractoauth2.html#autoRefresh-prop" translate="no">QAbstractOAuth2::autoRefresh</a>, and <a href="qabstractoauth2.html#refreshLeadTime-prop" translate="no">QAbstractOAuth2::refreshLeadTime</a>.</p>
<p>The expiration time for a refresh token is generally not indicated by the authorization server (apart from the server's documentation). Their validity can range from days to months, or longer. Furthermore, as with other tokens, they can be revoked by the user and thus invalidated at any time. Therefore, it is important to properly detect a failed refresh attempt with <a href="qabstractoauth.html#requestFailed" translate="no">QAbstractOAuth::requestFailed</a>() or <a href="qabstractoauth2.html#serverReportedErrorOccurred" translate="no">QAbstractOAuth2::serverReportedErrorOccurred</a>().</p>
<h2 id="qt-openid-connect-support">Qt OpenID Connect Support</h2>
<p>OpenID Connect (OIDC) is a <a href="https://openid.net/specs/openid-connect-core-1_0-final.html">simple identity layer on top of OAuth2 protocol</a>. Where authorization provides means to authorize users to perform actions, OIDC enables establishing a trusted identity of a user.</p>
<p>Qt's support for OIDC is at the moment limited to getting <a href="https://openid.net/specs/openid-connect-core-1_0-final.html#Terminology">ID tokens</a>. An <code translate="no">ID token</code> is a <a href="https://datatracker.ietf.org/doc/html/rfc7519">JSON Web Token (JWT)</a> that contains claims about the authentication event.</p>
<p>Notably the support for <code translate="no">ID token</code> validation or <code translate="no">ID token</code> decryption is currently not implemented.</p>
<p>Assuming the application is able to <a href="qt-oauth2-overview.html#validating-an-id-token">validate</a> the received tokens, the token can be used to establish the identity of the user reliably (to the degree the OIDC provider itself is trusted).</p>
<p>ID tokens are sensitive information and should be kept as a secret. ID tokens are not intended for sending out in API calls - the access token is intended for that purpose. Note that some vendors may use the same <a href="https://datatracker.ietf.org/doc/html/rfc7519">JWT format</a> for access tokens, but that is not to be confused with actual ID tokens which incidentally use the same format. With ID tokens the client receiving the token is responsible for verifying the token, whereas with access tokens it's the resource server accepting the token that is responsible for verification.</p>
<h3 id="getting-an-id-token">Getting an ID Token</h3>
<p>Getting an ID token is very similar to getting an access token. First we need to set the appropriate scope. Authorization Server vendor may support additional scope specifiers such as <code translate="no">profile</code> and <code translate="no">email</code>, but all OIDC requests must include <code translate="no">openid</code> scope:</p>
<pre class="cpp" translate="no">
 m_oauth<span class="operator">.</span>setRequestedScopeTokens({<span class="string">&quot;openid&quot;</span>});
</pre>
<p>For OIDC it is strongly recommended to use <a href="qabstractoauth2.html#nonce-prop" translate="no">nonce</a> parameter. This is done by ensuring that appropriate <a href="qabstractoauth2.html#NonceMode-enum" translate="no">NonceMode</a> is set.</p>
<pre class="cpp" translate="no">
 <span class="comment">// This is for illustrative purposes, 'Automatic' is the default mode</span>
 m_oauth<span class="operator">.</span>setNonceMode(QAbstractOAuth2<span class="operator">::</span>NonceMode<span class="operator">::</span>Automatic);
</pre>
<p>As last step we can listen for either <a href="qabstractoauth.html#granted" translate="no">QAbstractOAuth2::granted</a> signal or the <a href="qabstractoauth2.html#idToken-prop" translate="no">QAbstractOAuth2::idTokenChanged</a> directly:</p>
<pre class="cpp" translate="no">
 connect(<span class="operator">&amp;</span>m_oauth<span class="operator">,</span> <span class="operator">&amp;</span>QAbstractOAuth2<span class="operator">::</span>idTokenChanged<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">[</span><span class="keyword">this</span><span class="operator">]</span>(<span class="keyword">const</span> <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> <span class="operator">&amp;</span>token) {
     Q_UNUSED(token); <span class="comment">// Handle token</span>
 });
</pre>
<h3 id="validating-an-id-token">Validating an ID Token</h3>
<p>Validating the received ID Token is a crucial part of the flow, and, <a href="https://openid.net/specs/openid-connect-core-1_0-final.html#IDTokenValidation">when fully implemented, a somewhat complicated task</a>.</p>
<p>At its outline validation consists of these steps</p>
<ul>
<li>Decrypting the token if needed (<a href="https://datatracker.ietf.org/doc/html/rfc7516">see JWE</a>)</li>
<li>Extracting the token header, payload, and signature</li>
<li>Validating the signature</li>
<li>Validating the fields of the payload (such as <code translate="no">aud, iss, exp, nonce, iat</code>)</li>
</ul>
<p>Qt currently doesn't provide support for ID token validation, but there are <a href="https://jwt.io/libraries">several C++ library options available</a>, such as <a href="https://github.com/Thalhammer/jwt-cpp">jwt-cpp</a>.</p>
<h4 id="id-token-verification-example">ID Token Verification Example</h4>
<p>This section illustrates a simple verification with the help of <a href="https://github.com/Thalhammer/jwt-cpp">jwt-cpp</a> library. As prerequisites, the development environment needs to have <a href="https://www.openssl.org/">OpenSSL</a> libraries, and <a href="https://github.com/Thalhammer/jwt-cpp">jwt-cpp</a> include folder under the application project's source directory.</p>
<p>In application project's <code translate="no">CMakeLists.txt</code> we first check that the prerequisities are met:</p>
<pre class="cpp" translate="no">
 find_package(OpenSSL 1.0.0 QUIET)
 set(JWT_CPP_INCLUDE_DIR &quot;${CMAKE_SOURCE_DIR}/include&quot;)
 if(OPENSSL_FOUND AND EXISTS &quot;${JWT_CPP_INCLUDE_DIR}/jwt-cpp/jwt.h&quot;)
</pre>
<p>Then we add necessary includes and libraries:</p>
<pre class="cpp" translate="no">
     target_include_directories(networkauth_oauth_snippets PRIVATE &quot;${JWT_CPP_INCLUDE_DIR}&quot;)
     target_link_libraries(networkauth_oauth_snippets PRIVATE OpenSSL::SSL OpenSSL::Crypto)
     target_compile_definitions(networkauth_oauth_snippets PRIVATE JWT_CPP_AVAILABLE)
</pre>
<p>In the application source files, include the verification library:</p>
<pre class="cpp" translate="no">
 <span class="preprocessor">#ifdef JWT_CPP_AVAILABLE</span>
 <span class="preprocessor">#include &quot;jwt-cpp/jwt.h&quot;</span>
 <span class="preprocessor">#endif</span>
</pre>
<p>Once the application receives an <code translate="no">ID token</code>, it's time to verify it. First we find a matching key from JSON Web Key Sets (JWKS, see <a href="qt-oauth2-overview.html#openid-connect-discovery">OpenID Connect Discovery</a>).</p>
<pre class="cpp" translate="no">
 <span class="keyword">try</span> {
     <span class="keyword">const</span> <span class="keyword">auto</span> jwt <span class="operator">=</span> jwt<span class="operator">::</span>decode(m_oauth<span class="operator">.</span>idToken()<span class="operator">.</span>toStdString());
     <span class="keyword">const</span> <span class="keyword">auto</span> jwks <span class="operator">=</span> jwt<span class="operator">::</span>parse_jwks(m_jwks<span class="operator">-</span><span class="operator">&gt;</span>toJson(<span class="type"><a href="../qtcore/qjsondocument.html" translate="no">QJsonDocument</a></span><span class="operator">::</span>Compact)<span class="operator">.</span>toStdString());
     <span class="keyword">const</span> <span class="keyword">auto</span> jwk <span class="operator">=</span> jwks<span class="operator">.</span>get_jwk(jwt<span class="operator">.</span>get_key_id());
</pre>
<p>And then we do the actual verification:</p>
<pre class="cpp" translate="no">
 <span class="comment">// Here we use modulus and exponent to derive the key</span>
 <span class="keyword">const</span> <span class="keyword">auto</span> n <span class="operator">=</span> jwk<span class="operator">.</span>get_jwk_claim(<span class="string">&quot;n&quot;</span>)<span class="operator">.</span>as_string(); <span class="comment">// modulus</span>
 <span class="keyword">const</span> <span class="keyword">auto</span> e <span class="operator">=</span> jwk<span class="operator">.</span>get_jwk_claim(<span class="string">&quot;e&quot;</span>)<span class="operator">.</span>as_string(); <span class="comment">// exponent</span>
 <span class="keyword">if</span> (n<span class="operator">.</span>empty() <span class="operator">|</span><span class="operator">|</span> e<span class="operator">.</span>empty()) {
     <a href="../qtcore/qtlogging.html#qWarning" translate="no">qWarning</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;Modulus or exponent empty&quot;</span>;
     <span class="keyword">return</span> <span class="keyword">false</span>;
 }
 <span class="keyword">if</span> (jwt<span class="operator">.</span>get_algorithm() <span class="operator">!</span><span class="operator">=</span> <span class="string">&quot;RS256&quot;</span>) { <span class="comment">// This example only supports RS256</span>
     <a href="../qtcore/qtlogging.html#qWarning" translate="no">qWarning</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;Unsupported algorithm:&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> jwt<span class="operator">.</span>get_algorithm();
     <span class="keyword">return</span> <span class="keyword">false</span>;
 }
 <span class="keyword">if</span> (jwk<span class="operator">.</span>get_jwk_claim(<span class="string">&quot;kty&quot;</span>)<span class="operator">.</span>as_string() <span class="operator">!</span><span class="operator">=</span> <span class="string">&quot;RSA&quot;</span>) {
     <a href="../qtcore/qtlogging.html#qWarning" translate="no">qWarning</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;Unsupported key type:&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> jwk<span class="operator">.</span>get_jwk_claim(<span class="string">&quot;kty&quot;</span>)<span class="operator">.</span>as_string();
     <span class="keyword">return</span> <span class="keyword">false</span>;
 }
 <span class="keyword">if</span> (jwk<span class="operator">.</span>has_jwk_claim(<span class="string">&quot;use&quot;</span>) <span class="operator">&amp;</span><span class="operator">&amp;</span> jwk<span class="operator">.</span>get_jwk_claim(<span class="string">&quot;use&quot;</span>)<span class="operator">.</span>as_string() <span class="operator">!</span><span class="operator">=</span> <span class="string">&quot;sig&quot;</span>) {
     <a href="../qtcore/qtlogging.html#qWarning" translate="no">qWarning</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;Key not for signature&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> jwk<span class="operator">.</span>get_jwk_claim(<span class="string">&quot;use&quot;</span>)<span class="operator">.</span>as_string();
     <span class="keyword">return</span> <span class="keyword">false</span>;
 }
 <span class="comment">// Simple minimal verification (omits special cases and eg. 'sub' verification).</span>
 <span class="comment">// jwt-cpp does check also 'exp', 'iat', and 'nbf' if they are present.</span>
 <span class="keyword">const</span> <span class="keyword">auto</span> keyPEM <span class="operator">=</span> jwt<span class="operator">::</span>helper<span class="operator">::</span>create_public_key_from_rsa_components(n<span class="operator">,</span> e);
 <span class="keyword">auto</span> verifier <span class="operator">=</span> jwt<span class="operator">::</span>verify()
                     <span class="operator">.</span>allow_algorithm(jwt<span class="operator">::</span>algorithm<span class="operator">::</span>rs256(keyPEM))
                     <span class="operator">.</span>with_claim(<span class="string">&quot;nonce&quot;</span><span class="operator">,</span> jwt<span class="operator">::</span>claim(m_oauth<span class="operator">.</span>nonce()<span class="operator">.</span>toStdString()))
                     <span class="operator">.</span>with_issuer(m_oidcConfig<span class="operator">-</span><span class="operator">&gt;</span>value(<span class="string">&quot;issuer&quot;</span>_L1)<span class="operator">.</span>toString()<span class="operator">.</span>toStdString())
                     <span class="operator">.</span>with_audience(std<span class="operator">::</span>string(clientIdentifier<span class="operator">.</span>data()))
                     <span class="operator">.</span>leeway(<span class="number">60UL</span>);
 verifier<span class="operator">.</span>verify(jwt);
 <a href="../qtcore/qtlogging.html#qDebug" translate="no">qDebug</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;ID Token verified successfully&quot;</span>;
 <span class="keyword">return</span> <span class="keyword">true</span>;
 } <span class="keyword">catch</span>(<span class="keyword">const</span> std<span class="operator">::</span>exception <span class="operator">&amp;</span>e) {
 <span class="comment">// Handle error. Alternatively pass error parameter to jwt-cpp calls</span>
 <a href="../qtcore/qtlogging.html#qWarning" translate="no">qWarning</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;ID Token verification failed&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> e<span class="operator">.</span>what();
 <span class="keyword">return</span> <span class="keyword">false</span>;
 }
</pre>
<p>It is recommended to check up-to-date documentation and examples of the library being used, and also to familiarize with <a href="https://openid.net/specs/openid-connect-core-1_0-final.html#IDTokenValidation">ID token verification</a>.</p>
<h3 id="reading-id-token-values">Reading ID Token Values</h3>
<p>The ID token is in <a href="https://datatracker.ietf.org/doc/html/rfc7519">JSON Web Token (JWT)</a> format and consists of a header, payload, and signature parts, separated by dots {'.'}.</p>
<p>Reading the values of the ID token is straightforward. As an example, assuming a struct:</p>
<pre class="cpp" translate="no">
 <span class="keyword">struct</span> IDToken {
     <span class="type"><a href="../qtcore/qjsonobject.html" translate="no">QJsonObject</a></span> header;
     <span class="type"><a href="../qtcore/qjsonobject.html" translate="no">QJsonObject</a></span> payload;
     <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> signature;
 };
</pre>
<p>And a function:</p>
<pre class="cpp" translate="no">
 std<span class="operator">::</span>optional<span class="operator">&lt;</span>IDToken<span class="operator">&gt;</span> parseIDToken(<span class="keyword">const</span> <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> <span class="operator">&amp;</span>token) <span class="keyword">const</span>;
</pre>
<p>The token can be extracted:</p>
<pre class="cpp" translate="no">
 <span class="keyword">if</span> (token<span class="operator">.</span>isEmpty())
     <span class="keyword">return</span> std<span class="operator">::</span>nullopt;

 <span class="type"><a href="../qtcore/qlist.html" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span><span class="operator">&gt;</span> parts <span class="operator">=</span> token<span class="operator">.</span>toLatin1()<span class="operator">.</span>split(<span class="char">'.'</span>);
 <span class="keyword">if</span> (parts<span class="operator">.</span>size() <span class="operator">!</span><span class="operator">=</span> <span class="number">3</span>)
     <span class="keyword">return</span> std<span class="operator">::</span>nullopt;

 <span class="type"><a href="../qtcore/qjsonparseerror.html" translate="no">QJsonParseError</a></span> parsing;

 <span class="type"><a href="../qtcore/qjsondocument.html" translate="no">QJsonDocument</a></span> header <span class="operator">=</span> <span class="type"><a href="../qtcore/qjsondocument.html" translate="no">QJsonDocument</a></span><span class="operator">::</span>fromJson(
     <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span><span class="operator">::</span>fromBase64(parts<span class="operator">.</span>at(<span class="number">0</span>)<span class="operator">,</span> <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span><span class="operator">::</span>Base64UrlEncoding)<span class="operator">,</span> <span class="operator">&amp;</span>parsing);
 <span class="keyword">if</span> (parsing<span class="operator">.</span>error <span class="operator">!</span><span class="operator">=</span> <span class="type"><a href="../qtcore/qjsonparseerror.html" translate="no">QJsonParseError</a></span><span class="operator">::</span>NoError <span class="operator">|</span><span class="operator">|</span> <span class="operator">!</span>header<span class="operator">.</span>isObject())
     <span class="keyword">return</span> std<span class="operator">::</span>nullopt;

 <span class="type"><a href="../qtcore/qjsondocument.html" translate="no">QJsonDocument</a></span> payload <span class="operator">=</span> <span class="type"><a href="../qtcore/qjsondocument.html" translate="no">QJsonDocument</a></span><span class="operator">::</span>fromJson(
     <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span><span class="operator">::</span>fromBase64(parts<span class="operator">.</span>at(<span class="number">1</span>)<span class="operator">,</span> <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span><span class="operator">::</span>Base64UrlEncoding)<span class="operator">,</span> <span class="operator">&amp;</span>parsing);
 <span class="keyword">if</span> (parsing<span class="operator">.</span>error <span class="operator">!</span><span class="operator">=</span> <span class="type"><a href="../qtcore/qjsonparseerror.html" translate="no">QJsonParseError</a></span><span class="operator">::</span>NoError <span class="operator">|</span><span class="operator">|</span> <span class="operator">!</span>payload<span class="operator">.</span>isObject())
     <span class="keyword">return</span> std<span class="operator">::</span>nullopt;

 <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> signature <span class="operator">=</span> <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span><span class="operator">::</span>fromBase64(parts<span class="operator">.</span>at(<span class="number">2</span>)<span class="operator">,</span> <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span><span class="operator">::</span>Base64UrlEncoding);

 <span class="keyword">return</span> IDToken{header<span class="operator">.</span>object()<span class="operator">,</span> payload<span class="operator">.</span>object()<span class="operator">,</span> signature};
</pre>
<p>In more rare cases the token may be encrypted with <a href="https://datatracker.ietf.org/doc/html/rfc7516">JSON Web Encryption (JWE)</a>, which internally contains a JWT token. In this case the token must be decrypted first.</p>
<h3 id="openid-connect-discovery">OpenID Connect Discovery</h3>
<p><a href="https://openid.net/specs/openid-connect-discovery-1_0.html">OpenID Connect Discovery</a> defines means to discover needed OpenID provider details, in order to interact with it. This includes things such as <code translate="no">authorization_endpoint</code> and <code translate="no">token_endpoint</code> URLs.</p>
<p>While these provider details can be statically configured in the application, discovering the details at runtime may provide more flexibility and robustness in interacting with various providers.</p>
<p>Getting the discovery document is a simple <code translate="no">HTTP GET</code> request. The document is typically located in <code translate="no">https://&lt;the-domain eg. example.com&gt;/.well-known/openid_configuration</code></p>
<pre class="cpp" translate="no">
 m_network<span class="operator">-</span><span class="operator">&gt;</span>get(request<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">[</span><span class="keyword">this</span><span class="operator">]</span>(<span class="type"><a href="../qtnetwork/qrestreply.html" translate="no">QRestReply</a></span> <span class="operator">&amp;</span>reply) {
     <span class="keyword">if</span> (reply<span class="operator">.</span>isSuccess()) {
         <span class="keyword">if</span> (<span class="keyword">auto</span> doc <span class="operator">=</span> reply<span class="operator">.</span>readJson(); doc <span class="operator">&amp;</span><span class="operator">&amp;</span> doc<span class="operator">-</span><span class="operator">&gt;</span>isObject())
             m_oidcConfig <span class="operator">=</span> doc<span class="operator">-</span><span class="operator">&gt;</span>object(); <span class="comment">// Store the configuration</span>
     }
 });
</pre>
<p>Notably, for token validation, the <a href="https://datatracker.ietf.org/doc/html/rfc7517#section-5">jwks_uri</a> field provides a link for accessing the current (public) security credentials. Using that removes the need to hardcode such credentials in the application directly. This also helps with key rotation; the vendors may change the used keys from time to time, and therefore ensuring an up-to-date key is important.</p>
<p>Getting the keys is similarly a simple <code translate="no">HTTP GET</code> request:</p>
<pre class="cpp" translate="no">
 m_network<span class="operator">-</span><span class="operator">&gt;</span>get(request<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">[</span><span class="keyword">this</span><span class="operator">]</span>(<span class="type"><a href="../qtnetwork/qrestreply.html" translate="no">QRestReply</a></span> <span class="operator">&amp;</span>reply) {
     <span class="keyword">if</span> (reply<span class="operator">.</span>isSuccess()) {
         <span class="keyword">if</span> (<span class="keyword">auto</span> doc <span class="operator">=</span> reply<span class="operator">.</span>readJson(); doc <span class="operator">&amp;</span><span class="operator">&amp;</span> doc<span class="operator">-</span><span class="operator">&gt;</span>isObject())
             m_jwks <span class="operator">=</span> doc; <span class="comment">// Use the keys later to verify tokens</span>
     }
 });
</pre>
<p>The key set typically contains several keys. The correct key is indicated in the JWT header (care must be taken to match the keys properly, just checking the key id (<code translate="no">kid</code>) field is not adequate).</p>
<h3 id="openid-userinfo-endpoint">OpenID UserInfo Endpoint</h3>
<p>An alternative way to access user information is to use <a href="https://openid.net/specs/openid-connect-core-1_0-final.html#UserInfo">OpenID UserInfo Endpoint</a>, if the OIDC provider supports it. The URL for the userinfo is in <code translate="no">userinfo_endpoint</code> field of the <a href="qt-oauth2-overview.html#openid-connect-discovery">OpenID Connect Discovery</a> document.</p>
<p>The userinfo endpoint does not use the ID token, but is accessed with the access token. Accessing the userinfo is similar to accessing any other resource with an access token.</p>
<p>Assuming the access token is received and set for example by:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="../qtnetwork/qnetworkrequestfactory.html" translate="no">QNetworkRequestFactory</a></span> userInfoApi(url);
 userInfoApi<span class="operator">.</span>setBearerToken(m_oauth<span class="operator">.</span>token()<span class="operator">.</span>toLatin1());
</pre>
<p>Then accessing the userinfo is a <code translate="no">HTTP GET</code> request:</p>
<pre class="cpp" translate="no">
 m_network<span class="operator">-</span><span class="operator">&gt;</span>get(userInfoApi<span class="operator">.</span>createRequest()<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">[</span><span class="keyword">this</span><span class="operator">]</span>(<span class="type"><a href="../qtnetwork/qrestreply.html" translate="no">QRestReply</a></span> <span class="operator">&amp;</span>reply) {
     <span class="keyword">if</span> (reply<span class="operator">.</span>isSuccess()) {
         <span class="keyword">if</span> (<span class="keyword">auto</span> doc <span class="operator">=</span> reply<span class="operator">.</span>readJson(); doc <span class="operator">&amp;</span><span class="operator">&amp;</span> doc<span class="operator">-</span><span class="operator">&gt;</span>isObject())
             <a href="../qtcore/qtlogging.html#qDebug" translate="no">qDebug</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> doc<span class="operator">-</span><span class="operator">&gt;</span>object(); <span class="comment">// Use the userinfo</span>
     }
 });
</pre>
</div>
<!-- @@@qt-oauth2-overview.html -->
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <abbr title="Copyright">&copy;</abbr> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
