<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qhttpserver.cpp -->
  <meta name="description" content="QHttpServer is a simplified API for QAbstractHttpServer and QHttpServerRouter.">
  <title>QHttpServer Class | Qt HTTP Server | Qt 6.9.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li>Qt 6.9</li>
<li><a href="qthttpserver-index.html">Qt HTTP Server</a></li>
<li><a href="qthttpserver-module.html" translate="no">C++ Classes</a></li>
<li>QHttpServer</li>
<li id="buildversion"><a href="qthttpserver-index.html">Qt 6.9.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QHttpServer Class</h1>
<!-- $$$QHttpServer-brief -->
<p>QHttpServer is a simplified API for <a href="qabstracthttpserver.html" translate="no">QAbstractHttpServer</a> and <a href="qhttpserverrouter.html" translate="no">QHttpServerRouter</a>. <a href="#details">More...</a></p>
<!-- @@@QHttpServer -->
<div class="table"><table class="alignedsummary requisites" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign"> <code translate="no">#include &lt;QHttpServer&gt;</code></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> <code translate="no">find_package(Qt6 REQUIRED COMPONENTS HttpServer)</code><br/>
<code translate="no">target_link_libraries(mytarget PRIVATE Qt6::HttpServer)</code></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> <code translate="no">QT += httpserver</code></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 6.4</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="qabstracthttpserver.html" translate="no">QAbstractHttpServer</a></td></tr>
</table></div>
<ul>
<li><a href="qhttpserver-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qhttpserver.html#QHttpServer" translate="no">QHttpServer</a></b>(QObject *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qhttpserver.html#dtor.QHttpServer" translate="no">~QHttpServer</a></b>() override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qhttpserver.html#addAfterRequestHandler" translate="no">addAfterRequestHandler</a></b>(const QObject *<i>context</i>, Functor &amp;&amp;<i>slot</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qhttpserver.html#clearMissingHandler" translate="no">clearMissingHandler</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Rule *</td><td class="memItemRight bottomAlign"><b><a href="qhttpserver.html#route" translate="no">route</a></b>(const QString &amp;<i>pathPattern</i>, QHttpServerRequest::Methods <i>method</i>, const QObject *<i>context</i>, Functor &amp;&amp;<i>slot</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Rule *</td><td class="memItemRight bottomAlign"><b><a href="qhttpserver.html#route-1" translate="no">route</a></b>(const QString &amp;<i>pathPattern</i>, Functor &amp;&amp;<i>handler</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Rule *</td><td class="memItemRight bottomAlign"><b><a href="qhttpserver.html#route-2" translate="no">route</a></b>(const QString &amp;<i>pathPattern</i>, QHttpServerRequest::Methods <i>method</i>, Functor &amp;&amp;<i>handler</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Rule *</td><td class="memItemRight bottomAlign"><b><a href="qhttpserver.html#route-3" translate="no">route</a></b>(const QString &amp;<i>pathPattern</i>, const QObject *<i>context</i>, Functor &amp;&amp;<i>slot</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QHttpServerRouter *</td><td class="memItemRight bottomAlign"><b><a href="qhttpserver.html#router" translate="no">router</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QHttpServerRouter *</td><td class="memItemRight bottomAlign"><b><a href="qhttpserver.html#router-1" translate="no">router</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qhttpserver.html#setMissingHandler" translate="no">setMissingHandler</a></b>(const QObject *<i>context</i>, Functor &amp;&amp;<i>slot</i>)</td></tr>
</table></div>
<!-- $$$QHttpServer-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>QHttpServer is used to create a simple HTTP server by registering a range of request handlers.</p>
<p>The <a href="qhttpserver.html#route" translate="no">route</a> function can be used to conveniently add rules to the server's <a href="qhttpserverrouter.html" translate="no">QHttpServerRouter</a>. To register a handler that is called after every request to further process the response use <a href="qhttpserver.html#addAfterRequestHandler" translate="no">addAfterRequestHandler</a>, but this mechanism only works for routes returning <a href="qhttpserverresponse.html" translate="no">QHttpServerResponse</a> or <code translate="no">QFuture&lt;QHttpServerResponse&gt;</code>. To register a handler for all unhandled requests use <a href="qhttpserver.html#setMissingHandler" translate="no">setMissingHandler</a>.</p>
<p>Minimal example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qhttpserver.html#QHttpServer" translate="no">QHttpServer</a></span> server;

 server<span class="operator">.</span>route(<span class="string">&quot;/&quot;</span><span class="operator">,</span> <span class="operator">[</span><span class="operator">]</span> () {
     <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;
 });

 <span class="keyword">auto</span> tcpserver <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="../qtnetwork/qtcpserver.html" translate="no">QTcpServer</a></span>();
 <span class="keyword">if</span> (<span class="operator">!</span>tcpserver<span class="operator">-</span><span class="operator">&gt;</span>listen() <span class="operator">|</span><span class="operator">|</span> <span class="operator">!</span>server<span class="operator">.</span>bind(tcpserver)) {
     <span class="keyword">delete</span> tcpserver;
     <span class="keyword">return</span> <span class="operator">-</span><span class="number">1</span>;
 }
 <a href="../qtcore/qtlogging.html#qDebug" translate="no">qDebug</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;Listening on port&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> tcpserver<span class="operator">-</span><span class="operator">&gt;</span>serverPort();
</pre>
</div>
<!-- @@@QHttpServer -->
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QHttpServer[overload1]$$$QHttpServerQObject* -->
<h3 class="fn" translate="no" id="QHttpServer"><code class="details extra" translate="no">[explicit]</code> QHttpServer::<span class="name">QHttpServer</span>(<span class="type"><a href="../qtcore/qobject.html#QObject" translate="no">QObject</a></span> *<i>parent</i> = nullptr)</h3>
<p>Creates an instance of QHttpServer with parent <i translate="no">parent</i>.</p>
<!-- @@@QHttpServer -->
<!-- $$$~QHttpServer[overload1]$$$~QHttpServer -->
<h3 class="fn" translate="no" id="dtor.QHttpServer"><code class="details extra" translate="no">[override virtual noexcept]</code> QHttpServer::<span class="name">~QHttpServer</span>()</h3>
<p>Destroys a <a href="qhttpserver.html" translate="no">QHttpServer</a>.</p>
<!-- @@@~QHttpServer -->
<!-- $$$addAfterRequestHandler[overload1]$$$addAfterRequestHandlerconstQObject*Functor&& -->
<h3 class="fn" translate="no" id="addAfterRequestHandler">template &lt;typename Functor&gt; <span class="type">void</span> QHttpServer::<span class="name">addAfterRequestHandler</span>(const <span class="type"><a href="../qtcore/qobject.html#QObject" translate="no">QObject</a></span> *<i>context</i>, <span class="type">Functor</span> &amp;&amp;<i>slot</i>)</h3>
<p>Register a <i translate="no">context</i> and <i translate="no">slot</i> to be called after each request is handled.</p>
<p>The <i translate="no">slot</i> has to implement the signature <code translate="no">void (*)(const QHttpServerRequest &amp;, QHttpServerResponse &amp;)</code>.</p>
<p>The <i translate="no">slot</i> can also be a function pointer, non-mutable lambda, or any other copyable callable with const call operator. In that case the <i translate="no">context</i> will be a context object and the handler will be valid until the context object is destroyed.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 server<span class="operator">.</span>addAfterRequestHandler(<span class="operator">&amp;</span>server<span class="operator">,</span> <span class="operator">[</span><span class="operator">]</span> (<span class="keyword">const</span> <span class="type"><a href="qhttpserverrequest.html" translate="no">QHttpServerRequest</a></span> <span class="operator">&amp;</span>req<span class="operator">,</span> <span class="type"><a href="qhttpserverresponse.html" translate="no">QHttpServerResponse</a></span> <span class="operator">&amp;</span>resp) {
     <span class="keyword">auto</span> h <span class="operator">=</span> resp<span class="operator">.</span>headers();
     h<span class="operator">.</span>append(<span class="type"><a href="../qtnetwork/qhttpheaders.html" translate="no">QHttpHeaders</a></span><span class="operator">::</span>WellKnownHeader<span class="operator">::</span>Cookie<span class="operator">,</span> <span class="string">&quot;PollyWants=Cracker&quot;</span>);
     resp<span class="operator">.</span>setHeaders(std<span class="operator">::</span>move(h));
 }
</pre>
<div class="admonition note">
<p><b>Note: </b>These handlers will only be called for requests that are processed by route handlers that either return <a href="qhttpserverresponse.html" translate="no">QHttpServerResponse</a> or <a href="../qtcore/qfuture.html" translate="no">QFuture</a>&lt;<a href="qhttpserverresponse.html" translate="no">QHttpServerResponse</a>&gt;, and therefore do not take a <a href="qhttpserverresponder.html" translate="no">QHttpServerResponder</a> argument.</p>
</div>
<!-- @@@addAfterRequestHandler -->
<!-- $$$clearMissingHandler[overload1]$$$clearMissingHandler -->
<h3 class="fn" translate="no" id="clearMissingHandler"><span class="type">void</span> QHttpServer::<span class="name">clearMissingHandler</span>()</h3>
<p>Resets the handler to the default one that produces replies with status <code translate="no">404 Not Found</code>.</p>
<p><b>See also </b><a href="qhttpserver.html#setMissingHandler" translate="no">setMissingHandler</a>.</p>
<!-- @@@clearMissingHandler -->
<!-- $$$route[overload1]$$$routeconstQString&QHttpServerRequest::MethodsconstQObject*Functor&& -->
<h3 class="fn" translate="no" id="route">template &lt;typename Rule = QHttpServerRouterRule, typename Functor&gt; <span class="type">Rule</span> *QHttpServer::<span class="name">route</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>pathPattern</i>, <span class="type"><a href="qhttpserverrequest.html#Method-enum" translate="no">QHttpServerRequest::Methods</a></span> <i>method</i>, const <span class="type"><a href="../qtcore/qobject.html#QObject" translate="no">QObject</a></span> *<i>context</i>, <span class="type">Functor</span> &amp;&amp;<i>slot</i>)</h3>
<p>This method is used to add a new <code translate="no">Rule</code> to the server's <a href="qhttpserverrouter.html" translate="no">QHttpServerRouter</a> member. The <code translate="no">Rule</code> template parameter can be any custom class derived from <a href="qhttpserverrouterrule.html" translate="no">QHttpServerRouterRule</a>. The parameters are passed to <code translate="no">Rule</code>. When handling the incoming HTTP requests, the <a href="qhttpserverrouter.html" translate="no">QHttpServerRouter</a> matches the <code translate="no">Rule</code> to the incoming HTTP request using the URL and HTTP method, and the first match of both is executed. The <i translate="no">pathPattern</i> parameter is compared with the <a href="../qtcore/qurl.html#path" translate="no">path</a>() of the URL of the incoming request. The <i translate="no">method</i> parameter is compared with the HTTP method of the incoming request.</p>
<p>The <i translate="no">slot</i> parameter can be a member function pointer of <i translate="no">context</i>. It can also be a function pointer, a non-mutable lambda, or any other copyable callable with const call operator. The rule will be valid for the lifetime duration of <i translate="no">context</i>. The <i translate="no">context</i> must share the same thread affinity as the <a href="qhttpserver.html" translate="no">QHttpServer</a> for the registration to be successful and for the rule to be executed.</p>
<p>The slot can express its response with a return statement. In that case the function has to return <a href="qhttpserverresponse.html" translate="no">QHttpServerResponse</a> or any type that can be converted to <a href="qhttpserverresponse.html" translate="no">QHttpServerResponse</a>. A large range of conversion constructors are available, see <a href="qhttpserverresponse.html" translate="no">QHttpServerResponse</a>.</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qhttpserver.html#QHttpServer" translate="no">QHttpServer</a></span> server;
 server<span class="operator">.</span>route(<span class="string">&quot;/test/&quot;</span><span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">[</span><span class="operator">]</span> () { <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; });
</pre>
<p>Alternatively, an optional <a href="qhttpserverresponder.html" translate="no">QHttpServerResponder</a>&amp; argument can be provided, in which case the response has to be written using it and the function must return <code translate="no">void</code>.</p>
<pre class="cpp" translate="no">
 server<span class="operator">.</span>route(<span class="string">&quot;/test2&quot;</span><span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">[</span><span class="operator">]</span> (<span class="type"><a href="qhttpserverresponder.html" translate="no">QHttpServerResponder</a></span> <span class="operator">&amp;</span>responder) {
                                 responder<span class="operator">.</span>write(<span class="type"><a href="qhttpserverresponder.html" translate="no">QHttpServerResponder</a></span><span class="operator">::</span>StatusCode<span class="operator">::</span>Forbidden); });
</pre>
<p>The <i translate="no">slot</i> can also have <code translate="no">const</code> <a href="qhttpserverrequest.html" translate="no">QHttpServerRequest</a>&amp; as the last parameter, or as the second to last if the <a href="qhttpserverresponder.html" translate="no">QHttpServerResponder</a>&amp; is the last parameter. It contains detailed information on the request.</p>
<pre class="cpp" translate="no">
 server<span class="operator">.</span>route(<span class="string">&quot;/test3&quot;</span><span class="operator">,</span> <span class="type"><a href="qhttpserverrequest.html" translate="no">QHttpServerRequest</a></span><span class="operator">::</span>Method<span class="operator">::</span>Post<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span>
              <span class="operator">[</span><span class="operator">]</span> (<span class="keyword">const</span> <span class="type"><a href="qhttpserverrequest.html" translate="no">QHttpServerRequest</a></span> <span class="operator">&amp;</span>request<span class="operator">,</span> <span class="type"><a href="qhttpserverresponder.html" translate="no">QHttpServerResponder</a></span> <span class="operator">&amp;</span>responder) {
                  responder<span class="operator">.</span>write(request<span class="operator">.</span>body()<span class="operator">,</span> <span class="string">&quot;text/plain&quot;</span>_ba);
              });
</pre>
<p>The <i translate="no">slot</i> can also take any amount of copyable parameters that can have the types available from <a href="qhttpserverrouter.html#converters" translate="no">QHttpServerRouter::converters</a>(). By default, these are most integer types, float, double, <a href="../qtcore/qstring.html" translate="no">QString</a>, <a href="../qtcore/qbytearray.html" translate="no">QByteArray</a>, and <a href="../qtcore/qurl.html" translate="no">QUrl</a>. Converters for additional types can be added by calling <a href="qhttpserverrouter.html#addConverter" translate="no">QHttpServerRouter::addConverter</a>().</p>
<p>The <i translate="no">pathPattern</i> can contain a number of <code translate="no">&quot;&lt;arg&gt;&quot;</code> substrings that are matched with the parameters of <i translate="no">slot</i> from left to right. The converters are chosen based on the types of these parameters.</p>
<p>Each registered type has an associated regex that is used to match and convert occurrences of <code translate="no">&quot;&lt;arg&gt;&quot;</code> in the <i translate="no">pathPattern</i>. These regex patterns are combined to construct a parser for the entire path. The resulting parser is then used to verify if the path matches the pattern. If parsing succeeds, the corresponding function is called with the converted parameters. If parsing fails, the next registered callback is attempted.</p>
<p>In the example below, the value in the request path replacing <code translate="no">&quot;&lt;arg&gt;&quot;</code> is converted to an <code translate="no">int</code> because the lambda expects an <code translate="no">int</code> parameter. When an HTTP request matches the route, the converted value is passed to the lambda's <code translate="no">page</code> argument:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qhttpserver.html#QHttpServer" translate="no">QHttpServer</a></span> server;
 server<span class="operator">.</span>route(<span class="string">&quot;/showpage/&lt;arg&gt;&quot;</span><span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">[</span><span class="operator">]</span> (<span class="keyword">const</span> <span class="type">int</span> page) { <span class="keyword">return</span> getPage(page); });
</pre>
<p>This function returns, if successful, a pointer to the newly created Rule, otherwise a <code translate="no">nullptr</code>. The pointer can be used to set parameters on any custom <a href="qhttpserverrouter.html" translate="no">QHttpServerRouter</a> class:</p>
<pre class="cpp" translate="no">
 <span class="keyword">auto</span> rule <span class="operator">=</span> server<span class="operator">.</span>route<span class="operator">&lt;</span>MyRule<span class="operator">&gt;</span>(<span class="string">&quot;/test4&quot;</span><span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">[</span><span class="operator">]</span> () {<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;});
 rule<span class="operator">-</span><span class="operator">&gt;</span>setParameter(<span class="string">&quot;test&quot;</span>);
</pre>
<div class="admonition note">
<p><b>Note: </b>This function, route, must not be called from <i translate="no">slot</i>, so no route handlers can register other route handlers.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>If a request was processed by a <i translate="no">slot</i> accepting <a href="qhttpserverresponder.html" translate="no">QHttpServerResponder</a>&amp; as an argument, none of the after request handlers (see <a href="qhttpserver.html#addAfterRequestHandler" translate="no">addAfterRequestHandler</a>) will be called.</p>
</div>
<p>Requests are processed sequentially inside the <a href="qhttpserver.html" translate="no">QHttpServer</a>'s thread by default. The request handler may return <code translate="no">QFuture&lt;QHttpServerResponse&gt;</code> if concurrent processing is desired:</p>
<pre class="cpp" translate="no">
 server<span class="operator">.</span>route(<span class="string">&quot;/feature/&lt;arg&gt;&quot;</span><span class="operator">,</span> <span class="operator">[</span><span class="operator">]</span> (<span class="type">int</span> ms) {
     <span class="keyword">return</span> <span class="type">QtConcurrent</span><span class="operator">::</span>run(<span class="operator">[</span>ms<span class="operator">]</span> () {
         <span class="type"><a href="../qtcore/qthread.html" translate="no">QThread</a></span><span class="operator">::</span>msleep(ms);
         <span class="keyword">return</span> <span class="type"><a href="qhttpserverresponse.html" translate="no">QHttpServerResponse</a></span>(<span class="string">&quot;the future is coming&quot;</span>);
     });
 });
</pre>
<p>The lambda of the QtConcurrent::run() is executed concurrently, but all the network communication is executed sequentially in the thread the <code translate="no">QHttpServer</code> belongs to after the <a href="../qtcore/qfuture.html" translate="no">QFuture</a> is done. Be aware that any <a href="qhttpserverrequest.html" translate="no">QHttpServerRequest</a> object is passed by reference to the callback. Extract all needed content before QtConcurrent::run() is called.</p>
<p>The <a href="qhttpserverresponder.html" translate="no">QHttpServerResponder</a>&amp; special argument is only available for routes returning <code translate="no">void</code>. When using a responder object the response is returned using it.</p>
<p><b>See also </b><a href="qhttpserverrouter.html#addRule" translate="no">QHttpServerRouter::addRule</a> and <a href="qhttpserver.html#addAfterRequestHandler" translate="no">addAfterRequestHandler</a>.</p>
<!-- @@@route -->
<!-- $$$route$$$routeconstQString&Functor&& -->
<h3 class="fn" translate="no" id="route-1">template &lt;typename Rule = QHttpServerRouterRule, typename Functor&gt; <span class="type">Rule</span> *QHttpServer::<span class="name">route</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>pathPattern</i>, <span class="type">Functor</span> &amp;&amp;<i>handler</i>)</h3>
<p>This is an overloaded function.</p>
<p>Overload of <a href="qhttpserver.html#route" translate="no">QHttpServer::route</a> to create a Rule for <i translate="no">pathPattern</i> and <a href="qhttpserverrequest.html#Method-enum" translate="no">QHttpServerRequest::Method::AnyKnown</a>. All requests are forwarded to <i translate="no">handler</i>, which can be a function pointer, a non-mutable lambda, or any other copyable callable with const call operator. The rule will be valid until the <a href="qhttpserver.html" translate="no">QHttpServer</a> is destroyed.</p>
<!-- @@@route -->
<!-- $$$route$$$routeconstQString&QHttpServerRequest::MethodsFunctor&& -->
<h3 class="fn" translate="no" id="route-2">template &lt;typename Rule = QHttpServerRouterRule, typename Functor&gt; <span class="type">Rule</span> *QHttpServer::<span class="name">route</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>pathPattern</i>, <span class="type"><a href="qhttpserverrequest.html#Method-enum" translate="no">QHttpServerRequest::Methods</a></span> <i>method</i>, <span class="type">Functor</span> &amp;&amp;<i>handler</i>)</h3>
<p>This is an overloaded function.</p>
<p>Overload of <a href="qhttpserver.html#route" translate="no">QHttpServer::route</a> to create a Rule for <i translate="no">pathPattern</i> and <i translate="no">method</i>. All requests are forwarded to <i translate="no">handler</i>, which can be a function pointer, a non-mutable lambda, or any other copyable callable with const call operator. The rule will be valid until the <a href="qhttpserver.html" translate="no">QHttpServer</a> is destroyed.</p>
<!-- @@@route -->
<!-- $$$route$$$routeconstQString&constQObject*Functor&& -->
<h3 class="fn" translate="no" id="route-3">template &lt;typename Rule = QHttpServerRouterRule, typename Functor&gt; <span class="type">Rule</span> *QHttpServer::<span class="name">route</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>pathPattern</i>, const <span class="type"><a href="../qtcore/qobject.html#QObject" translate="no">QObject</a></span> *<i>context</i>, <span class="type">Functor</span> &amp;&amp;<i>slot</i>)</h3>
<p>This is an overloaded function.</p>
<p>Overload of <a href="qhttpserver.html#route" translate="no">QHttpServer::route</a> to create a Rule for <i translate="no">pathPattern</i> and the method <a href="qhttpserverrequest.html#Method-enum" translate="no">QHttpServerRequest::Method::AnyKnown</a>. All requests are forwarded to <i translate="no">context</i> and <i translate="no">slot</i>.</p>
<!-- @@@route -->
<!-- $$$router[overload1]$$$router -->
<h3 class="fn" translate="no" id="router"><span class="type"><a href="qhttpserverrouter.html" translate="no">QHttpServerRouter</a></span> *QHttpServer::<span class="name">router</span>()</h3>
<p>Returns a pointer to the router object.</p>
<!-- @@@router -->
<!-- $$$router$$$router -->
<h3 class="fn" translate="no" id="router-1">const <span class="type"><a href="qhttpserverrouter.html" translate="no">QHttpServerRouter</a></span> *QHttpServer::<span class="name">router</span>() const</h3>
<p>Returns a pointer to the constant router object.</p>
<!-- @@@router -->
<!-- $$$setMissingHandler[overload1]$$$setMissingHandlerconstQObject*Functor&& -->
<h3 class="fn" translate="no" id="setMissingHandler">template &lt;typename Functor&gt; <span class="type">void</span> QHttpServer::<span class="name">setMissingHandler</span>(const <span class="type"><a href="../qtcore/qobject.html#QObject" translate="no">QObject</a></span> *<i>context</i>, <span class="type">Functor</span> &amp;&amp;<i>slot</i>)</h3>
<p>Set a handler for unhandled requests.</p>
<p>All unhandled requests will be forwarded to the <i translate="no">context</i>'s <i translate="no">slot</i>.</p>
<p>The <i translate="no">slot</i> has to implement the signature <code translate="no">void (*)(const QHttpServerRequest &amp;, QHttpServerResponder &amp;)</code>. The <i translate="no">slot</i> can also be a function pointer, non-mutable lambda, or any other copyable callable with const call operator. In that case the <i translate="no">context</i> will be a context object. The handler will be valid until the context object is destroyed.</p>
<p>The default handler replies with status <code translate="no">404 Not Found</code>.</p>
<p><b>See also </b><a href="qhttpserver.html#clearMissingHandler" translate="no">clearMissingHandler</a>.</p>
<!-- @@@setMissingHandler -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <abbr title="Copyright">&copy;</abbr> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
