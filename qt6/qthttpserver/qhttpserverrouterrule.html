<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qhttpserverrouterrule.cpp -->
  <meta name="description" content="The QHttpServerRouterRule is the base class for QHttpServerRouter rules.">
  <title>QHttpServerRouterRule Class | Qt HTTP Server | Qt 6.9.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li>Qt 6.9</li>
<li><a href="qthttpserver-index.html">Qt HTTP Server</a></li>
<li><a href="qthttpserver-module.html" translate="no">C++ Classes</a></li>
<li>QHttpServerRouterRule</li>
<li id="buildversion"><a href="qthttpserver-index.html">Qt 6.9.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#static-public-members">Static Public Members</a></li>
<li class="level1"><a href="#protected-functions">Protected Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
<li class="level2"><a href="#path-and-patterns">Path and Patterns</a></li>
<li class="level2"><a href="#request-method">Request Method</a></li>
<li class="level2"><a href="#handler-signature">Handler Signature</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QHttpServerRouterRule Class</h1>
<!-- $$$QHttpServerRouterRule-brief -->
<p>The QHttpServerRouterRule is the base class for <a href="qhttpserverrouter.html" translate="no">QHttpServerRouter</a> rules. <a href="#details">More...</a></p>
<!-- @@@QHttpServerRouterRule -->
<div class="table"><table class="alignedsummary requisites" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign"> <code translate="no">#include &lt;QHttpServerRouterRule&gt;</code></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> <code translate="no">find_package(Qt6 REQUIRED COMPONENTS HttpServer)</code><br/>
<code translate="no">target_link_libraries(mytarget PRIVATE Qt6::HttpServer)</code></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> <code translate="no">QT += httpserver</code></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 6.4</td></tr>
</table></div>
<ul>
<li><a href="qhttpserverrouterrule-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qhttpserverrouterrule.html#QHttpServerRouterRule" translate="no">QHttpServerRouterRule</a></b>(const QString &amp;<i>pathPattern</i>, const QHttpServerRequest::Methods <i>methods</i>, const QObject *<i>receiver</i>, Functor &amp;&amp;<i>slot</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qhttpserverrouterrule.html#QHttpServerRouterRule-4" translate="no">QHttpServerRouterRule</a></b>(const QString &amp;<i>pathPattern</i>, const QObject *<i>receiver</i>, Functor &amp;&amp;<i>slot</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qhttpserverrouterrule.html#dtor.QHttpServerRouterRule" translate="no">~QHttpServerRouterRule</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QObject *</td><td class="memItemRight bottomAlign"><b><a href="qhttpserverrouterrule.html#contextObject" translate="no">contextObject</a></b>() const</td></tr>
</table></div>
<h2 id="static-public-members">Static Public Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> typename ViewTraits::BindableType </td><td class="memItemRight bottomAlign"><b><a href="qhttpserverrouterrule.html#bindCaptured" translate="no">bindCaptured</a></b>(QObject *<i>receiver</i>, Functor &amp;&amp;<i>slot</i>, const QRegularExpressionMatch &amp;<i>match</i>)</td></tr>
</table></div>
<h2 id="protected-functions">Protected Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qhttpserverrouterrule.html#exec" translate="no">exec</a></b>(const QHttpServerRequest &amp;<i>request</i>, QHttpServerResponder &amp;<i>responder</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qhttpserverrouterrule.html#hasValidMethods" translate="no">hasValidMethods</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qhttpserverrouterrule.html#matches" translate="no">matches</a></b>(const QHttpServerRequest &amp;<i>request</i>, QRegularExpressionMatch *<i>match</i>) const</td></tr>
</table></div>
<!-- $$$QHttpServerRouterRule-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>QHttpServerRouterRule expresses the connection between a request path, an HTTP request method, and the respective handler callback. The <a href="qhttpserverrouter.html" translate="no">QHttpServerRouter</a> is a collection of such rules from which the handlers are called if the path and request method match the request. The handler callback must provide the response to the request.</p>
<h3 id="path-and-patterns">Path and Patterns</h3>
<p>Every QHttpServerRouterRule contains a path or path pattern which defines the paths for which it can provide a response through its handler. The path can contain placeholders that are forwarded to the rule's handler. The following examples of path patterns are shown with the <a href="qhttpserver.html#route" translate="no">QHttpServer::route</a>() convenience method, but can also be provided to the QHttpServerRouterRule constructor.</p>
<p>In the simplest case the path is a string with a leading <code translate="no">&quot;/&quot;</code>:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qhttpserver.html" translate="no">QHttpServer</a></span> server;
 server<span class="operator">.</span>route(<span class="string">&quot;/user&quot;</span><span class="operator">,</span> <span class="operator">[</span><span class="operator">]</span> () { <span class="keyword">return</span> <span class="string">&quot;hello user&quot;</span>; } );
</pre>
<p>This path pattern creates a rule that forwards all requests with <code translate="no">&quot;/user&quot;</code> to the provided handler, which in this case is a simple lambda (Note that the handler syntax would look different when using QHttpServerRouterRule directly, see below).</p>
<p>The path pattern can further contain a trailing <code translate="no">&quot;/&quot;</code> to create a rule that addresses a collection of paths with arguments after the trailing <code translate="no">&quot;/&quot;</code>. Using the <a href="qhttpserver.html#route" translate="no">QHttpServer::route</a> convenience method the argument is directly forwarded to the lambda:</p>
<pre class="cpp" translate="no">
 server<span class="operator">.</span>route(<span class="string">&quot;/user/&quot;</span><span class="operator">,</span> <span class="operator">[</span><span class="operator">]</span> ( <span class="type"><a href="../qtcore/qttypes.html#qint64-typedef" translate="no">qint64</a></span> id ) { <span class="keyword">return</span> <span class="string">&quot;hello user&quot;</span>; } );
</pre>
<p>This would match the request paths <code translate="no">&quot;/user/1&quot;</code>, <code translate="no">&quot;/user/2&quot;</code> and so on.</p>
<p>The argument can be positioned freely within the path pattern by using the <code translate="no">&quot;&lt;arg&gt;&quot;</code> placeholder. This keyword further allows multiple placeholders.</p>
<pre class="cpp" translate="no">
 server<span class="operator">.</span>route(<span class="string">&quot;/user/&lt;arg&gt;/history&quot;</span><span class="operator">,</span> <span class="operator">[</span><span class="operator">]</span> (<span class="type"><a href="../qtcore/qttypes.html#qint64-typedef" translate="no">qint64</a></span> id){ <span class="keyword">return</span> <span class="string">&quot;hello user&quot;</span>; } );
 server<span class="operator">.</span>route(<span class="string">&quot;/user/&lt;arg&gt;/history/&quot;</span><span class="operator">,</span> <span class="operator">[</span><span class="operator">]</span> (<span class="type"><a href="../qtcore/qttypes.html#qint64-typedef" translate="no">qint64</a></span> id<span class="operator">,</span> <span class="type"><a href="../qtcore/qttypes.html#qint64-typedef" translate="no">qint64</a></span> page){ <span class="keyword">return</span> <span class="string">&quot;hello user&quot;</span>; } );
</pre>
<p>This would, for example, match the request path <code translate="no">&quot;/user/1/history/2&quot;</code>. All types which are registered in <a href="qhttpserverrouter.html#converters" translate="no">QHttpServerRouter::converters</a>() can be used in the callback and the respective placeholder.</p>
<h3 id="request-method">Request Method</h3>
<p>Request method is simply one of <a href="qhttpserverrequest.html#Method-enum" translate="no">QHttpServerRequest::Method</a>. If no method is provided to any overload of the Rule construction, the rule will match any request method.</p>
<h3 id="handler-signature">Handler Signature</h3>
<p>The handler is a callback with the signature</p>
<pre class="cpp" translate="no">
 <span class="type">void</span> (<span class="operator">*</span>)(<span class="keyword">const</span> <span class="type"><a href="../qtcore/qregularexpressionmatch.html" translate="no">QRegularExpressionMatch</a></span> <span class="operator">&amp;</span><span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="qhttpserverrequest.html" translate="no">QHttpServerRequest</a></span> <span class="operator">&amp;</span><span class="operator">,</span> <span class="type"><a href="qhttpserverresponder.html" translate="no">QHttpServerResponder</a></span> <span class="operator">&amp;</span>);
</pre>
<p>The handler callback receives any matched placeholders as its first argument. The second argument contains details about the request and the response has to be written on the last argument by the handler.</p>
<p>The following code example shows how new rules with the respective handler can be created and added to a <a href="qhttpserverrouter.html" translate="no">QHttpServerRouter</a>:</p>
<pre class="cpp" translate="no">
 <span class="keyword">template</span><span class="operator">&lt;</span><span class="keyword">typename</span> ViewHandler<span class="operator">&gt;</span>
 <span class="type">void</span> route(<span class="keyword">const</span> <span class="type">char</span> <span class="operator">*</span>path<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="qhttpserverrequest.html" translate="no">QHttpServerRequest</a></span><span class="operator">::</span>Methods methods<span class="operator">,</span> ViewHandler <span class="operator">&amp;</span><span class="operator">&amp;</span>viewHandler)
 {
     <span class="keyword">auto</span> rule <span class="operator">=</span> std<span class="operator">::</span>make_unique<span class="operator">&lt;</span><span class="type"><a href="qhttpserverrouterrule.html#QHttpServerRouterRule" translate="no">QHttpServerRouterRule</a></span><span class="operator">&gt;</span>(
             path<span class="operator">,</span> methods<span class="operator">,</span> <span class="operator">[</span><span class="keyword">this</span><span class="operator">,</span> viewHandler <span class="operator">=</span> std<span class="operator">::</span>forward<span class="operator">&lt;</span>ViewHandler<span class="operator">&gt;</span>(viewHandler)<span class="operator">]</span>
                                             (<span class="type"><a href="../qtcore/qregularexpressionmatch.html" translate="no">QRegularExpressionMatch</a></span> <span class="operator">&amp;</span>match<span class="operator">,</span>
                                              <span class="keyword">const</span> <span class="type"><a href="qhttpserverrequest.html" translate="no">QHttpServerRequest</a></span> <span class="operator">&amp;</span>request<span class="operator">,</span>
                                              <span class="type"><a href="qhttpserverresponder.html" translate="no">QHttpServerResponder</a></span> <span class="operator">&amp;</span>responder) <span class="keyword">mutable</span> {
         <span class="keyword">auto</span> boundViewHandler <span class="operator">=</span> <span class="type"><a href="qhttpserverrouterrule.html#QHttpServerRouterRule" translate="no">QHttpServerRouterRule</a></span><span class="operator">::</span>bindCaptured<span class="operator">&lt;</span>ViewHandler<span class="operator">&gt;</span>(
                 <span class="keyword">this</span><span class="operator">,</span> std<span class="operator">::</span>move(viewHandler)<span class="operator">,</span> match);
         <span class="comment">// call viewHandler</span>
         boundViewHandler();
     });

 <span class="comment">// QHttpServerRouter</span>
 router<span class="operator">.</span>addRule<span class="operator">&lt;</span>ViewHandler<span class="operator">&gt;</span>(std<span class="operator">::</span>move(rule));
 }

 <span class="comment">// Valid:</span>
 route(<span class="string">&quot;/user/&quot;</span><span class="operator">,</span> <span class="operator">[</span><span class="operator">]</span> (<span class="type"><a href="../qtcore/qttypes.html#qint64-typedef" translate="no">qint64</a></span> id) { } );                            <span class="comment">// &quot;/user/1&quot;</span>
                                                                  <span class="comment">// &quot;/user/3&quot;</span>
                                                                  <span class="comment">//</span>
 route(<span class="string">&quot;/user/&lt;arg&gt;/history&quot;</span><span class="operator">,</span> <span class="operator">[</span><span class="operator">]</span> (<span class="type"><a href="../qtcore/qttypes.html#qint64-typedef" translate="no">qint64</a></span> id) { } );               <span class="comment">// &quot;/user/1/history&quot;</span>
                                                                  <span class="comment">// &quot;/user/2/history&quot;</span>
                                                                  <span class="comment">//</span>
 route(<span class="string">&quot;/user/&lt;arg&gt;/history/&quot;</span><span class="operator">,</span> <span class="operator">[</span><span class="operator">]</span> (<span class="type"><a href="../qtcore/qttypes.html#qint64-typedef" translate="no">qint64</a></span> id<span class="operator">,</span> <span class="type"><a href="../qtcore/qttypes.html#qint64-typedef" translate="no">qint64</a></span> page) { } ); <span class="comment">// &quot;/user/1/history/1&quot;</span>
                                                                  <span class="comment">// &quot;/user/2/history/2&quot;</span>
</pre>
<div class="admonition note">
<p><b>Note: </b>This is a low level API, see <a href="qhttpserver.html" translate="no">QHttpServer</a> for higher level alternatives.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Regular expressions in the path pattern are not supported, but can be registered (to match a use of <code translate="no">&quot;&lt;arg&gt;&quot;</code> to a specific type) using <a href="qhttpserverrouter.html#addConverter" translate="no">QHttpServerRouter::addConverter</a>().</p>
</div>
</div>
<!-- @@@QHttpServerRouterRule -->
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QHttpServerRouterRule[overload1]$$$QHttpServerRouterRuleconstQString&constQHttpServerRequest::MethodsconstQObject*Functor&& -->
<h3 class="fn" translate="no" id="QHttpServerRouterRule">template &lt;typename Functor&gt; QHttpServerRouterRule::<span class="name">QHttpServerRouterRule</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>pathPattern</i>, const <span class="type"><a href="qhttpserverrequest.html#Method-enum" translate="no">QHttpServerRequest::Methods</a></span> <i>methods</i>, const <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span> *<i>receiver</i>, <span class="type">Functor</span> &amp;&amp;<i>slot</i>)</h3>
<p>Constructs a rule for <i translate="no">pathPattern</i>, <i translate="no">methods</i> and connects it to <i translate="no">receiver</i> and <i translate="no">slot</i>. The <i translate="no">slot</i> can also be a function pointer, non-mutable lambda, or any other copyable callable with const call operator. In that case the <i translate="no">receiver</i> will be a context object. The handler will be valid until the receiver object is destroyed.</p>
<p>The rule accepts any combinations of available HTTP methods.</p>
<p><b>See also </b><a href="qhttpserverrequest.html#Method-enum" translate="no">QHttpServerRequest::Methods</a>.</p>
<!-- @@@QHttpServerRouterRule -->
<!-- $$$QHttpServerRouterRule$$$QHttpServerRouterRuleconstQString&constQObject*Functor&& -->
<h3 class="fn" translate="no" id="QHttpServerRouterRule-4">template &lt;typename Functor&gt; QHttpServerRouterRule::<span class="name">QHttpServerRouterRule</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>pathPattern</i>, const <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span> *<i>receiver</i>, <span class="type">Functor</span> &amp;&amp;<i>slot</i>)</h3>
<p>This is an overloaded function.</p>
<p>Constructs a rule for <i translate="no">pathPattern</i>, <a href="qhttpserverrequest.html#Method-enum" translate="no">QHttpServerRequest::Method::AnyKnown</a> and connects it to <i translate="no">receiver</i> and <i translate="no">slot</i>. The <i translate="no">slot</i> can also be a function pointer, non-mutable lambda, or any other copyable callable with const call operator. In that case the <i translate="no">receiver</i> will be a context object. The handler will be valid until the receiver object is destroyed.</p>
<!-- @@@QHttpServerRouterRule -->
<!-- $$$~QHttpServerRouterRule[overload1]$$$~QHttpServerRouterRule -->
<h3 class="fn" translate="no" id="dtor.QHttpServerRouterRule"><code class="details extra" translate="no">[virtual noexcept]</code> QHttpServerRouterRule::<span class="name">~QHttpServerRouterRule</span>()</h3>
<p>Destroys a <a href="qhttpserverrouterrule.html" translate="no">QHttpServerRouterRule</a>.</p>
<!-- @@@~QHttpServerRouterRule -->
<!-- $$$bindCaptured[overload1]$$$bindCapturedQObject*Functor&&constQRegularExpressionMatch& -->
<h3 class="fn" translate="no" id="bindCaptured"><code class="details extra" translate="no">[static]</code> template &lt;typename Functor, typename ViewTraits = QHttpServerRouterViewTraits&lt;Functor&gt;&gt; <span class="type">typename</span> <span class="type">ViewTraits::BindableType</span> QHttpServerRouterRule::<span class="name">bindCaptured</span>(<span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span> *<i>receiver</i>, <span class="type">Functor</span> &amp;&amp;<i>slot</i>, const <span class="type"><a href="../qtcore/qregularexpressionmatch.html" translate="no">QRegularExpressionMatch</a></span> &amp;<i>match</i>)</h3>
<p>Supplies the <i translate="no">receiver</i> and <i translate="no">slot</i> with arguments derived from a URL. Returns the bound function that accepts whatever remaining arguments the handler may take, supplying them to the slot after the URL-derived values. Each match of the regex applied to the URL (as a string) is converted to the type of the handler's parameter at its position, so that it can be passed as <i translate="no">match</i>.</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qhttpserverrouter.html" translate="no">QHttpServerRouter</a></span> router;

 <span class="keyword">auto</span> pageView <span class="operator">=</span> <span class="operator">[</span><span class="operator">]</span> (<span class="keyword">const</span> <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> <span class="operator">&amp;</span>page<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="../qtcore/qttypes.html#quint32-typedef" translate="no">quint32</a></span> num) {
     <a href="../qtcore/qtlogging.html#qDebug" translate="no">qDebug</a>(<span class="string">&quot;page: %s, num: %d&quot;</span><span class="operator">,</span> <a href="../qtcore/qstring.html#qPrintable" translate="no">qPrintable</a>(page)<span class="operator">,</span> num);
 };
 <span class="keyword">using</span> ViewHandler <span class="operator">=</span> decltype(pageView);

 <span class="keyword">auto</span> rule <span class="operator">=</span> std<span class="operator">::</span>make_unique<span class="operator">&lt;</span><span class="type"><a href="qhttpserverrouterrule.html#QHttpServerRouterRule" translate="no">QHttpServerRouterRule</a></span><span class="operator">&gt;</span>(
     <span class="string">&quot;/&lt;arg&gt;/&lt;arg&gt;/log&quot;</span><span class="operator">,</span>
     <span class="operator">[</span><span class="operator">&amp;</span>router<span class="operator">,</span> <span class="operator">&amp;</span>pageView<span class="operator">]</span> (<span class="type"><a href="../qtcore/qregularexpressionmatch.html" translate="no">QRegularExpressionMatch</a></span> <span class="operator">&amp;</span>match<span class="operator">,</span>
                           <span class="keyword">const</span> <span class="type"><a href="qhttpserverrequest.html" translate="no">QHttpServerRequest</a></span> <span class="operator">&amp;</span>request<span class="operator">,</span>
                           <span class="type"><a href="qhttpserverresponder.html" translate="no">QHttpServerResponder</a></span> <span class="operator">&amp;</span><span class="operator">&amp;</span>responder) {
     <span class="comment">// Bind and call viewHandler with match's captured string and quint32:</span>
     <span class="type"><a href="qhttpserverrouterrule.html#QHttpServerRouterRule" translate="no">QHttpServerRouterRule</a></span><span class="operator">::</span>bindCaptured(pageView<span class="operator">,</span> match)();
 });

 router<span class="operator">.</span>addRule<span class="operator">&lt;</span>ViewHandler<span class="operator">&gt;</span>(std<span class="operator">::</span>move(rule));
</pre>
<!-- @@@bindCaptured -->
<!-- $$$contextObject[overload1]$$$contextObject -->
<h3 class="fn" translate="no" id="contextObject">const <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span> *QHttpServerRouterRule::<span class="name">contextObject</span>() const</h3>
<p>Returns the context object of this rule. This is the receiver that has to handle the request.</p>
<!-- @@@contextObject -->
<!-- $$$exec[overload1]$$$execconstQHttpServerRequest&QHttpServerResponder& -->
<h3 class="fn" translate="no" id="exec"><code class="details extra" translate="no">[protected]</code> <span class="type">bool</span> QHttpServerRouterRule::<span class="name">exec</span>(const <span class="type"><a href="qhttpserverrequest.html" translate="no">QHttpServerRequest</a></span> &amp;<i>request</i>, <span class="type"><a href="qhttpserverresponder.html" translate="no">QHttpServerResponder</a></span> &amp;<i>responder</i>) const</h3>
<p>Executes this rule for the given <i translate="no">request</i>.</p>
<p>This function is called by <a href="qhttpserverrouter.html" translate="no">QHttpServerRouter</a> when it receives a new request. If the given <i translate="no">request</i> matches this rule, this function handles the request by delivering a response to the given <i translate="no">responder</i>, then returns <code translate="no">true</code>. Otherwise, it returns <code translate="no">false</code>.</p>
<!-- @@@exec -->
<!-- $$$hasValidMethods[overload1]$$$hasValidMethods -->
<h3 class="fn" translate="no" id="hasValidMethods"><code class="details extra" translate="no">[protected]</code> <span class="type">bool</span> QHttpServerRouterRule::<span class="name">hasValidMethods</span>() const</h3>
<p>Returns <code translate="no">true</code> if the methods is valid</p>
<!-- @@@hasValidMethods -->
<!-- $$$matches[overload1]$$$matchesconstQHttpServerRequest&QRegularExpressionMatch* -->
<h3 class="fn" translate="no" id="matches"><code class="details extra" translate="no">[virtual protected]</code> <span class="type">bool</span> QHttpServerRouterRule::<span class="name">matches</span>(const <span class="type"><a href="qhttpserverrequest.html" translate="no">QHttpServerRequest</a></span> &amp;<i>request</i>, <span class="type"><a href="../qtcore/qregularexpressionmatch.html" translate="no">QRegularExpressionMatch</a></span> *<i>match</i>) const</h3>
<p>Determines whether a given <i translate="no">request</i> matches this rule.</p>
<p>This virtual function is called by <a href="qhttpserverrouterrule.html#exec" translate="no">exec</a>() to check if <i translate="no">request</i> matches this rule. If a match is found, it is stored in the object pointed to by <i translate="no">match</i> (which <i>must not</i> be <code translate="no">nullptr</code>) and this function returns <code translate="no">true</code>. Otherwise, it returns <code translate="no">false</code>.</p>
<!-- @@@matches -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <abbr title="Copyright">&copy;</abbr> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
