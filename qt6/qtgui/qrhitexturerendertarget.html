<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qrhi.cpp -->
  <meta name="description" content="Texture render target resource.">
  <title>QRhiTextureRenderTarget Class | Qt GUI | Qt 6.9.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li>Qt 6.9</li>
<li><a href="qtgui-index.html">Qt GUI</a></li>
<li><a href="qtgui-module.html" translate="no">C++ Classes</a></li>
<li><a href="qtguiprivate-module.html" translate="no">QtGuiPrivate</a></li>
<li>QRhiTextureRenderTarget</li>
<li id="buildversion"><a href="qtgui-index.html">Qt 6.9.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#reimplemented-public-functions">Reimplemented Public Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QRhiTextureRenderTarget Class</h1>
<!-- $$$QRhiTextureRenderTarget-brief -->
<p>Texture render target resource. <a href="#details">More...</a></p>
<!-- @@@QRhiTextureRenderTarget -->
<div class="table"><table class="alignedsummary requisites" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign"> <code translate="no">#include &lt;rhi/qrhi.h&gt;</code></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> <code translate="no">find_package(Qt6 REQUIRED COMPONENTS Gui)</code><br/>
<code translate="no">target_link_libraries(mytarget PRIVATE Qt6::GuiPrivate)</code></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> <code translate="no">QT += gui-private</code></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 6.6</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="qrhirendertarget.html" translate="no">QRhiRenderTarget</a></td></tr>
</table></div>
<ul>
<li><a href="qrhitexturerendertarget-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qrhitexturerendertarget.html#Flag-enum" translate="no">Flag</a></b> { PreserveColorContents, PreserveDepthStencilContents, DoNotStoreDepthStencilContents }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qrhitexturerendertarget.html#Flag-enum" translate="no">Flags</a></b></td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qrhitexturerendertarget.html#create" translate="no">create</a></b>() = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiTextureRenderTargetDescription </td><td class="memItemRight bottomAlign"><b><a href="qrhitexturerendertarget.html#description" translate="no">description</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiTextureRenderTarget::Flags </td><td class="memItemRight bottomAlign"><b><a href="qrhitexturerendertarget.html#flags" translate="no">flags</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QRhiRenderPassDescriptor *</td><td class="memItemRight bottomAlign"><b><a href="qrhitexturerendertarget.html#newCompatibleRenderPassDescriptor" translate="no">newCompatibleRenderPassDescriptor</a></b>() = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhitexturerendertarget.html#setDescription" translate="no">setDescription</a></b>(const QRhiTextureRenderTargetDescription &amp;<i>desc</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhitexturerendertarget.html#setFlags" translate="no">setFlags</a></b>(QRhiTextureRenderTarget::Flags <i>f</i>)</td></tr>
</table></div>
<h2 id="reimplemented-public-functions">Reimplemented Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> virtual QRhiResource::Type </td><td class="memItemRight bottomAlign"><b><a href="qrhitexturerendertarget.html#resourceType" translate="no">resourceType</a></b>() const override</td></tr>
</table></div>
<!-- $$$QRhiTextureRenderTarget-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>A texture render target allows rendering into one or more textures, optionally with a depth texture or depth/stencil renderbuffer.</p>
<p>For multisample rendering the common approach is to use a renderbuffer as the color attachment and set the non-multisample destination texture as the <code translate="no">resolve texture</code>. For more information, read the detailed description of the <a href="qrhicolorattachment.html" translate="no">QRhiColorAttachment</a> class.</p>
<div class="admonition note">
<p><b>Note: </b>Textures used in combination with QRhiTextureRenderTarget must be created with the <a href="qrhitexture.html#Flag-enum" translate="no">QRhiTexture::RenderTarget</a> flag.</p>
</div>
<p>The simplest example of creating a render target with a texture as its single color attachment:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qrhitexture.html" translate="no">QRhiTexture</a></span> <span class="operator">*</span>texture <span class="operator">=</span> rhi<span class="operator">-</span><span class="operator">&gt;</span>newTexture(<span class="type"><a href="qrhitexture.html" translate="no">QRhiTexture</a></span><span class="operator">::</span>RGBA8<span class="operator">,</span> size<span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="type"><a href="qrhitexture.html" translate="no">QRhiTexture</a></span><span class="operator">::</span>RenderTarget);
 texture<span class="operator">-</span><span class="operator">&gt;</span>create();
 <span class="type">QRhiTextureRenderTarget</span> <span class="operator">*</span>rt <span class="operator">=</span> rhi<span class="operator">-</span><span class="operator">&gt;</span>newTextureRenderTarget({ texture });
 rp <span class="operator">=</span> rt<span class="operator">-</span><span class="operator">&gt;</span>newCompatibleRenderPassDescriptor();
 rt<span class="operator">-</span><span class="operator">&gt;</span>setRenderPassDescriptor(rp);
 rt<span class="operator">-</span><span class="operator">&gt;</span>create();
 <span class="comment">// rt can now be used with beginPass()</span>
</pre>
<div class="admonition note">
<p><b>Note: </b>This is a RHI API with limited compatibility guarantees, see <a href="qrhi.html" translate="no">QRhi</a> for details.</p>
</div>
</div>
<!-- @@@QRhiTextureRenderTarget -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$Flag$$$PreserveColorContents$$$PreserveDepthStencilContents$$$DoNotStoreDepthStencilContents -->
<h3 class="flags" id="Flag-enum">enum QRhiTextureRenderTarget::<span class="name">Flag</span><br/>flags QRhiTextureRenderTarget::<span class="name">Flags</span></h3>
<p>Flag values describing the load/store behavior for the render target. The load/store behavior may be baked into native resources under the hood, depending on the backend, and therefore it needs to be known upfront and cannot be changed without rebuilding (and so releasing and creating new native resources).</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QRhiTextureRenderTarget::PreserveColorContents</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 0</code></td><td class="topAlign">Indicates that the contents of the color attachments is to be loaded when starting a render pass, instead of clearing. This is potentially more expensive, especially on mobile (tiled) GPUs, but allows preserving the existing contents between passes. When doing multisample rendering with a resolve texture set, setting this flag also requests the multisample color data to be stored (written out) to the multisample texture or render buffer. (for non-multisample rendering the color data is always stored, but for MSAA storing the multisample data decreases efficiency for certain GPU architectures, hence defaulting to not writing it out) Note however that this is non-portable: in some cases there is no intermediate multisample texture on the graphics API level, e.g. when using OpenGL ES's <code translate="no">GL_EXT_multisampled_render_to_texture</code> as it is all implicit, handled by the OpenGL ES implementation. In that case, PreserveColorContents will likely have no effect. Therefore, avoid relying on this flag when using multisample rendering and the color attachment is using a multisample <a href="qrhitexture.html" translate="no">QRhiTexture</a> (not <a href="qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a>).</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTextureRenderTarget::PreserveDepthStencilContents</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 1</code></td><td class="topAlign">Indicates that the contents of the depth texture is to be loaded when starting a render pass, instead clearing. Only applicable when a texture is used as the depth buffer (<a href="qrhitexturerendertargetdescription.html#depthTexture" translate="no">QRhiTextureRenderTargetDescription::depthTexture</a>() is set) because depth/stencil renderbuffers may not have any physical backing and data may not be written out in the first place.</td></tr>
<tr><td class="topAlign"><code translate="no">QRhiTextureRenderTarget::DoNotStoreDepthStencilContents</code></td><td class="topAlign tblval"><code translate="no">1 &lt;&lt; 2</code></td><td class="topAlign">Indicates that the contents of the depth texture does not need to be written out. Relevant only when a <a href="qrhitexture.html" translate="no">QRhiTexture</a>, not <a href="qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a>, is used as the depth-stencil buffer, because for <a href="qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a> this is implicit. When a depthResolveTexture is set, the flag is not relevant, because the behavior is then as if the flag was set. This enum value is introduced in Qt 6.8.</td></tr>
</table></div>
<p>The Flags type is a typedef for <a href="../qtcore/qflags.html">QFlags</a>&lt;Flag&gt;. It stores an OR combination of Flag values.</p>
<!-- @@@Flag -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$create[overload1]$$$create -->
<h3 class="fn" translate="no" id="create"><code class="details extra" translate="no">[pure virtual]</code> <span class="type">bool</span> QRhiTextureRenderTarget::<span class="name">create</span>()</h3>
<p>Creates the corresponding native graphics resources. If there are already resources present due to an earlier create() with no corresponding <a href="qrhiresource.html#destroy" translate="no">destroy</a>(), then <a href="qrhiresource.html#destroy" translate="no">destroy</a>() is called implicitly first.</p>
<div class="admonition note">
<p><b>Note: </b><a href="qrhirendertarget.html#renderPassDescriptor" translate="no">renderPassDescriptor</a>() must be set before calling create(). To obtain a <a href="qrhirenderpassdescriptor.html" translate="no">QRhiRenderPassDescriptor</a> compatible with the render target, call <a href="qrhitexturerendertarget.html#newCompatibleRenderPassDescriptor" translate="no">newCompatibleRenderPassDescriptor</a>() before create() but after setting all other parameters, such as <a href="qrhitexturerendertarget.html#description" translate="no">description</a>() and <a href="qrhitexturerendertarget.html#flags" translate="no">flags</a>(). To save resources, reuse the same <a href="qrhirenderpassdescriptor.html" translate="no">QRhiRenderPassDescriptor</a> with multiple <a href="qrhitexturerendertarget.html" translate="no">QRhiTextureRenderTarget</a> instances, whenever possible. Sharing the same render pass descriptor is only possible when the render targets have the same number and type of attachments (the actual textures can differ) and the same flags.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>resources, such as <a href="qrhitexture.html" translate="no">QRhiTexture</a> instances, referenced in <a href="qrhitexturerendertarget.html#description" translate="no">description</a>() must already have create() called on them.</p>
</div>
<p>Returns <code translate="no">true</code> when successful, <code translate="no">false</code> when a graphics operation failed. Regardless of the return value, calling <a href="qrhiresource.html#destroy" translate="no">destroy</a>() is always safe.</p>
<!-- @@@create -->
<!-- $$$description[overload1]$$$description -->
<h3 class="fn" translate="no" id="description"><span class="type"><a href="qrhitexturerendertargetdescription.html" translate="no">QRhiTextureRenderTargetDescription</a></span> QRhiTextureRenderTarget::<span class="name">description</span>() const</h3>
<p>Returns the render target description.</p>
<p><b>See also </b><a href="qrhitexturerendertarget.html#setDescription" translate="no">setDescription</a>().</p>
<!-- @@@description -->
<!-- $$$flags[overload1]$$$flags -->
<h3 class="fn" translate="no" id="flags"><span class="type"><a href="qrhitexturerendertarget.html#Flag-enum" translate="no">QRhiTextureRenderTarget::Flags</a></span> QRhiTextureRenderTarget::<span class="name">flags</span>() const</h3>
<p>Returns the currently set flags.</p>
<p><b>See also </b><a href="qrhitexturerendertarget.html#setFlags" translate="no">setFlags</a>().</p>
<!-- @@@flags -->
<!-- $$$newCompatibleRenderPassDescriptor[overload1]$$$newCompatibleRenderPassDescriptor -->
<h3 class="fn" translate="no" id="newCompatibleRenderPassDescriptor"><code class="details extra" translate="no">[pure virtual]</code> <span class="type"><a href="qrhirenderpassdescriptor.html" translate="no">QRhiRenderPassDescriptor</a></span> *QRhiTextureRenderTarget::<span class="name">newCompatibleRenderPassDescriptor</span>()</h3>
<p>Returns a new <a href="qrhirenderpassdescriptor.html" translate="no">QRhiRenderPassDescriptor</a> that is compatible with this render target.</p>
<p>The returned value is used in two ways: it can be passed to <a href="qrhirendertarget.html#setRenderPassDescriptor" translate="no">setRenderPassDescriptor</a>() and <a href="qrhigraphicspipeline.html#setRenderPassDescriptor" translate="no">QRhiGraphicsPipeline::setRenderPassDescriptor</a>(). A render pass descriptor describes the attachments (color, depth/stencil) and the load/store behavior that can be affected by <a href="qrhitexturerendertarget.html#flags" translate="no">flags</a>(). A <a href="qrhigraphicspipeline.html" translate="no">QRhiGraphicsPipeline</a> can only be used in combination with a render target that has a <a href="qrhirenderpassdescriptor.html#isCompatible" translate="no">compatible</a> <a href="qrhirenderpassdescriptor.html" translate="no">QRhiRenderPassDescriptor</a> set.</p>
<p>Two <a href="qrhitexturerendertarget.html" translate="no">QRhiTextureRenderTarget</a> instances can share the same render pass descriptor as long as they have the same number and type of attachments. The associated <a href="qrhitexture.html" translate="no">QRhiTexture</a> or <a href="qrhirenderbuffer.html" translate="no">QRhiRenderBuffer</a> instances are not part of the render pass descriptor so those can differ in the two <a href="qrhitexturerendertarget.html" translate="no">QRhiTextureRenderTarget</a> instances.</p>
<div class="admonition note">
<p><b>Note: </b>resources, such as <a href="qrhitexture.html" translate="no">QRhiTexture</a> instances, referenced in <a href="qrhitexturerendertarget.html#description" translate="no">description</a>() must already have <a href="qrhitexturerendertarget.html#create" translate="no">create</a>() called on them.</p>
</div>
<p><b>See also </b><a href="qrhitexturerendertarget.html#create" translate="no">create</a>().</p>
<!-- @@@newCompatibleRenderPassDescriptor -->
<!-- $$$resourceType[overload1]$$$resourceType -->
<h3 class="fn" translate="no" id="resourceType"><code class="details extra" translate="no">[override virtual]</code> <span class="type"><a href="qrhiresource.html#Type-enum" translate="no">QRhiResource::Type</a></span> QRhiTextureRenderTarget::<span class="name">resourceType</span>() const</h3>
<p>Reimplements: <a href="qrhiresource.html#resourceType" translate="no">QRhiResource::resourceType</a>() const.</p>
<p>Returns the resource type.</p>
<!-- @@@resourceType -->
<!-- $$$setDescription[overload1]$$$setDescriptionconstQRhiTextureRenderTargetDescription& -->
<h3 class="fn" translate="no" id="setDescription"><span class="type">void</span> QRhiTextureRenderTarget::<span class="name">setDescription</span>(const <span class="type"><a href="qrhitexturerendertargetdescription.html" translate="no">QRhiTextureRenderTargetDescription</a></span> &amp;<i>desc</i>)</h3>
<p>Sets the render target description <i translate="no">desc</i>.</p>
<p><b>See also </b><a href="qrhitexturerendertarget.html#description" translate="no">description</a>().</p>
<!-- @@@setDescription -->
<!-- $$$setFlags[overload1]$$$setFlagsQRhiTextureRenderTarget::Flags -->
<h3 class="fn" translate="no" id="setFlags"><span class="type">void</span> QRhiTextureRenderTarget::<span class="name">setFlags</span>(<span class="type"><a href="qrhitexturerendertarget.html#Flag-enum" translate="no">QRhiTextureRenderTarget::Flags</a></span> <i>f</i>)</h3>
<p>Sets the flags to <i translate="no">f</i>.</p>
<p><b>See also </b><a href="qrhitexturerendertarget.html#flags" translate="no">flags</a>().</p>
<!-- @@@setFlags -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <abbr title="Copyright">&copy;</abbr> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
