<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qchronotimer.cpp -->
  <meta name="description" content="The QChronoTimer class provides repetitive and single-shot timers.">
  <title>QChronoTimer Class | Qt Core | Qt 6.9.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li>Qt 6.9</li>
<li><a href="qtcore-index.html">Qt Core</a></li>
<li><a href="qtcore-module.html" translate="no">C++ Classes</a></li>
<li>QChronoTimer</li>
<li id="buildversion"><a href="qtcore-index.html">Qt 6.9.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#properties">Properties</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#public-slots">Public Slots</a></li>
<li class="level1"><a href="#signals">Signals</a></li>
<li class="level1"><a href="#reimplemented-protected-functions">Reimplemented Protected Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
<li class="level2"><a href="#accuracy-and-timer-resolution">Accuracy and Timer Resolution</a></li>
<li class="level2"><a href="#alternatives-to-qchronotimer">Alternatives to QChronoTimer</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QChronoTimer Class</h1>
<!-- $$$QChronoTimer-brief -->
<p>The QChronoTimer class provides repetitive and single-shot timers. <a href="#details">More...</a></p>
<!-- @@@QChronoTimer -->
<div class="table"><table class="alignedsummary requisites" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign"> <code translate="no">#include &lt;QChronoTimer&gt;</code></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> <code translate="no">find_package(Qt6 REQUIRED COMPONENTS Core)</code><br/>
<code translate="no">target_link_libraries(mytarget PRIVATE Qt6::Core)</code></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> <code translate="no">QT += core</code></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 6.8</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="qobject.html" translate="no">QObject</a></td></tr>
</table></div>
<ul>
<li><a href="qchronotimer-members.html">List of all members, including inherited members</a></li>
<li>QChronoTimer is part of <a href="events.html">Event Classes</a>.</li>
</ul>
<h2 id="properties">Properties</h2>
<div class="table"><table class="propsummary" translate="no">
<tr><td class="topAlign"><ul>
<li class="fn" translate="no"><b><a href="qchronotimer.html#active-prop" translate="no">active</a></b> : bool</li>
<li class="fn" translate="no"><b><a href="qchronotimer.html#interval-prop" translate="no">interval</a></b> : std::chrono::nanoseconds</li>
<li class="fn" translate="no"><b><a href="qchronotimer.html#remainingTime-prop" translate="no">remainingTime</a></b> : const std::chrono::nanoseconds</li>
</ul></td><td class="topAlign"><ul>
<li class="fn" translate="no"><b><a href="qchronotimer.html#singleShot-prop" translate="no">singleShot</a></b> : bool</li>
<li class="fn" translate="no"><b><a href="qchronotimer.html#timerType-prop" translate="no">timerType</a></b> : Qt::TimerType</li>
</ul>
</td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qchronotimer.html#QChronoTimer" translate="no">QChronoTimer</a></b>(QObject *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qchronotimer.html#QChronoTimer-1" translate="no">QChronoTimer</a></b>(std::chrono::nanoseconds <i>nsec</i>, QObject *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qchronotimer.html#dtor.QChronoTimer" translate="no">~QChronoTimer</a></b>() override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QBindable&lt;bool&gt; </td><td class="memItemRight bottomAlign"><b><a href="qchronotimer.html#active-prop" translate="no">bindableActive</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QBindable&lt;std::chrono::nanoseconds&gt; </td><td class="memItemRight bottomAlign"><b><a href="qchronotimer.html#interval-prop" translate="no">bindableInterval</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QBindable&lt;bool&gt; </td><td class="memItemRight bottomAlign"><b><a href="qchronotimer.html#singleShot-prop" translate="no">bindableSingleShot</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QBindable&lt;Qt::TimerType&gt; </td><td class="memItemRight bottomAlign"><b><a href="qchronotimer.html#timerType-prop" translate="no">bindableTimerType</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMetaObject::Connection </td><td class="memItemRight bottomAlign"><b><a href="qchronotimer.html#callOnTimeout" translate="no">callOnTimeout</a></b>(const QObject *<i>context</i>, Functor &amp;&amp;<i>slot</i>, Qt::ConnectionType <i>connectionType</i> = Qt::AutoConnection)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Qt::TimerId </td><td class="memItemRight bottomAlign"><b><a href="qchronotimer.html#id" translate="no">id</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> std::chrono::nanoseconds </td><td class="memItemRight bottomAlign"><b><a href="qchronotimer.html#interval-prop" translate="no">interval</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qchronotimer.html#isActive" translate="no">isActive</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qchronotimer.html#singleShot-prop" translate="no">isSingleShot</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> std::chrono::nanoseconds </td><td class="memItemRight bottomAlign"><b><a href="qchronotimer.html#remainingTime-prop" translate="no">remainingTime</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qchronotimer.html#interval-prop" translate="no">setInterval</a></b>(std::chrono::nanoseconds <i>nsec</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qchronotimer.html#singleShot-prop" translate="no">setSingleShot</a></b>(bool <i>singleShot</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qchronotimer.html#timerType-prop" translate="no">setTimerType</a></b>(Qt::TimerType <i>atype</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Qt::TimerType </td><td class="memItemRight bottomAlign"><b><a href="qchronotimer.html#timerType-prop" translate="no">timerType</a></b>() const</td></tr>
</table></div>
<h2 id="public-slots">Public Slots</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qchronotimer.html#start" translate="no">start</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qchronotimer.html#stop" translate="no">stop</a></b>()</td></tr>
</table></div>
<h2 id="signals">Signals</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qchronotimer.html#timeout" translate="no">timeout</a></b>()</td></tr>
</table></div>
<h2 id="reimplemented-protected-functions">Reimplemented Protected Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qchronotimer.html#timerEvent" translate="no">timerEvent</a></b>(QTimerEvent *<i>e</i>) override</td></tr>
</table></div>
<!-- $$$QChronoTimer-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>The QChronoTimer class provides a high-level programming interface for timers. To use it, create a QChronoTimer, either passing the interval to the constructor, or setting it after construction using <a href="qchronotimer.html#interval-prop" translate="no">setInterval</a>(), connect its <a href="qchronotimer.html#timeout" translate="no">timeout</a>() signal to the appropriate slots, and call <a href="qchronotimer.html#start" translate="no">start</a>(). From then on, it will emit the <a href="qchronotimer.html#timeout" translate="no">timeout</a>() signal at constant intervals. For example:</p>
<pre class="cpp" translate="no">
         <span class="type"><a href="qchronotimer.html#QChronoTimer" translate="no">QChronoTimer</a></span> <span class="operator">*</span>timer <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qchronotimer.html#QChronoTimer" translate="no">QChronoTimer</a></span>(<span class="number">1s</span><span class="operator">,</span> <span class="keyword">this</span>);
         connect(timer<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="qchronotimer.html#QChronoTimer" translate="no">QChronoTimer</a></span><span class="operator">::</span>timeout<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">&amp;</span>MyWidget<span class="operator">::</span>processOneThing);
         timer<span class="operator">-</span><span class="operator">&gt;</span>start();
         <span class="type"><a href="qchronotimer.html#QChronoTimer" translate="no">QChronoTimer</a></span> <span class="operator">*</span>timer <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qchronotimer.html#QChronoTimer" translate="no">QChronoTimer</a></span>(<span class="keyword">this</span>);
         connect(timer<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="qchronotimer.html#QChronoTimer" translate="no">QChronoTimer</a></span><span class="operator">::</span>timeout<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">&amp;</span>MyWidget<span class="operator">::</span>processOneThing);
         timer<span class="operator">-</span><span class="operator">&gt;</span>setInterval(<span class="number">1s</span>);
         timer<span class="operator">-</span><span class="operator">&gt;</span>start();
</pre>
<p>You can set a timer to time out only once by calling <a href="qchronotimer.html#singleShot-prop" translate="no">setSingleShot</a>(true).</p>
<div class="admonition note">
<p><b>Note: </b>QChronoTimer has no singleShot() static methods, as the ones on <a href="qtimer.html" translate="no">QTimer</a> already work with chrono types and nanoseconds resolution.</p>
</div>
<p>In multithreaded applications, you can use QChronoTimer in any thread that has an event loop. To start an event loop from a non-GUI thread, use <a href="qthread.html#exec" translate="no">QThread::exec</a>(). Qt uses the timer's <a href="qobject.html#thread" translate="no">thread affinity</a> to determine which thread will emit the <a href="qchronotimer.html#timeout" translate="no">timeout</a>() signal. Because of this, you must start and stop the timer in its thread; it is not possible to start a timer from another thread.</p>
<p>As a special case, a QChronoTimer with a timeout of <code translate="no">0ns</code> will time out as soon as possible, though the ordering between zero timers and other sources of events is unspecified. Zero timers can be used to do some work while still providing a responsive user interface:</p>
<pre class="cpp" translate="no">
         <span class="comment">// The default interval is 0ns</span>
         <span class="type"><a href="qchronotimer.html#QChronoTimer" translate="no">QChronoTimer</a></span> <span class="operator">*</span>timer <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qchronotimer.html#QChronoTimer" translate="no">QChronoTimer</a></span>(<span class="keyword">this</span>);
         connect(timer<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="qchronotimer.html#QChronoTimer" translate="no">QChronoTimer</a></span><span class="operator">::</span>timeout<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">&amp;</span>MyWidget<span class="operator">::</span>processOneThing);
         timer<span class="operator">-</span><span class="operator">&gt;</span>start();
</pre>
<p>From then on, <code translate="no">processOneThing()</code> will be called repeatedly. It should be written in such a way that it always returns quickly (for example, after processing one data item) so that Qt can deliver events to the user interface and stop the timer as soon as it has done all its work. This is the traditional way of implementing heavy work in GUI applications, but as multithreading is becoming available on more platforms, a modern alternative is doing the heavy work in a thread other than the GUI (main) thread. Qt has the <a href="qthread.html" translate="no">QThread</a> class, which can be used to achieve that.</p>
<h3 id="accuracy-and-timer-resolution">Accuracy and Timer Resolution</h3>
<p>The accuracy of timers depends on the underlying operating system and hardware. Most platforms support requesting nano-second precision for timers (for example, libc's <code translate="no">nanosleep</code>), though the accuracy of the timer will not equal this resolution in many real-world situations.</p>
<p>You can set the <a href="qt.html#TimerType-enum" translate="no">timer type</a> to tell QChronoTimer which precision to request from the system.</p>
<p>For <a href="qt.html#TimerType-enum" translate="no">Qt::PreciseTimer</a>, QChronoTimer will try to keep the precision at <code translate="no">1ns</code>. Precise timers will never time out earlier than expected.</p>
<p>For <a href="qt.html#TimerType-enum" translate="no">Qt::CoarseTimer</a> and <a href="qt.html#TimerType-enum" translate="no">Qt::VeryCoarseTimer</a> types, QChronoTimer may wake up earlier than expected, within the margins for those types:</p>
<ul>
<li>5% of the interval for <a href="qt.html#TimerType-enum" translate="no">Qt::CoarseTimer</a></li>
<li><code translate="no">500ms</code> for <a href="qt.html#TimerType-enum" translate="no">Qt::VeryCoarseTimer</a></li>
</ul>
<p>All timer types may time out later than expected if the system is busy or unable to provide the requested accuracy. In such a case of timeout overrun, Qt will emit <a href="qchronotimer.html#timeout" translate="no">timeout</a>() only once, even if multiple timeouts have expired, and then will resume the original interval.</p>
<h3 id="alternatives-to-qchronotimer">Alternatives to QChronoTimer</h3>
<p>QChronoTimer provides nanosecond resolution and a ±292 years range (less chances of integer overflow if the interval is longer than <code translate="no">std::numeric_limits&lt;int&gt;::max()</code>). If you only need millisecond resolution and ±24 days range, you can continue to use the classical <a href="qtimer.html" translate="no">QTimer</a> class</p>
<p>Another alternative is reimplementing the <a href="qobject.html#timerEvent" translate="no">QObject::timerEvent</a>() method in your class (which must be a sub-class of <a href="qobject.html" translate="no">QObject</a>), and using one of the following approaches:</p>
<ul>
<li>Using <a href="qbasictimer.html" translate="no">QBasicTimer</a>, a lightweight value-class wrapping a timer ID. You can start the timer with <a href="qbasictimer.html#start" translate="no">QBasicTimer::start</a>() and stop it with <a href="qbasictimer.html#stop" translate="no">QBasicTimer::stop</a>(). You can handle the event in your reimplemneted <a href="qchronotimer.html#timerEvent" translate="no">timerEvent</a>().</li>
<li>A more low-level method is manipulating the timer IDs directly. To start the timer call <a href="qobject.html#startTimer" translate="no">QObject::startTimer</a>(), storing the returned ID. To stop the timer call <a href="qobject.html#killTimer" translate="no">QObject::killTimer</a>(). You can handle the event in your reimplemented <a href="qchronotimer.html#timerEvent" translate="no">timerEvent</a>(). This approach is typically more cumbersome than using <a href="qbasictimer.html" translate="no">QBasicTimer</a>.</li>
</ul>
<p>A disadvantage of using <a href="qchronotimer.html#timerEvent" translate="no">timerEvent</a>() is that some high-level features, such as single-shot timers and signals, aren't supported.</p>
<p>Some operating systems limit the number of timers that may be used; Qt does its best to work around these limitations.</p>
</div>
<p><b>See also </b><a href="qbasictimer.html" translate="no">QBasicTimer</a>, <a href="qtimerevent.html" translate="no">QTimerEvent</a>, <a href="qobject.html#timerEvent" translate="no">QObject::timerEvent</a>(), <a href="timers.html">Timers</a>, and <a href="../qtwidgets/qtwidgets-widgets-analogclock-example.html">Analog Clock</a>.</p>
<!-- @@@QChronoTimer -->
<div class="prop">
<h2>Property Documentation</h2>
<!-- $$$active-prop$$$isActive$$$bindableActive -->
<h3 class="fn" translate="no" id="active-prop"><code class="details extra" translate="no">[bindable read-only]</code> <span class="name">active</span> : <span class="type">bool</span></h3>
<div class="admonition note"><p><b>Note: </b>This property supports <a href="qproperty.html" translate="no">QProperty</a> bindings.</p>
</div><p>This boolean property is <code translate="no">true</code> if the timer is running; otherwise <code translate="no">false</code>.</p>
<!-- @@@active -->
<!-- $$$interval-prop$$$interval$$$setIntervalstd::chrono::nanoseconds$$$bindableInterval -->
<h3 class="fn" translate="no" id="interval-prop"><code class="details extra" translate="no">[bindable]</code> <span class="name">interval</span> : <span class="type">std::chrono::nanoseconds</span></h3>
<div class="admonition note"><p><b>Note: </b>This property supports <a href="qproperty.html" translate="no">QProperty</a> bindings.</p>
</div><p>This property holds the timeout interval</p>
<p>The default value for this property is <code translate="no">0ns</code>.</p>
<p>A <a href="qchronotimer.html" translate="no">QChronoTimer</a> with a timeout of <code translate="no">0ns</code> will time out as soon as all the events in the window system's event queue have been processed.</p>
<p>Setting the interval of a running timer will change the interval, <a href="qchronotimer.html#stop" translate="no">stop</a>() and then <a href="qchronotimer.html#start" translate="no">start</a>() the timer, and acquire a new <a href="qchronotimer.html#id" translate="no">id</a>(). If the timer is not running, only the interval is changed.</p>
<p><b>See also </b><a href="qchronotimer.html#singleShot-prop" translate="no">singleShot</a>.</p>
<!-- @@@interval -->
<!-- $$$remainingTime-prop$$$remainingTime -->
<h3 class="fn" translate="no" id="remainingTime-prop"><code class="details extra" translate="no">[read-only]</code> <span class="name">remainingTime</span> : const <span class="type">std::chrono::nanoseconds</span></h3>
<p>This property holds the remaining time</p>
<p>Returns the remaining duration until the timeout.</p>
<p>If the timer is inactive, the returned duration will be negative.</p>
<p>If the timer is overdue, the returned duration will be <code translate="no">0ns</code>.</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> std::chrono::nanoseconds </td><td class="memItemRight bottomAlign"><span class="name"><b>remainingTime</b></span>() const</td></tr>
</table></div>
<p><b>See also </b><a href="qchronotimer.html#interval-prop" translate="no">interval</a>.</p>
<!-- @@@remainingTime -->
<!-- $$$singleShot-prop$$$isSingleShot$$$setSingleShotbool$$$bindableSingleShot -->
<h3 class="fn" translate="no" id="singleShot-prop"><code class="details extra" translate="no">[bindable]</code> <span class="name">singleShot</span> : <span class="type">bool</span></h3>
<div class="admonition note"><p><b>Note: </b>This property supports <a href="qproperty.html" translate="no">QProperty</a> bindings.</p>
</div><p>This property holds whether the timer is a single-shot timer</p>
<p>A single-shot timer fires only once, non-single-shot timers fire every <a href="qchronotimer.html#interval-prop" translate="no">interval</a>.</p>
<p>The default value for this property is <code translate="no">false</code>.</p>
<p><b>See also </b><a href="qchronotimer.html#interval-prop" translate="no">interval</a>.</p>
<!-- @@@singleShot -->
<!-- $$$timerType-prop$$$timerType$$$setTimerTypeQt::TimerType$$$bindableTimerType -->
<h3 class="fn" translate="no" id="timerType-prop"><code class="details extra" translate="no">[bindable]</code> <span class="name">timerType</span> : <span class="type"><a href="qt.html#TimerType-enum" translate="no">Qt::TimerType</a></span></h3>
<div class="admonition note"><p><b>Note: </b>This property supports <a href="qproperty.html" translate="no">QProperty</a> bindings.</p>
</div><p>Controls the accuracy of the timer</p>
<p>The default value for this property is <code translate="no">Qt::CoarseTimer</code>.</p>
<p><b>See also </b><a href="qt.html#TimerType-enum" translate="no">Qt::TimerType</a>.</p>
<!-- @@@timerType -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QChronoTimer[overload1]$$$QChronoTimerQObject* -->
<h3 class="fn" translate="no" id="QChronoTimer"><code class="details extra" translate="no">[explicit]</code> QChronoTimer::<span class="name">QChronoTimer</span>(<span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span> *<i>parent</i> = nullptr)</h3>
<p>Constructs a timer with the given <i translate="no">parent</i>, using the default interval, <code translate="no">0ns</code>.</p>
<!-- @@@QChronoTimer -->
<!-- $$$QChronoTimer$$$QChronoTimerstd::chrono::nanosecondsQObject* -->
<h3 class="fn" translate="no" id="QChronoTimer-1"><code class="details extra" translate="no">[explicit]</code> QChronoTimer::<span class="name">QChronoTimer</span>(<span class="type">std::chrono::nanoseconds</span> <i>nsec</i>, <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span> *<i>parent</i> = nullptr)</h3>
<p>Constructs a timer with the given <i translate="no">parent</i>, using an interval of <i translate="no">nsec</i>.</p>
<!-- @@@QChronoTimer -->
<!-- $$$~QChronoTimer[overload1]$$$~QChronoTimer -->
<h3 class="fn" translate="no" id="dtor.QChronoTimer"><code class="details extra" translate="no">[override virtual noexcept]</code> QChronoTimer::<span class="name">~QChronoTimer</span>()</h3>
<p>Destroys the timer.</p>
<!-- @@@~QChronoTimer -->
<!-- $$$callOnTimeout[overload1]$$$callOnTimeoutconstQObject*Functor&&Qt::ConnectionType -->
<h3 class="fn" translate="no" id="callOnTimeout">template &lt;typename Functor&gt; <span class="type"><a href="qmetaobject-connection.html" translate="no">QMetaObject::Connection</a></span> QChronoTimer::<span class="name">callOnTimeout</span>(const <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span> *<i>context</i>, <span class="type">Functor</span> &amp;&amp;<i>slot</i>, <span class="type"><a href="qt.html#ConnectionType-enum" translate="no">Qt::ConnectionType</a></span> <i>connectionType</i> = Qt::AutoConnection)</h3>
<p>This function overloads callOnTimeout().</p>
<p>Creates a connection from the <a href="qchronotimer.html#timeout" translate="no">timeout</a>() signal to <i translate="no">slot</i> to be placed in a specific event loop of <i translate="no">context</i>, with connection type <i translate="no">connectionType</i>, and returns a handle to the connection.</p>
<p>This method is provided as a convenience. It's equivalent to calling:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qobject.html#QObject" translate="no">QObject</a></span><span class="operator">::</span>connect(timer<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="qchronotimer.html#QChronoTimer" translate="no">QChronoTimer</a></span><span class="operator">::</span>timeout<span class="operator">,</span> context<span class="operator">,</span> slot<span class="operator">,</span> connectionType);
</pre>
<p><b>See also </b><a href="qobject.html#connect" translate="no">QObject::connect</a>() and <a href="qchronotimer.html#timeout" translate="no">timeout</a>().</p>
<!-- @@@callOnTimeout -->
<!-- $$$id[overload1]$$$id -->
<h3 class="fn" translate="no" id="id"><span class="type"><a href="qobject.html#TimerId-enum" translate="no">Qt::TimerId</a></span> QChronoTimer::<span class="name">id</span>() const</h3>
<p>Returns a <a href="qobject.html#TimerId-enum" translate="no">Qt::TimerId</a> representing the timer ID if the timer is running; otherwise returns <code translate="no">Qt::TimerId::Invalid</code>.</p>
<p><b>See also </b><a href="qobject.html#TimerId-enum" translate="no">Qt::TimerId</a>.</p>
<!-- @@@id -->
<!-- $$$isActive -->
<h3 class="fn" translate="no" id="isActive"><span class="type">bool</span> QChronoTimer::<span class="name">isActive</span>() const</h3>
<p>Returns <code translate="no">true</code> if the timer is running; otherwise returns <code translate="no">false</code>.</p>
<div class="admonition note"><p><b>Note: </b>Getter function for property <a href="qchronotimer.html#active-prop" translate="no">active</a>. </p>
</div><!-- @@@isActive -->
<!-- $$$start[overload1]$$$start -->
<h3 class="fn" translate="no" id="start"><code class="details extra" translate="no">[slot]</code> <span class="type">void</span> QChronoTimer::<span class="name">start</span>()</h3>
<p>This function overloads start().</p>
<p>Starts or restarts the timer with the timeout specified in <a href="qchronotimer.html#interval-prop" translate="no">interval</a>.</p>
<p>If the timer is already running, it will be <a href="qchronotimer.html#stop" translate="no">stopped</a> and restarted. This will also change its <a href="qchronotimer.html#id" translate="no">id</a>().</p>
<p>If <a href="qchronotimer.html#singleShot-prop" translate="no">singleShot</a> is true, the timer will be activated only once.</p>
<!-- @@@start -->
<!-- $$$stop[overload1]$$$stop -->
<h3 class="fn" translate="no" id="stop"><code class="details extra" translate="no">[slot]</code> <span class="type">void</span> QChronoTimer::<span class="name">stop</span>()</h3>
<p>Stops the timer.</p>
<p><b>See also </b><a href="qchronotimer.html#start" translate="no">start</a>().</p>
<!-- @@@stop -->
<!-- $$$timeout[overload1]$$$timeout -->
<h3 class="fn" translate="no" id="timeout"><code class="details extra" translate="no">[private signal]</code> <span class="type">void</span> QChronoTimer::<span class="name">timeout</span>()</h3>
<p>This signal is emitted when the timer times out.</p>
<div class="admonition note"><p><b>Note: </b>This is a private signal. It can be used in signal connections but cannot be emitted by the user.</p>
</div><p><b>See also </b><a href="qchronotimer.html#interval-prop" translate="no">interval</a>, <a href="qchronotimer.html#start" translate="no">start</a>(), and <a href="qchronotimer.html#stop" translate="no">stop</a>().</p>
<!-- @@@timeout -->
<!-- $$$timerEvent[overload1]$$$timerEventQTimerEvent* -->
<h3 class="fn" translate="no" id="timerEvent"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">void</span> QChronoTimer::<span class="name">timerEvent</span>(<span class="type"><a href="qtimerevent.html" translate="no">QTimerEvent</a></span> *<i>e</i>)</h3>
<p>Reimplements: <a href="qobject.html#timerEvent" translate="no">QObject::timerEvent</a>(QTimerEvent *event).</p>
<!-- @@@timerEvent -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <abbr title="Copyright">&copy;</abbr> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
