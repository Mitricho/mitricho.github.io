<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qglobalstatic.qdoc -->
  <meta name="description" content="The QGlobalStatic class is used to implement a global static object.">
  <title>QGlobalStatic Struct | Qt Core | Qt 6.9.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li>Qt 6.9</li>
<li><a href="qtcore-index.html">Qt Core</a></li>
<li><a href="qtcore-module.html" translate="no">C++ Classes</a></li>
<li>QGlobalStatic</li>
<li id="buildversion"><a href="qtcore-index.html">Qt 6.9.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#macros">Macros</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QGlobalStatic Struct</h1>
<span class="small-subtitle" translate="no">template &lt;typename Holder&gt; struct QGlobalStatic</span>
<!-- $$$QGlobalStatic-brief -->
<p>The QGlobalStatic class is used to implement a global static object. <a href="#details">More...</a></p>
<!-- @@@QGlobalStatic -->
<div class="table"><table class="alignedsummary requisites" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign"> <code translate="no">#include &lt;QGlobalStatic&gt;</code></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> <code translate="no">find_package(Qt6 REQUIRED COMPONENTS Core)</code><br/>
<code translate="no">target_link_libraries(mytarget PRIVATE Qt6::Core)</code></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> <code translate="no">QT += core</code></td></tr>
</table></div>
<ul>
<li><a href="qglobalstatic-members.html">List of all members, including inherited members</a></li>
<li><a href="qglobalstatic-obsolete.html">Deprecated members</a></li>
</ul>
<p><b>Note:</b> All functions in this struct are thread-safe.</p>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qglobalstatic.html#Type-typedef" translate="no">Type</a></b></td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qglobalstatic.html#exists" translate="no">exists</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qglobalstatic.html#isDestroyed" translate="no">isDestroyed</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QGlobalStatic&lt;Holder&gt;::Type *</td><td class="memItemRight bottomAlign"><b><a href="qglobalstatic.html#operator-QGlobalStatic-ltHolder-gt-3a-3aType--2a" translate="no">operator QGlobalStatic&lt;Holder&gt;::Type *</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QGlobalStatic&lt;Holder&gt;::Type &amp;</td><td class="memItemRight bottomAlign"><b><a href="qglobalstatic.html#operator-2a" translate="no">operator*</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QGlobalStatic&lt;Holder&gt;::Type *</td><td class="memItemRight bottomAlign"><b><a href="qglobalstatic.html#operator--gt" translate="no">operator-&gt;</a></b>()</td></tr>
</table></div>
<h2 id="macros">Macros</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qglobalstatic.html#Q_GLOBAL_STATIC" translate="no">Q_GLOBAL_STATIC</a></b>(<i>Type</i>, <i>variableName</i>, ...)</td></tr>
</table></div>
<!-- $$$QGlobalStatic-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>The QGlobalStatic class is the front-end API exported when <a href="qglobalstatic.html#Q_GLOBAL_STATIC" translate="no">Q_GLOBAL_STATIC</a>() is used. See the documentation of the macro for a discussion of its requirements and when to use it.</p>
<p>Normally, you will never use this class directly, but instead you will use the <a href="qglobalstatic.html#Q_GLOBAL_STATIC" translate="no">Q_GLOBAL_STATIC</a>() macro, as follows:</p>
<pre class="cpp" translate="no">
 Q_GLOBAL_STATIC(MyType<span class="operator">,</span> myGlobal)
</pre>
<p>The above example creates an object of type QGlobalStatic called <code translate="no">myGlobal</code>. After the above declaration, the <code translate="no">myGlobal</code> object may be used as if it were a pointer to an object of type <i translate="no">MyType</i>, guaranteed to be initialized exactly once. In addition to the use as a pointer, the object offers two methods to determine the current status of the global: <a href="qglobalstatic.html#exists" translate="no">exists</a>() and <a href="qglobalstatic.html#isDestroyed" translate="no">isDestroyed</a>().</p>
</div>
<p><b>See also </b><a href="qglobalstatic.html#Q_GLOBAL_STATIC" translate="no">Q_GLOBAL_STATIC</a>() and <a href="qglobalstatic-obsolete.html#Q_GLOBAL_STATIC_WITH_ARGS" class="obsolete" translate="no">Q_GLOBAL_STATIC_WITH_ARGS</a>().</p>
<!-- @@@QGlobalStatic -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$Type -->
<h3 class="fn" translate="no" id="Type-typedef"><code class="details extra" translate="no">[alias]</code> QGlobalStatic::<span class="name">Type</span></h3>
<p>This type is equivalent to the <code translate="no">Type</code> parameter passed to the <a href="qglobalstatic.html#Q_GLOBAL_STATIC" translate="no">Q_GLOBAL_STATIC</a>() or Q_GLOBAL_STATIC_WITH_ARGS() macros. It is used in the return types of some functions.</p>
<!-- @@@Type -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$exists[overload1]$$$exists -->
<h3 class="fn" translate="no" id="exists"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> QGlobalStatic::<span class="name">exists</span>() const</h3>
<p>This function returns <code translate="no">true</code> if the global static object has already completed initialization (that is, if the constructor for the type has already returned) and has not yet completed destruction. In particular, note that this function returns <code translate="no">false</code> if the initialization is still in progress.</p>
<p>Once this function has returned true once, it will never return false again until the global static object is destroyed. The latter happens on program exit or when the plugin or library containing the global static is unloaded.</p>
<p>This function is safe to call at any point in the program execution: it cannot fail and cannot cause a deadlock. Additionally, it will not cause the contents to be created if they have not yet been created.</p>
<p>This function is useful if one can determine the initial conditions of the global static object and would prefer to avoid a possibly expensive construction operation.</p>
<p>For example, in the following code sample, this function is used to short-circuit the creation of the global static called <code translate="no">globalState</code> and returns a default value:</p>
<pre class="cpp" translate="no">
 Q_GLOBAL_STATIC(MyType<span class="operator">,</span> globalState)
 <span class="type"><a href="qstring.html" translate="no">QString</a></span> someState()
 {
     <span class="keyword">if</span> (globalState<span class="operator">.</span>exists())
         <span class="keyword">return</span> globalState<span class="operator">-</span><span class="operator">&gt;</span>someState;
     <span class="keyword">return</span> <span class="type"><a href="qstring.html" translate="no">QString</a></span>();
 }
</pre>
<p><b>Thread-safety notice:</b> this function is thread-safe in the sense that it may be called from any thread at any time and will always return a valid reply. But due to the non-atomic nature of construction, this function may return false for a short time after the construction has completed.</p>
<p><b>Memory ordering notice:</b> this function does not impose any memory ordering guarantees. That is instead provided by the accessor functions that return the pointer or reference to the contents. If you bypass the accessor functions and attempt to access some global state set by the constructor, be sure to use the correct memory ordering semantics provided by <a href="qatomicint.html" translate="no">QAtomicInt</a> or <a href="qatomicpointer.html" translate="no">QAtomicPointer</a>.</p>
<p><b>See also </b><a href="qglobalstatic.html#isDestroyed" translate="no">isDestroyed</a>().</p>
<!-- @@@exists -->
<!-- $$$isDestroyed[overload1]$$$isDestroyed -->
<h3 class="fn" translate="no" id="isDestroyed"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> QGlobalStatic::<span class="name">isDestroyed</span>() const</h3>
<p>This function returns <code translate="no">true</code> if the global static object has already completed destruction (that is, if the destructor for the type has already returned). In particular, note that this function returns <code translate="no">false</code> if the destruction is still in progress.</p>
<p>Once this function has returned true once, it will never return false again until either the program is restarted or the plugin or library containing the global static is unloaded and reloaded.</p>
<p>This function is safe to call at any point in the program execution: it cannot fail and cannot cause a deadlock. Additionally, it will not cause the contents to be created if they have not yet been created.</p>
<p>This function is useful in code that may be executed at program shutdown, to determine whether the contents may still be accessed or not.</p>
<p><b>See also </b><a href="qglobalstatic.html#exists" translate="no">exists</a>().</p>
<!-- @@@isDestroyed -->
<!-- $$$operator QGlobalStatic<Holder>::Type *[overload1]$$$operator QGlobalStatic<Holder>::Type * -->
<h3 class="fn" translate="no" id="operator-QGlobalStatic-ltHolder-gt-3a-3aType--2a"><span class="type"><a href="qglobalstatic.html" translate="no">QGlobalStatic</a></span>&lt;<span class="type">Holder</span>&gt;<span class="type">::Type</span> *QGlobalStatic::<span class="name">operator QGlobalStatic&lt;Holder&gt;::Type *</span>()</h3>
<p>This function returns the address of the contents of this global static. If the contents have not yet been created, they will be created thread-safely by this function. If the contents have already been destroyed, this function will return a null pointer.</p>
<p>This function can be used, for example, to store the pointer to the contents of the global static in a local variable, thus avoiding multiple calls to the function. The implementation of <a href="qglobalstatic.html#Q_GLOBAL_STATIC" translate="no">Q_GLOBAL_STATIC</a>() is quite efficient already, but in performance-critical sections it might be useful to help the compiler a little. For example:</p>
<pre class="cpp" translate="no">
 Q_GLOBAL_STATIC(MyType<span class="operator">,</span> globalState)
 <span class="type"><a href="qstring.html" translate="no">QString</a></span> someState()
 {
     <span class="keyword">if</span> (globalState<span class="operator">::</span>isDestroyed())
         <span class="keyword">return</span> <span class="type"><a href="qstring.html" translate="no">QString</a></span>();
     MyType <span class="operator">*</span>state <span class="operator">=</span> globalState;
     <span class="keyword">if</span> (state<span class="operator">-</span><span class="operator">&gt;</span>condition)
         <span class="keyword">return</span> state<span class="operator">-</span><span class="operator">&gt;</span>value;
     <span class="keyword">else</span>
         <span class="keyword">return</span> state<span class="operator">-</span><span class="operator">&gt;</span>worth;
 }
</pre>
<p><b>See also </b><a href="qglobalstatic.html#operator--gt" translate="no">operator-&gt;</a>() and <a href="qglobalstatic.html#operator-2a" translate="no">operator*</a>().</p>
<!-- @@@operator QGlobalStatic<Holder>::Type * -->
<!-- $$$operator*[overload1]$$$operator* -->
<h3 class="fn" translate="no" id="operator-2a"><span class="type"><a href="qglobalstatic.html" translate="no">QGlobalStatic</a></span>&lt;<span class="type">Holder</span>&gt;<span class="type">::Type</span> &amp;QGlobalStatic::<span class="name">operator*</span>()</h3>
<p>This function returns a reference to the contents of this global static. If the contents have not yet been created, they will be created thread-safely by this function.</p>
<p>This function does not check if the contents have already been destroyed. If this function is called after the object has been destroyed, it will return an invalid reference that must not be used.</p>
<p><b>See also </b><a href="qglobalstatic.html#exists" translate="no">exists</a>() and <a href="qglobalstatic.html#isDestroyed" translate="no">isDestroyed</a>().</p>
<!-- @@@operator* -->
<!-- $$$operator->[overload1]$$$operator-> -->
<h3 class="fn" translate="no" id="operator--gt"><span class="type"><a href="qglobalstatic.html" translate="no">QGlobalStatic</a></span>&lt;<span class="type">Holder</span>&gt;<span class="type">::Type</span> *QGlobalStatic::<span class="name">operator-&gt;</span>()</h3>
<p>This function returns the address of the contents of this global static. If the contents have not yet been created, they will be created thread-safely by this function.</p>
<p>This function does not check if the contents have already been destroyed and will never return null. If this function is called after the object has been destroyed, it will return a dangling pointer that should not be dereferenced.</p>
<p><b>See also </b><a href="qglobalstatic.html#exists" translate="no">exists</a>() and <a href="qglobalstatic.html#isDestroyed" translate="no">isDestroyed</a>().</p>
<!-- @@@operator-> -->
</div>
<div class="macros">
<h2>Macro Documentation</h2>
<!-- $$$Q_GLOBAL_STATIC[overload1]$$$Q_GLOBAL_STATIC... -->
<h3 class="fn" translate="no" id="Q_GLOBAL_STATIC"><span class="name">Q_GLOBAL_STATIC</span>(<i>Type</i>, <i>variableName</i>, ...)</h3>
<p>Creates a global and static object of type <a href="qglobalstatic.html" translate="no">QGlobalStatic</a>, named <i translate="no">variableName</i>. It behaves as a pointer to <i translate="no">Type</i>. The object created by Q_GLOBAL_STATIC initializes itself on the first use, which means that it will not increase the application or the library's load time. Additionally, the object is initialized in a thread-safe manner on all platforms.</p>
<p>Since Qt 6.3, this macro admits variadic arguments, which are used to initialize the object, thus making the need for <a href="qglobalstatic-obsolete.html#Q_GLOBAL_STATIC_WITH_ARGS" class="obsolete" translate="no">Q_GLOBAL_STATIC_WITH_ARGS</a> unnecessary. Please note the arguments do not require an extra set of parentheses, unlike the older macro.</p>
<p>The typical use of this macro is as follows, in a global context (that is, not inside any function or class body):</p>
<pre class="cpp" translate="no">
 Q_GLOBAL_STATIC(MyType<span class="operator">,</span> myGlobal)
</pre>
<p>This macro is intended to replace global static objects that are not POD (Plain Old Data, or in C++11 terms, not made of a trivial type), hence the name. For example, the following C++ code creates a global static:</p>
<pre class="cpp" translate="no">
 <span class="keyword">static</span> MyType myGlobal;
</pre>
<p>Compared to Q_GLOBAL_STATIC, and assuming that <code translate="no">MyType</code> is a class or struct that has a constructor, a destructor, or is otherwise non-POD, the latter has the following drawbacks:</p>
<ul>
<li>it requires load-time initialization of <code translate="no">myGlobal</code> (that is, the default constructor for <code translate="no">MyType</code> is called when the library or application is loaded);</li>
<li>the object will be initialized even if it is never used;</li>
<li>the order of initialization and destruction among different translation units is not determined, leading to possible uses, before initialization or after destruction, by the constructors or destructors of other global variables.</li>
</ul>
<p>The Q_GLOBAL_STATIC macro solves all of these problems by guaranteeing thread-safe initialization on first use and allowing the user to query for whether the type has already been destroyed, to avoid the use-after-destruction problem (see <a href="qglobalstatic.html#isDestroyed" translate="no">QGlobalStatic::isDestroyed</a>()).</p>
<h4 id="constructor-and-destructor">Constructor and Destructor</h4>
<p>For Q_GLOBAL_STATIC, when only given a type and variable name, its <code translate="no">Type</code> must be publicly default-constructible and publicly destructible. Otherwise, <code translate="no">Type</code> must have a public constructor that accepts the remaining arguments to the macro. For Q_GLOBAL_STATIC_WITH_ARGS(), there must be a public constructor that accepts the macro's third argument as its list of parameters.</p>
<p>It is not possible to use Q_GLOBAL_STATIC with a <i translate="no">Type</i> whose relevant constructor or destructor is protected or private. If the type in question declares those members protected, it is possible to overcome the issue by deriving from the type and creating a public constructor and destructor. If the type declares them private, a friend declaration is necessary before deriving.</p>
<p>For example, the following is enough to create <code translate="no">MyType</code> based on a previously-defined <code translate="no">MyOtherType</code> which has a protected default constructor and/or a protected destructor (or declares them private, but also declares <code translate="no">MyType</code> as a friend).</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> MyType : <span class="keyword">public</span> MyOtherType { };
 Q_GLOBAL_STATIC(MyType<span class="operator">,</span> myGlobal)
</pre>
<p>No body for <code translate="no">MyType</code> is required since the destructor is an implicit member and so is the default constructor if no other constructors are defined. For use with arguments after <i translate="no">Type</i> and <i translate="no">variableName</i>, or with Q_GLOBAL_STATIC_WITH_ARGS(), however, a suitable constructor body is necessary:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> MyType : <span class="keyword">public</span> MyOtherType
 {
 <span class="keyword">public</span>:
     MyType(<span class="type">int</span> i) : MyOtherType(i) {}
 };
 Q_GLOBAL_STATIC(MyType<span class="operator">,</span> myGlobal<span class="operator">,</span> <span class="number">42</span>)
</pre>
<p>Alternatively (since C++11 introduced inheriting constructors), one could write:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> MyType : <span class="keyword">public</span> MyOtherType
 {
 <span class="keyword">public</span>:
     <span class="keyword">using</span> MyOtherType<span class="operator">::</span>MyOtherType;
 };
 Q_GLOBAL_STATIC_WITH_ARGS(MyType<span class="operator">,</span> myGlobal<span class="operator">,</span> (<span class="number">42</span>))
</pre>
<h4 id="placement">Placement</h4>
<p>The Q_GLOBAL_STATIC macro creates a type, and a variable of that type that is necessarily static, at the global scope. It is not possible to place the Q_GLOBAL_STATIC macro inside a function or the body of a class (doing so will result in compilation errors).</p>
<p>More importantly, this macro should be placed in source files, never in headers. Since the resulting object has static linkage, if the macro is placed in a header and included by multiple source files, the object will be defined multiple times and will not cause linking errors. Instead, each translation unit will refer to a different object, which could lead to subtle and hard-to-track errors.</p>
<h4 id="non-recommended-uses">Non-recommended uses</h4>
<p>Note that the macro is not recommended for use with types that are POD or that have C++11 constexpr constructors (trivially constructible and destructible). For those types, it is still recommended to use regular static, whether global or function-local.</p>
<p>This macro will work, but it will add unnecessary overhead.</p>
<h4 id="reentrancy-thread-safety-deadlocks-and-exception-safety-on-construction">Reentrancy, Thread-safety, Deadlocks, and Exception-safety on Construction</h4>
<p>The Q_GLOBAL_STATIC macro creates an object that initializes itself on first use in a thread-safe manner: if multiple threads attempt to initialize the object at the same time, only one thread will proceed to initialize, while all other threads wait for completion.</p>
<p>If the initialization process throws an exception, the initialization is deemed not complete and will be attempted again when control reaches any use of the object. If there are any threads waiting for initialization, one of them will be woken up to attempt to initialize.</p>
<p>The macro makes no guarantee about reentrancy from the same thread. If the global static object is accessed directly or indirectly from inside its own constructor, a deadlock will surely happen.</p>
<p>In addition, if two Q_GLOBAL_STATIC objects are being initialized on two different threads and each one's initialization sequence accesses the other, a deadlock might happen. For that reason, it is recommended to keep global static constructors simple or, failing that, to ensure that there's no cross-dependency of uses of global static during construction.</p>
<h4 id="destruction">Destruction</h4>
<p>If the object is never used during the lifetime of the program, aside from the <a href="qglobalstatic.html#exists" translate="no">QGlobalStatic::exists</a>() and <a href="qglobalstatic.html#isDestroyed" translate="no">QGlobalStatic::isDestroyed</a>() functions, the contents of type <i translate="no">Type</i> will not be created and there will not be any exit-time operation.</p>
<p>If the object is created, it will be destroyed at exit-time, similar to the C <code translate="no">atexit()</code> function. On most systems, in fact, the destructor will also be called if the library or plugin is unloaded from memory before exit.</p>
<p>Since the destruction is meant to happen at program exit, no thread-safety is provided. This includes the case of plugin or library unload. In addition, since destructors are not supposed to throw exceptions, no exception safety is provided either.</p>
<p>However, reentrancy is permitted: during destruction, it is possible to access the global static object and the pointer returned will be the same as it was before destruction began. After the destruction has completed, accessing the global static object is not permitted, except as noted in the <a href="qglobalstatic.html" translate="no">QGlobalStatic</a> API.</p>
<p><b>See also </b><a href="qglobalstatic-obsolete.html#Q_GLOBAL_STATIC_WITH_ARGS" class="obsolete" translate="no">Q_GLOBAL_STATIC_WITH_ARGS</a>(), <a href="qapplicationstatic.html#Q_APPLICATION_STATIC" translate="no">Q_APPLICATION_STATIC</a>(), and <a href="qglobalstatic.html" translate="no">QGlobalStatic</a>.</p>
<!-- @@@Q_GLOBAL_STATIC -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <abbr title="Copyright">&copy;</abbr> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
