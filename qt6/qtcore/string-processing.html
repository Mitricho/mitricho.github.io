<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qstring-overview.qdoc -->
  <title>Classes for string data | Qt Core | Qt 6.9.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li>Qt 6.9</li>
<li><a href="qtcore-index.html">Qt Core</a></li>
<li>Classes for string data</li>
<li id="buildversion"><a href="qtcore-index.html">Qt 6.9.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
  <link rel="prev" href="events.html" />
  <link rel="next" href="implicit-sharing.html" />
<p class="naviNextPrevious headerNavi">
<a class="prevPage" href="events.html">Event Classes</a>
<span class="naviSeparator">  &#9702;  </span>
<a class="nextPage" href="implicit-sharing.html">Implicit Sharing</a>
</p>
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#overview">Overview</a></li>
<li class="level2"><a href="#impactful-tips">Impactful tips</a></li>
<li class="level2"><a href="#efficient-usage">Efficient usage</a></li>
<li class="level1"><a href="#basic-string-classes">Basic string classes</a></li>
<li class="level1"><a href="#high-level-string-related-classes">High-level string-related classes</a></li>
<li class="level1"><a href="#which-string-class-to-use">Which string class to use?</a></li>
<li class="level2"><a href="#string-class-for-creating-api">String class for creating API</a></li>
<li class="level2"><a href="#string-class-for-using-api">String class for using API</a></li>
<li class="level1"><a href="#list-of-all-string-related-classes">List of all string related classes</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">Classes for string data</h1>
<!-- $$$string-processing-description -->
<div class="descr" id="details">
<h2 id="overview">Overview</h2>
<p>This page gives an overview over string classes in Qt, in particular the large amount of string containers and how to use them efficiently in performance-critical code.</p>
<p>The following instructions for efficient use are aimed at experienced developers working on performance-critical code that contains considerable amounts of string processing. This is, for example, a parser or a text file generator. <i>Generally, <a href="qstring.html" translate="no">QString</a> can be used everywhere and it will perform fine.</i> It also provides APIs for handling several encodings (for example <a href="qstring.html#fromLatin1" translate="no">QString::fromLatin1</a>()). For many applications and especially when string-processing plays an insignificant role for performance, <a href="qstring.html" translate="no">QString</a> will be a simple and sufficient solution. Some Qt functions return a <a href="qstringview.html" translate="no">QStringView</a>. It can be converted to a <a href="qstring.html" translate="no">QString</a> with <a href="qstringview.html#toString" translate="no">QStringView::toString</a>() if required.</p>
<h3 id="impactful-tips">Impactful tips</h3>
<p>The following three rules improve string handling substantially without increasing the complexity too much. Follow these rules to get nearly optimal performance in most cases. The first two rules address encoding of string literals and marking them in source code. The third rule addresses deep copies when using parts of a string.</p>
<ul>
<li>All strings that only contain ASCII characters (for example log messages) can be encoded with Latin-1. Use the <a href="qlatin1char.html#operator-22-22_L1" translate="no">string literal</a> <code translate="no">&quot;foo&quot;_L1</code>. Without this suffix, string literals in source code are assumed to be UTF-8 encoded and processing them will be slower. Generally, try to use the tightest encoding, which is Latin-1 in many cases.</li>
<li>User-visible strings are usually translated and thus passed through the <a href="qobject.html#tr" translate="no">QObject::tr</a>() function. This function takes a string literal (const char array) and returns a <a href="qstring.html" translate="no">QString</a> with UTF-16 encoding as demanded by all UI elements. If the translation infrastructure is not used, you should use UTF-16 encoding throughout the whole application. Use the string literal <code translate="no">u&quot;foo&quot;</code> to create UTF-16 string literals or the Qt specific literal <code translate="no">u&quot;foo&quot;_s</code> to directly create a <a href="qstring.html" translate="no">QString</a>.</li>
<li>When processing parts of a <a href="qstring.html" translate="no">QString</a>, instead of copying each part into its own <a href="qstring.html" translate="no">QString</a> object, create <a href="qstringview.html" translate="no">QStringView</a> objects instead. These can be converted back to <a href="qstring.html" translate="no">QString</a> using <a href="qstringview.html#toString" translate="no">QStringView::toString</a>(), but avoid doing so as much as possible. If functions return <a href="qstringview.html" translate="no">QStringView</a>, it is most efficient to keep working with this class, if possible. The API is similar to a constant <a href="qstring.html" translate="no">QString</a>.</li>
</ul>
<h3 id="efficient-usage">Efficient usage</h3>
<p>To use string classes efficiently, one should understand the three concepts of:</p>
<ul>
<li>Encoding</li>
<li>Owning and non-owning containers</li>
<li>Literals</li>
</ul>
<h4 id="encoding">Encoding</h4>
<p>Encoding-wise Qt supports UTF-16, UTF-8, Latin-1 (ISO 8859-1) and US-ASCII (that is the common subset of Latin-1 and UTF-8) in one form or another.</p>
<ul>
<li>Latin-1 is a character encoding that uses a single byte per character which makes it the most efficient but also limited encoding.</li>
<li>UTF-8 is a variable-length character encoding that encodes all characters using one to four bytes. It is backwards compatible to US-ASCII and it is the common encoding for source code and similar files. Qt assumes that source code is encoded in UTF-8.</li>
<li>UTF-16 is a variable-length encoding that uses two or four bytes per character. It is the common encoding for user-exposed text in Qt.</li>
</ul>
<p>See the information about support for Unicode in Qt for more information.</p>
<p>Other encodings are supported in the form of single functions like <a href="qstring.html#fromUcs4" translate="no">QString::fromUcs4</a>() or of the <a href="qstringconverter.html" translate="no">QStringConverter</a> classes. Furthermore, Qt provides an encoding-agnostic container for data, <a href="qbytearray.html" translate="no">QByteArray</a>, that is well-suited to storing binary data. <a href="qanystringview.html" translate="no">QAnyStringView</a> keeps track of the encoding of the underlying string and can thus carry a view onto strings with any of the supported encoding standards.</p>
<p>Converting between encodings is expensive, therefore, avoid if possible. On the other hand, a more compact encoding, particularly for string literals, can reduce binary size, which can increase performance. Where string literals can be expressed in Latin-1, it manages a good compromise between these competing factors, even if it has to be converted to UTF-16 at some point. When a Latin-1 string must be converted to a <a href="qstring.html" translate="no">QString</a>, it is done relatively efficiently.</p>
<h4 id="functionality">Functionality</h4>
<p>String classes can be further distinguished by the functionality they support. One major distinction is whether they own, and thus control, their data or merely reference data held elsewhere. The former are called <i>owning</i> containers, the latter <i>non-owning</i> containers or views. A non-owning container type typically just records a pointer to the start of the data and its size, making it lightweight and cheap, but it only remains valid as long as the data remains available. An owning string manages the memory in which it stores its data, ensuring that data remains available throughout the lifetime of the container, but its creation and destruction incur the costs of allocating and releasing memory. Views typically support a subset of the functions of the owning string, lacking the possibility to modify the underlying data.</p>
<p>As a result, string views are particularly well-suited to representing parts of larger strings, for example in a parser, while owning strings are good for persistent storage, such as members of a class. Where a function returns a string that it has constructed, for example by combining fragments, it has to return an owning string; but where a function returns part of some persistently stored string, a view is usually more suitable.</p>
<p>Note that owning containers in Qt share their data <a href="implicit-sharing.html">implicitly</a>, meaning that it is also efficient to pass or return large containers by value, although slightly less efficient than passing by reference due to the reference counting. If you want to make use of the implicit data sharing mechanism of Qt classes, you have to pass the string as an owning container or a reference to one. Conversion to a view and back will always create an additional copy of the data.</p>
<p>Finally, Qt provides classes for single characters, lists of strings and string matchers. These classes are available for most supported encoding standards in Qt, with some exceptions. Higher level functionality is provided by specialized classes, such as <a href="qlocale.html" translate="no">QLocale</a> or <a href="qtextboundaryfinder.html" translate="no">QTextBoundaryFinder</a>. These high level classes usually rely on <a href="qstring.html" translate="no">QString</a> and its UTF-16 encoding. Some classes are templates and work with all available string classes.</p>
<h4 id="literals">Literals</h4>
<p>The C++ standard provides <a href="https://en.cppreference.com/w/cpp/language/string_literal">string literals</a> to create strings at compile-time. There are string literals defined by the language and literals defined by Qt, so-called <a href="https://en.cppreference.com/w/cpp/language/user_literal">user-defined literals</a>. A string literal defined by C++ is enclosed in double quotes and can have a prefix that tells the compiler how to interpret its content. For Qt, the UTF-16 string literal <code translate="no">u&quot;foo&quot;</code> is the most important. It creates a string encoded in UTF-16 at compile-time, saving the need to convert from some other encoding at run-time. <a href="qstringview.html" translate="no">QStringView</a> can be easily and efficiently constructed from one, so they can be passed to functions that accept a <a href="qstringview.html" translate="no">QStringView</a> argument (or, as a result, a <a href="qanystringview.html" translate="no">QAnyStringView</a>).</p>
<p>User-defined literals have the same form as those defined by C++ but add a suffix after the closing quote. The encoding remains determined by the prefix, but the resulting literal is used to construct an object of some user-defined type. Qt thus defines these for some of its own string types: <code translate="no">u&quot;foo&quot;_s</code> for <a href="qstring.html" translate="no">QString</a>, <code translate="no">&quot;foo&quot;_L1</code> for <a href="qlatin1stringview.html" translate="no">QLatin1StringView</a> and <code translate="no">u&quot;foo&quot;_ba</code> for <a href="qbytearray.html" translate="no">QByteArray</a>. These are provided by using the <a href="qt-literals-stringliterals.html" translate="no">StringLiterals Namespace</a>. A plain C++ string literal <code translate="no">&quot;foo&quot;</code> will be understood as UTF-8 and conversion to <a href="qstring.html" translate="no">QString</a> and thus UTF-16 will be expensive. When you have string literals in plain ASCII, use <code translate="no">&quot;foo&quot;_L1</code> to interpret it as Latin-1, gaining the various benefits outlined above.</p>
<h2 id="basic-string-classes">Basic string classes</h2>
<p>The following table gives an overview over basic string classes for the various standards of text encoding.</p>
<div class="table"><table class="generic">
 <thead><tr class="qt-style"><th >Encoding</th><th >C++ String literal</th><th >Qt user-defined literal</th><th >C++ Character</th><th >Qt Character</th><th >Owning string</th><th >Non-owning string</th></tr></thead>
<tr valign="top" class="odd"><td >Latin-1</td><td >-</td><td >&quot;&quot;_L1</td><td >-</td><td ><a href="qlatin1char.html" translate="no">QLatin1Char</a></td><td >-</td><td ><a href="qlatin1stringview.html" translate="no">QLatin1StringView</a></td></tr>
<tr valign="top" class="even"><td >UTF-8</td><td >u8&quot;&quot;</td><td >-</td><td >char8_t</td><td >-</td><td >-</td><td ><a href="qutf8stringview.html" translate="no">QUtf8StringView</a></td></tr>
<tr valign="top" class="odd"><td >UTF-16</td><td >u&quot;&quot;</td><td >u&quot;&quot;_s</td><td >char16_t</td><td ><a href="qchar.html" translate="no">QChar</a></td><td ><a href="qstring.html" translate="no">QString</a></td><td ><a href="qstringview.html" translate="no">QStringView</a></td></tr>
<tr valign="top" class="even"><td >Binary/None</td><td >-</td><td >&quot;&quot;_ba</td><td >std::byte</td><td >-</td><td ><a href="qbytearray.html" translate="no">QByteArray</a></td><td ><a href="qbytearrayview.html" translate="no">QByteArrayView</a></td></tr>
<tr valign="top" class="odd"><td >Flexible</td><td >any</td><td >-</td><td >-</td><td >-</td><td >-</td><td ><a href="qanystringview.html" translate="no">QAnyStringView</a></td></tr>
</table></div>
<p>Some of the missing entries can be substituted with built-in and standard library C++ types: An owning Latin-1 or UTF-8 encoded string can be <code translate="no">std::string</code> or any 8-bit <code translate="no">char</code> array. <a href="qstringview.html" translate="no">QStringView</a> can also reference any 16-bit character arrays, such as std::u16string or std::wstring on some platforms.</p>
<p>Qt also provides specialized lists for some of those types, that are <a href="qstringlist.html" translate="no">QStringList</a> and <a href="qbytearrayview.html" translate="no">QByteArrayView</a>, as well as matchers, <a href="qlatin1stringmatcher.html" translate="no">QLatin1StringMatcher</a> and <a href="qbytearraymatcher.html" translate="no">QByteArrayMatcher</a>. The matchers also have static versions that are created at compile-time, <a href="qstaticlatin1stringmatcher.html" translate="no">QStaticLatin1StringMatcher</a> and <a href="qstaticbytearraymatcher.html" translate="no">QStaticByteArrayMatcher</a>.</p>
<p>Further worth noting:</p>
<ul>
<li><a href="qstring.html#QStringLiteral" translate="no">QStringLiteral</a> is a macro which is identical to <code translate="no">u&quot;foo&quot;_s</code> and available without the <a href="qt-literals-stringliterals.html" translate="no">StringLiterals Namespace</a>. Preferably you should use the modern string literal.</li>
<li><a href="qlatin1string.html" translate="no">QLatin1String</a> is a synonym for <a href="qlatin1stringview.html" translate="no">QLatin1StringView</a> and exists for backwards compatibility. It is not an owning string and might be removed in future releases.</li>
<li><a href="qanystringview.html" translate="no">QAnyStringView</a> provides a view for a string with any of the three supported encodings. The encoding is stored alongside the reference to the data. This class is well suited to create interfaces that take a wide spectrum of string types and encodings. In contrast to other classes, no processing is conducted on <a href="qanystringview.html" translate="no">QAnyStringView</a> directly. Processing is conducted on the underlying <a href="qlatin1stringview.html" translate="no">QLatin1StringView</a>, <a href="qutf8stringview.html" translate="no">QUtf8StringView</a> or <a href="qstringview.html" translate="no">QStringView</a> in the respective encoding. Use <a href="qanystringview.html#visit" translate="no">QAnyStringView::visit</a>() to do the same in your own functions that take this class as an argument.</li>
<li>A <a href="qlatin1stringview.html" translate="no">QLatin1StringView</a> with non-ASCII characters is not straightforward to construct in a UTF-8 encoded source code file and requires special treatment, see the <a href="qlatin1stringview.html" translate="no">QLatin1StringView</a> documentation.</li>
<li>QStringRef is a reference to a portion of a <a href="qstring.html" translate="no">QString</a>, available in the Qt5Compat module for backwards compatibility. It should be replaced by <a href="qstringview.html" translate="no">QStringView</a>.</li>
</ul>
<h2 id="high-level-string-related-classes">High-level string-related classes</h2>
<p>More high-level classes that provide additional functionality work mostly with <a href="qstring.html" translate="no">QString</a> and thus UTF-16. These are:</p>
<ul>
<li><a href="qregularexpression.html" translate="no">QRegularExpression</a>, <a href="qregularexpressionmatch.html" translate="no">QRegularExpressionMatch</a> and <a href="qregularexpressionmatchiterator.html" translate="no">QRegularExpressionMatchIterator</a> to work with pattern matching and regular expressions.</li>
<li><a href="qlocale.html" translate="no">QLocale</a> to convert numbers and data to and from strings in a manner appropriate to the user's language and culture.</li>
<li><a href="qcollator.html" translate="no">QCollator</a> and <a href="qcollatorsortkey.html" translate="no">QCollatorSortKey</a> to compare strings with respect to the users language, script or territory.</li>
<li><a href="qtextboundaryfinder.html" translate="no">QTextBoundaryFinder</a> to break up text ready for typesetting in accord with Unicode rules.</li>
<li><code translate="no">QStringBuilder</code>, an internal class that will substantially improve the performance of string concatenations with the <code translate="no">+</code> operator, see the <a href="qstring.html" translate="no">QString</a> documentation.</li>
</ul>
<p>Some classes are templates or have a flexible API and work with various string classes. These are</p>
<ul>
<li><a href="qtextstream.html" translate="no">QTextStream</a> to stream into <a href="qiodevice.html" translate="no">QIODevice</a>, <a href="qbytearray.html" translate="no">QByteArray</a> or <a href="qstring.html" translate="no">QString</a></li>
<li><a href="qstringtokenizer.html" translate="no">QStringTokenizer</a> to split strings</li>
</ul>
<h2 id="which-string-class-to-use">Which string class to use?</h2>
<p>The general guidance in using string classes is:</p>
<ul>
<li>Avoid copying and memory allocations,</li>
<li>Avoid encoding conversions, and</li>
<li>Choose the most compact encoding.</li>
</ul>
<p>Qt provides many functionalities to avoid memory allocations. Most Qt containers employ <a href="implicit-sharing.html">Implicit Sharing</a> of their data. For implicit sharing to work, there must be an uninterrupted chain of the same class &mdash; converting from <a href="qstring.html" translate="no">QString</a> to <a href="qstringview.html" translate="no">QStringView</a> and back will result in two <a href="qstring.html" translate="no">QStrings</a> that do not share their data. Therefore, functions need to pass their data as <a href="qstring.html" translate="no">QString</a> (both values or references work). Extracting parts of a string is not possible with implicit data sharing. To use parts of a longer string, make use of string views, an explicit form of data sharing.</p>
<p>Conversions between encodings can be reduced by sticking to a certain encoding. Data received, for example in UTF-8, is best stored and processed in UTF-8 if no conversation to any other encoding is required. Comparisons between strings of the same encoding are fastest and the same is the case for most other operations. If strings of a certain encoding are often compared or converted to any other encoding it might be beneficial to convert and store them once. Some operations provide many overloads (or a <a href="qanystringview.html" translate="no">QAnyStringView</a> overload) to take various string types and encodings and they should be the second choice to optimize performance, if using the same encoding is not feasible. Explicit encoding conversions before calling a function should be a last resort when no other option is available. Latin-1 is a very simple encoding and operation between Latin-1 and any other encoding are almost as efficient as operations between the same encoding.</p>
<p>The most efficient encoding (from most to least efficient Latin-1, UTF-8, UTF-16) should be chosen when no other constrains determine the encoding. For error handling and logging <a href="qlatin1stringview.html" translate="no">QLatin1StringView</a> is usually sufficient. User-visible strings in Qt are always of type <a href="qstring.html" translate="no">QString</a> and as such UTF-16 encoded. Therefore it is most effective to use <a href="qstring.html" translate="no">QStrings</a>, <a href="qstringview.html" translate="no">QStringViews</a> and <a href="qstring.html#QStringLiteral" translate="no">QStringLiterals</a> throughout the life-time of a user-visible string. The <a href="qobject.html#tr" translate="no">QObject::tr</a>() function provides the correct encoding and type. <a href="qbytearray.html" translate="no">QByteArray</a> should be used if encoding does not play a role, for example to store binary data, or if the encoding is unknown.</p>
<h3 id="string-class-for-creating-api">String class for creating API</h3>
<p class="centerAlign"><img src="images/string_class_api.svg" alt="&quot;String class for an optimal API&quot;" /></p><h4 id="member-variables">Member variables</h4>
<p>Member variables should be of an owning type in nearly all cases. Views can only be used as member variables if the lifetime of the referenced owning string is guaranteed to exceed the lifetime of the object.</p>
<h4 id="function-arguments">Function arguments</h4>
<p>Function arguments should be string views of a suitable encoding in most cases. <a href="qanystringview.html" translate="no">QAnyStringView</a> can be used as a parameter to support more than one encoding and <a href="qanystringview.html#visit" translate="no">QAnyStringView::visit</a>() can be used internally to fork off into per-encoding functions. If the function is limited to a single encoding, <a href="qlatin1stringview.html" translate="no">QLatin1StringView</a>, <a href="qutf8stringview.html" translate="no">QUtf8StringView</a>, <a href="qstringview.html" translate="no">QStringView</a> or <a href="qbytearrayview.html" translate="no">QByteArrayView</a> should be used.</p>
<p>If the function saves the argument in an owning string (usually a setter function), it is most efficient to use the same owning string as function argument to make use of the implicit data sharing functionality of Qt. The owning string can be passed as a <code translate="no">const</code> reference. Overloading functions with multiple owning and non-owning string types can lead to overload ambiguity and should be avoided. Owning string types in Qt can be automatically converted to their non-owning version or to <a href="qanystringview.html" translate="no">QAnyStringView</a>.</p>
<h4 id="return-values">Return values</h4>
<p>Temporary strings have to be returned as an owning string, usually <a href="qstring.html" translate="no">QString</a>. If the returned string is known at compile-time use <code translate="no">u&quot;foo&quot;_s</code> to construct the <a href="qstring.html" translate="no">QString</a> structure at compile-time. If existing owning strings (for example <a href="qstring.html" translate="no">QString</a>) are returned from a function in full (for example a getter function), it is most efficient to return them by reference. They can also be returned by value to allow returning a temporary in the future. Qt's use of implicit sharing avoids the performance impact of allocation and copying when returning by value.</p>
<p>Parts of existing strings can be returned efficiently with a string view of the appropriate encoding, for an example see <a href="qregularexpressionmatch.html#capturedView" translate="no">QRegularExpressionMatch::capturedView</a>() which returns a <a href="qstringview.html" translate="no">QStringView</a>.</p>
<h3 id="string-class-for-using-api">String class for using API</h3>
<p class="centerAlign"><img src="images/string_class_calling.svg" alt="&quot;String class for calling a function&quot;" /></p><p>To use a Qt API efficiently you should try to match the function argument types. If you are limited in your choice, Qt will conduct various conversions: Owning strings are implicitly converted to non-owning strings, non-owning strings can create their owning counter parts, see for example <a href="qstringview.html#toString" translate="no">QStringView::toString</a>(). Encoding conversions are conducted implicitly in many cases but this should be avoided if possible. To avoid accidental implicit conversion from UTF-8 you can activate the macro <a href="qstring.html#QT_NO_CAST_FROM_ASCII" translate="no">QT_NO_CAST_FROM_ASCII</a>.</p>
<p>If you need to assemble a string at runtime before passing it to a function you will need an owning string and thus <a href="qstring.html" translate="no">QString</a>. If the function argument is <a href="qstringview.html" translate="no">QStringView</a> or <a href="qanystringview.html" translate="no">QAnyStringView</a> it will be implicitly converted.</p>
<p>If the string is known at compile-time, there is room for optimization. If the function accepts a <a href="qstring.html" translate="no">QString</a>, you should create it with <code translate="no">u&quot;foo&quot;_s</code> or the <a href="qstring.html#QStringLiteral" translate="no">QStringLiteral</a> macro. If the function expects a <a href="qstringview.html" translate="no">QStringView</a>, it is best constructed with an ordinary UTF-16 string literal <code translate="no">u&quot;foo&quot;</code>, if a <a href="qlatin1stringview.html" translate="no">QLatin1StringView</a> is expected, construct it with <code translate="no">&quot;foo&quot;_L1</code>. If you have the choice between both, for example if the function expects <a href="qanystringview.html" translate="no">QAnyStringView</a>, use the tightest encoding, usually Latin-1.</p>
<h2 id="list-of-all-string-related-classes">List of all string related classes</h2>
</div>
<!-- @@@string-processing -->
<div class="table"><table class="annotated">
<tr class="odd topAlign"><td class="tblName" translate="no"><p><a href="qanystringview.html">QAnyStringView</a></p></td><td class="tblDescr"><p>Unified view on Latin-1, UTF-8, or UTF-16 strings with a read-only subset of the QString API</p></td></tr>
<tr class="even topAlign"><td class="tblName" translate="no"><p><a href="qbytearray.html">QByteArray</a></p></td><td class="tblDescr"><p>Array of bytes</p></td></tr>
<tr class="odd topAlign"><td class="tblName" translate="no"><p><a href="qbytearraylist.html">QByteArrayList</a></p></td><td class="tblDescr"><p>List of byte arrays</p></td></tr>
<tr class="even topAlign"><td class="tblName" translate="no"><p><a href="qbytearraymatcher.html">QByteArrayMatcher</a></p></td><td class="tblDescr"><p>Holds a sequence of bytes that can be quickly matched in a byte array</p></td></tr>
<tr class="odd topAlign"><td class="tblName" translate="no"><p><a href="qbytearrayview.html">QByteArrayView</a></p></td><td class="tblDescr"><p>View on an array of bytes with a read-only subset of the QByteArray API</p></td></tr>
<tr class="even topAlign"><td class="tblName" translate="no"><p><a href="qchar.html">QChar</a></p></td><td class="tblDescr"><p>16-bit Unicode character</p></td></tr>
<tr class="odd topAlign"><td class="tblName" translate="no"><p><a href="qcollator.html">QCollator</a></p></td><td class="tblDescr"><p>Compares strings according to a localized collation algorithm</p></td></tr>
<tr class="even topAlign"><td class="tblName" translate="no"><p><a href="qcollatorsortkey.html">QCollatorSortKey</a></p></td><td class="tblDescr"><p>Can be used to speed up string collation</p></td></tr>
<tr class="odd topAlign"><td class="tblName" translate="no"><p><a href="qlatin1char.html">QLatin1Char</a></p></td><td class="tblDescr"><p>8-bit ASCII/Latin-1 character</p></td></tr>
<tr class="even topAlign"><td class="tblName" translate="no"><p><a href="qlatin1stringmatcher.html">QLatin1StringMatcher</a></p></td><td class="tblDescr"><p>Optimized search for substring in Latin-1 text</p></td></tr>
<tr class="odd topAlign"><td class="tblName" translate="no"><p><a href="qlatin1stringview.html">QLatin1StringView</a></p></td><td class="tblDescr"><p>Thin wrapper around a US-ASCII/Latin-1 encoded string literal</p></td></tr>
<tr class="even topAlign"><td class="tblName" translate="no"><p><a href="qlocale.html">QLocale</a></p></td><td class="tblDescr"><p>Converts between numbers and their string representations in various languages</p></td></tr>
<tr class="odd topAlign"><td class="tblName" translate="no"><p><a href="qregularexpression.html">QRegularExpression</a></p></td><td class="tblDescr"><p>Pattern matching using regular expressions</p></td></tr>
<tr class="even topAlign"><td class="tblName" translate="no"><p><a href="qregularexpressionmatch.html">QRegularExpressionMatch</a></p></td><td class="tblDescr"><p>The results of a matching a QRegularExpression against a string</p></td></tr>
<tr class="odd topAlign"><td class="tblName" translate="no"><p><a href="qregularexpressionmatchiterator.html">QRegularExpressionMatchIterator</a></p></td><td class="tblDescr"><p>Iterator on the results of a global match of a QRegularExpression object against a string</p></td></tr>
<tr class="even topAlign"><td class="tblName" translate="no"><p><a href="qstaticbytearraymatcher.html">QStaticByteArrayMatcher</a></p></td><td class="tblDescr"><p>Compile-time version of QByteArrayMatcher</p></td></tr>
<tr class="odd topAlign"><td class="tblName" translate="no"><p><a href="qstaticlatin1stringmatcher.html">QStaticLatin1StringMatcher</a></p></td><td class="tblDescr"><p>Compile-time version of QLatin1StringMatcher</p></td></tr>
<tr class="even topAlign"><td class="tblName" translate="no"><p><a href="qstring.html">QString</a></p></td><td class="tblDescr"><p>Unicode character string</p></td></tr>
<tr class="odd topAlign"><td class="tblName" translate="no"><p><a href="qstringconverter.html">QStringConverter</a></p></td><td class="tblDescr"><p>Base class for encoding and decoding text</p></td></tr>
<tr class="even topAlign"><td class="tblName" translate="no"><p><a href="qstringdecoder.html">QStringDecoder</a></p></td><td class="tblDescr"><p>State-based decoder for text</p></td></tr>
<tr class="odd topAlign"><td class="tblName" translate="no"><p><a href="qstringencoder.html">QStringEncoder</a></p></td><td class="tblDescr"><p>State-based encoder for text</p></td></tr>
<tr class="even topAlign"><td class="tblName" translate="no"><p><a href="qstringlist.html">QStringList</a></p></td><td class="tblDescr"><p>List of strings</p></td></tr>
<tr class="odd topAlign"><td class="tblName" translate="no"><p><a href="qstringmatcher.html">QStringMatcher</a></p></td><td class="tblDescr"><p>Holds a sequence of characters that can be quickly matched in a Unicode string</p></td></tr>
<tr class="even topAlign"><td class="tblName" translate="no"><p><a href="qstringtokenizer.html">QStringTokenizer</a></p></td><td class="tblDescr"><p>Splits strings into tokens along given separators</p></td></tr>
<tr class="odd topAlign"><td class="tblName" translate="no"><p><a href="qstringview.html">QStringView</a></p></td><td class="tblDescr"><p>Unified view on UTF-16 strings with a read-only subset of the QString API</p></td></tr>
<tr class="even topAlign"><td class="tblName" translate="no"><p><a href="qtextboundaryfinder.html">QTextBoundaryFinder</a></p></td><td class="tblDescr"><p>Way of finding Unicode text boundaries in a string</p></td></tr>
<tr class="odd topAlign"><td class="tblName" translate="no"><p><a href="qtextstream.html">QTextStream</a></p></td><td class="tblDescr"><p>Convenient interface for reading and writing text</p></td></tr>
<tr class="even topAlign"><td class="tblName" translate="no"><p><a href="qutf8stringview.html">QUtf8StringView</a></p></td><td class="tblDescr"><p>Unified view on UTF-8 strings with a read-only subset of the QString API</p></td></tr>
</table></div>
<p class="naviNextPrevious footerNavi">
<a class="prevPage" href="events.html">Event Classes</a>
<span class="naviSeparator">  &#9702;  </span>
<a class="nextPage" href="implicit-sharing.html">Implicit Sharing</a>
</p>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <abbr title="Copyright">&copy;</abbr> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
