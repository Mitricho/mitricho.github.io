<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qt6-port-to-qt-add-qml-module.qdoc -->
  <meta name="description" content="Port your QML modules to the qt_add_qml_module CMake API.">
  <title>Port QML modules to CMake | Qt Qml | Qt 6.9.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li>Qt 6.9</li>
<li><a href="qtqml-index.html">Qt Qml</a></li>
<li>Port QML modules to CMake</li>
<li id="buildversion"><a href="qtqml-index.html">Qt 6.9.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#identify-issues-to-fix">Identify issues to fix</a></li>
<li class="level1"><a href="#prepare-the-project-for-qt-add-qml-module">Prepare the project for qt_add_qml_module</a></li>
<li class="level2"><a href="#make-qt-add-qml-module-available-in-cmake">Make qt_add_qml_module available in CMake</a></li>
<li class="level2"><a href="#use-qt-standard-project-setup">Use qt_standard_project_setup</a></li>
<li class="level1"><a href="#use-qt-add-qml-module">Use qt_add_qml_module</a></li>
<li class="level2"><a href="#add-a-qml-module-to-your-executable-target">Add a QML module to your executable target</a></li>
<li class="level2"><a href="#add-a-qml-module-to-your-library-target">Add a QML module to your library target</a></li>
<li class="level1"><a href="#use-loadfrommodule-to-load-your-qml-files">Use loadFromModule to load your QML files</a></li>
<li class="level1"><a href="#remove-handwritten-qmldir-files">Remove handwritten qmldir files</a></li>
<li class="level1"><a href="#remove-qmltypes-files-generated-by-qmlplugindump">Remove qmltypes files generated by qmlplugindump</a></li>
<li class="level1"><a href="#remove-handwritten-type-registration-plugins">Remove handwritten type registration plugins</a></li>
<li class="level1"><a href="#remove-qrc-files">Remove qrc files</a></li>
<li class="level1"><a href="#replace-directory-imports-with-qml-module-imports">Replace directory imports with QML module imports</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">Port QML modules to CMake</h1>
<!-- $$$qt6-port-to-qt-add-qml-module.html-description -->
<div class="descr" id="details">
<p>QML modules have become more powerful and easier to use in Qt 6. The following sections describe how to port QML modules to the <a href="qt-add-qml-module.html">qt_add_qml_module</a> CMake API.</p>
<p>See also <a href="qt6-modernize-qml-modules.html">Modern QML modules</a> on how to modernize a QML module that already uses <a href="qt-add-qml-module.html">qt_add_qml_module</a>.</p>
<h2 id="identify-issues-to-fix">Identify issues to fix</h2>
<p>Use <a href="qtqml-tooling-qmllint.html">qmllint</a> to support you through the process.</p>
<p>Each QML module defined with <a href="qt-add-qml-module.html">qt_add_qml_module</a> has a <code translate="no">_qmllint</code> CMake target that you can use to identify potential issues or improvements. For a QML module called <code translate="no">MyQmlLibrary</code> use <code translate="no">MyQmlLibrary_qmllint</code>, for example. To run <a href="qtqml-tooling-qmllint.html">qmllint</a> on all QML modules, use <code translate="no">all_qmllint</code>.</p>
<p>The warning categories of <a href="qtqml-tooling-qmllint.html">qmllint</a> that hint at QML module issues are:</p>
<ul>
<li><a href="qmllint-warnings-and-errors-import.html">[import]</a></li>
<li><a href="qmllint-warnings-and-errors-unused-imports.html">[unused-imports]</a></li>
<li><a href="qmllint-warnings-and-errors-unresolved-type.html">[unresolved-type]</a></li>
<li><a href="qmllint-warnings-and-errors-unresolved-alias.html">[unresolved-alias]</a></li>
<li><a href="qmllint-warnings-and-errors-missing-enum-entry.html">[missing-enum-entry]</a></li>
<li><a href="qmllint-warnings-and-errors-missing-property.html">[missing-property]</a></li>
<li><a href="qmllint-warnings-and-errors-missing-type.html">[missing-type]</a></li>
</ul>
<h2 id="prepare-the-project-for-qt-add-qml-module">Prepare the project for qt_add_qml_module</h2>
<h3 id="make-qt-add-qml-module-available-in-cmake">Make qt_add_qml_module available in CMake</h3>
<p>To make <a href="qt-add-qml-module.html">qt_add_qml_module</a> available in CMake, add <code translate="no">Core</code> and <code translate="no">Qml</code> to your <code translate="no">find_package</code> call in the project's top-level <code translate="no">CMakeLists.txt</code> file:</p>
<pre class="cpp plain" translate="no">
 find_package(Qt6 REQUIRED COMPONENTS Core Qml)
</pre>
<h3 id="use-qt-standard-project-setup">Use qt_standard_project_setup</h3>
<p><a href="../qtcore/qt-standard-project-setup.html">qt_standard_project_setup</a> sets up Qt CMake policies needed for <a href="qt-add-qml-module.html">qt_add_qml_module</a>, among other things.</p>
<p>Call <a href="../qtcore/qt-standard-project-setup.html">qt_standard_project_setup</a> in the project's top-level <code translate="no">CMakeLists.txt</code> file before any <a href="qt-add-qml-module.html">qt_add_qml_module</a> call:</p>
<pre class="cpp plain" translate="no">
 qt_standard_project_setup(REQUIRES 6.8)
</pre>
<h2 id="use-qt-add-qml-module">Use qt_add_qml_module</h2>
<p><a href="qt-add-qml-module.html">qt_add_qml_module</a> is the CMake function that takes care of generating QML modules. It automatically generates <code translate="no">qmldir</code> and <code translate="no">qmltypes</code> files, and sets up tooling like <a href="qtqml-tool-qmlcachegen.html">qmlcachegen</a> or <a href="qtqml-tooling-qmllint.html">qmllint</a>.</p>
<p>QML modules can be added to both executable and library targets in CMake. QML modules attached to the executable target can't be used or linked by other executables, while QML modules attached to library targets can.</p>
<h3 id="add-a-qml-module-to-your-executable-target">Add a QML module to your executable target</h3>
<p>In this case, the source files of the QML module are treated as part of the executable itself, rather than being compiled into a separate library. This means neither a module nor plugin library for this module is created&mdash;&ndash;the module is fully integrated into the executable. As a result, the module is tied to that specific program and cannot be reused by other executables or libraries.</p>
<p>To add a QML module to your executable, in your <code translate="no">CMakeLists.txt</code>:</p>
<pre class="cpp plain" translate="no">
 # pre-existing:
 qt_add_executable(MyApp main.cpp)

 # add this
 qt_add_qml_module(MyApp
     URI MyAppModule
     QML_FILES
         Main.qml # and possibly more .qml files
 )
</pre>
<p>The <code translate="no">Main.qml</code> should start with an upper case letter so that it can be instantiated by <code translate="no">loadFromModule</code> methods like <a href="qqmlapplicationengine.html#loadFromModule" translate="no">QQmlApplicationEngine::loadFromModule</a> or <a href="qqmlcomponent.html#loadFromModule" translate="no">QQmlComponent::loadFromModule</a>. Also, the QML module URI should be different from the target name to avoid name clashes in the build folder.</p>
<h3 id="add-a-qml-module-to-your-library-target">Add a QML module to your library target</h3>
<p>To add a QML module to your library, in your <code translate="no">CMakeLists.txt</code>:</p>
<pre class="cpp plain" translate="no">
 qt_add_qml_module(MyQmlLibrary
     URI MyQmlModule
     QML_FILES MyQmlComponent1.qml MyQmlComponent2.qml...
     SOURCES MyCppComponent1.h MyCppComponent1.cpp MyCppComponent2.h MyCppComponent2.cpp...
     RESOURCES MyResource1.png MyResource2.png...
 )
</pre>
<p><a href="qt-add-qml-module.html">qt_add_qml_module</a> creates a <code translate="no">SHARED</code> library via <a href="../qtcore/qt-add-library.html">qt_add_library</a> if the <code translate="no">MyQmlLibrary</code> target does not exist yet, like in this example.</p>
<div class="admonition note">
<p><b>Note: </b>Your QML module URI should be different from the target name to avoid name clashes in the build folder.</p>
</div>
<h2 id="use-loadfrommodule-to-load-your-qml-files">Use loadFromModule to load your QML files</h2>
<p>Use <code translate="no">loadFromModule</code> to load your QML file, for example:</p>
<pre class="cpp plain" translate="no">
 engine.load(QUrl(QStringLiteral(&quot;qrc:/MyQmlModule/Main.qml&quot;)));
 // becomes
 engine.loadFromModule(&quot;MyQmlModule&quot;, &quot;Main&quot;);
</pre>
<h2 id="remove-handwritten-qmldir-files">Remove handwritten qmldir files</h2>
<p><a href="qt-add-qml-module.html">qt_add_qml_module</a> automatically generates <code translate="no">qmldir</code> files. If you have singletons in your <code translate="no">qmldir</code>, declare them in your <code translate="no">CMakeLists.txt</code> before the <a href="qt-add-qml-module.html">qt_add_qml_module</a> call with:</p>
<pre class="cpp plain" translate="no">
 set_source_files_properties(MySingleton.qml PROPERTIES QT_QML_SINGLETON_TYPE TRUE)
</pre>
<p>Delete the handwritten <code translate="no">qmldir</code> after that.</p>
<h2 id="remove-qmltypes-files-generated-by-qmlplugindump">Remove qmltypes files generated by qmlplugindump</h2>
<p><a href="qt-add-qml-module.html">qt_add_qml_module</a> auto-generates <code translate="no">qmltypes</code> files when all your types are using <a href="qtqml-cppintegration-definetypes.html#registering-c-types-with-the-qml-type-system">declarative type registration</a>, which removes the need to generate <code translate="no">qmltypes</code> files by hand using tools like <code translate="no">qmlplugindump</code>.</p>
<p>To achieve that, remove manual calls to <code translate="no">qmlRegisterType</code> and its variants. Then, <a href="qtqml-cppintegration-definetypes.html#registering-c-types-with-the-qml-type-system">register your types declaratively</a> by using <a href="qqmlintegration-h-qtqml-proxy.html#QML_ELEMENT" translate="no">QML_ELEMENT</a>, for example:</p>
<pre class="cpp plain" translate="no">
 // add this header
 #include &lt;QtQml/qqmlregistrations.h&gt;

 class MyComponent: public QObject {
     Q_OBJECT

     // add this line to register MyComponent as 'MyComponent' in QML.
     QML_ELEMENT
     ....
 };
</pre>
<p>See <a href="qtqml-cppintegration-definetypes.html#registering-c-types-with-the-qml-type-system">Registering C++ Types with the QML Type System</a> on how to handle more complicated registration cases like foreign type registration.</p>
<p>Delete the handwritten <code translate="no">qmltypes</code> files after that.</p>
<h2 id="remove-handwritten-type-registration-plugins">Remove handwritten type registration plugins</h2>
<p><a href="qt-add-qml-module.html">qt_add_qml_module</a> can generate a <a href="qtqml-modules-cppplugins.html">QML module plugin</a> automatically for you. You don't need a handwritten plugin if your plugin's only task is to do type registration. Remove the plugin altogether if switching to declarative type registration did remove all the code from your plugin.</p>
<p>Make sure that you <i>remove</i> the <code translate="no">NO_PLUGIN</code>, <code translate="no">NO_PLUGIN_OPTIONAL</code>, <code translate="no">NO_CREATE_PLUGIN_TARGET</code>, and <code translate="no">NO_GENERATE_PLUGIN_SOURCE</code> arguments from <a href="qt-add-qml-module.html">qt_add_qml_module</a> to allow automatic plugin generation.</p>
<h2 id="remove-qrc-files">Remove qrc files</h2>
<p><a href="qt-add-qml-module.html">qt_add_qml_module</a> automatically generates <code translate="no">qrc</code> files. To list resources in the <code translate="no">qrc</code> files, like images or sound files, add them to <a href="qt-add-qml-module.html">qt_add_qml_module</a>'s <code translate="no">RESOURCES</code> argument. You can find the Module's resources under <code translate="no">:/qt/qml/MyQmlLibraryModule/</code>.</p>
<h2 id="replace-directory-imports-with-qml-module-imports">Replace directory imports with QML module imports</h2>
<p>Replace directory imports with QML module imports. For example,</p>
<pre class="cpp plain" translate="no">
 import &quot;content&quot; // contains SomeType.qml
 // becomes
 import MyQmlModule // contains SomeType.qml

 SomeType {
     ...
 }
</pre>
<p>Note that files inside a QML module automatically import their own QML module. You can remove the self-imports.</p>
</div>
<p><b>See also </b><a href="qml-changes-qt6.html">Changes to Qt QML</a> and <a href="qt6-modernize-qml-modules.html">Modern QML modules</a>.</p>
<!-- @@@qt6-port-to-qt-add-qml-module.html -->
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <abbr title="Copyright">&copy;</abbr> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
