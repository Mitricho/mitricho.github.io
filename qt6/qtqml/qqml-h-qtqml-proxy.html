<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>qqml.h Proxy Page | Qt Qml | Qt 6.9.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li>Qt 6.9</li>
<li><a href="qtqml-index.html">Qt Qml</a></li>
<li>qqml.h Proxy Page</li>
<li id="buildversion"><a href="qtqml-index.html">Qt 6.9.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<h1 class="title">qqml.h Proxy Page</h1>
<h2 id="types">Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qqml-h-qtqml-proxy.html#QQmlModuleImportSpecialVersions-enum" translate="no">QQmlModuleImportSpecialVersions</a></b> { QQmlModuleImportModuleAny, QQmlModuleImportLatest, QQmlModuleImportAuto }</td></tr>
</table></div>
<h2 id="functions">Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> QObject *</td><td class="memItemRight bottomAlign"><b><a href="qqml-h-qtqml-proxy.html#qmlAttachedPropertiesObject" translate="no">qmlAttachedPropertiesObject</a></b>(const QObject *<i>attachee</i>, bool <i>create</i> = true)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqml-h-qtqml-proxy.html#qmlClearTypeRegistrations" translate="no">qmlClearTypeRegistrations</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QObject *</td><td class="memItemRight bottomAlign"><b><a href="qqml-h-qtqml-proxy.html#qmlExtendedObject" translate="no">qmlExtendedObject</a></b>(QObject *<i>base</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qqml-h-qtqml-proxy.html#qmlProtectModule" translate="no">qmlProtectModule</a></b>(const char *<i>uri</i>, int <i>majVersion</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qqml-h-qtqml-proxy.html#qmlRegisterAnonymousType" translate="no">qmlRegisterAnonymousType</a></b>(const char *<i>uri</i>, int <i>versionMajor</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qqml-h-qtqml-proxy.html#qmlRegisterExtendedType" translate="no">qmlRegisterExtendedType</a></b>(const char *<i>uri</i>, int <i>versionMajor</i>, int <i>versionMinor</i>, const char *<i>qmlName</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qqml-h-qtqml-proxy.html#qmlRegisterExtendedUncreatableType" translate="no">qmlRegisterExtendedUncreatableType</a></b>(const char *<i>uri</i>, int <i>versionMajor</i>, int <i>versionMinor</i>, const char *<i>qmlName</i>, const QString &amp;<i>reason</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqml-h-qtqml-proxy.html#qmlRegisterModule" translate="no">qmlRegisterModule</a></b>(const char *<i>uri</i>, int <i>versionMajor</i>, int <i>versionMinor</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqml-h-qtqml-proxy.html#qmlRegisterModuleImport" translate="no">qmlRegisterModuleImport</a></b>(const char *<i>uri</i>, int <i>moduleMajor</i>, const char *<i>import</i>, int <i>importMajor</i> = QQmlModuleImportLatest, int <i>importMinor</i> = QQmlModuleImportLatest)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qqml-h-qtqml-proxy.html#qmlRegisterRevision" translate="no">qmlRegisterRevision</a></b>(const char *<i>uri</i>, int <i>versionMajor</i>, int <i>versionMinor</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qqml-h-qtqml-proxy.html#qmlRegisterSingletonInstance" translate="no">qmlRegisterSingletonInstance</a></b>(const char *<i>uri</i>, int <i>versionMajor</i>, int <i>versionMinor</i>, const char *<i>typeName</i>, QObject *<i>cppObject</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qqml-h-qtqml-proxy.html#qmlRegisterSingletonType" translate="no">qmlRegisterSingletonType</a></b>(const QUrl &amp;<i>url</i>, const char *<i>uri</i>, int <i>versionMajor</i>, int <i>versionMinor</i>, const char *<i>qmlName</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qqml-h-qtqml-proxy.html#qmlRegisterSingletonType-1" translate="no">qmlRegisterSingletonType</a></b>(const char *<i>uri</i>, int <i>versionMajor</i>, int <i>versionMinor</i>, const char *<i>typeName</i>, std::function&lt;QJSValue (QQmlEngine *, QJSEngine *)&gt; <i>callback</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qqml-h-qtqml-proxy.html#qmlRegisterSingletonType-2" translate="no">qmlRegisterSingletonType</a></b>(const char *<i>uri</i>, int <i>versionMajor</i>, int <i>versionMinor</i>, const char *<i>typeName</i>, std::function&lt;QObject *(QQmlEngine *, QJSEngine *)&gt; <i>callback</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qqml-h-qtqml-proxy.html#qmlRegisterType" translate="no">qmlRegisterType</a></b>(const char *<i>uri</i>, int <i>versionMajor</i>, int <i>versionMinor</i>, const char *<i>qmlName</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qqml-h-qtqml-proxy.html#qmlRegisterType-1" translate="no">qmlRegisterType</a></b>(const QUrl &amp;<i>url</i>, const char *<i>uri</i>, int <i>versionMajor</i>, int <i>versionMinor</i>, const char *<i>qmlName</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qqml-h-qtqml-proxy.html#qmlRegisterTypeNotAvailable" translate="no">qmlRegisterTypeNotAvailable</a></b>(const char *<i>uri</i>, int <i>versionMajor</i>, int <i>versionMinor</i>, const char *<i>qmlName</i>, const QString &amp;<i>message</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qqml-h-qtqml-proxy.html#qmlRegisterUncreatableMetaObject" translate="no">qmlRegisterUncreatableMetaObject</a></b>(const QMetaObject &amp;<i>staticMetaObject</i>, const char *<i>uri</i>, int <i>versionMajor</i>, int <i>versionMinor</i>, const char *<i>qmlName</i>, const QString &amp;<i>reason</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qqml-h-qtqml-proxy.html#qmlRegisterUncreatableType" translate="no">qmlRegisterUncreatableType</a></b>(const char *<i>uri</i>, int <i>versionMajor</i>, int <i>versionMinor</i>, const char *<i>qmlName</i>, const QString &amp;<i>message</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qqml-h-qtqml-proxy.html#qmlTypeId" translate="no">qmlTypeId</a></b>(const char *<i>uri</i>, int <i>versionMajor</i>, int <i>versionMinor</i>, const char *<i>qmlName</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqml-h-qtqml-proxy.html#qmlUnregisterModuleImport" translate="no">qmlUnregisterModuleImport</a></b>(const char *<i>uri</i>, int <i>moduleMajor</i>, const char *<i>import</i>, int <i>importMajor</i> = QQmlModuleImportLatest, int <i>importMinor</i> = QQmlModuleImportLatest)</td></tr>
</table></div>
<h2 id="macros">Macros</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qqml-h-qtqml-proxy.html#QML_DECLARE_TYPE" translate="no">QML_DECLARE_TYPE</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qqml-h-qtqml-proxy.html#QML_DECLARE_TYPEINFO" translate="no">QML_DECLARE_TYPEINFO</a></b>(<i>Type</i>, <i>Flags</i>)</td></tr>
</table></div>
<div class="types">
<h2>Type Documentation</h2>
<!-- $$$QQmlModuleImportSpecialVersions$$$QQmlModuleImportModuleAny$$$QQmlModuleImportLatest$$$QQmlModuleImportAuto -->
<h3 class="fn" translate="no" id="QQmlModuleImportSpecialVersions-enum">enum <span class="name">QQmlModuleImportSpecialVersions</span></h3>
<p>Defines some special values that can be passed to the version arguments of <a href="qqml-h-qtqml-proxy.html#qmlRegisterModuleImport" translate="no">qmlRegisterModuleImport</a>() and <a href="qqml-h-qtqml-proxy.html#qmlUnregisterModuleImport" translate="no">qmlUnregisterModuleImport</a>().</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">qqml.h::QQmlModuleImportModuleAny</code></td><td class="topAlign tblval"><code translate="no">-1</code></td><td class="topAlign">When passed as majorVersion of the base module, signifies that the import is to be applied to any version of the module.</td></tr>
<tr><td class="topAlign"><code translate="no">qqml.h::QQmlModuleImportLatest</code></td><td class="topAlign tblval"><code translate="no">-1</code></td><td class="topAlign">When passed as major or minor version of the imported module, signifies that the latest overall, or latest minor version of a specified major version shall be imported.</td></tr>
<tr><td class="topAlign"><code translate="no">qqml.h::QQmlModuleImportAuto</code></td><td class="topAlign tblval"><code translate="no">-2</code></td><td class="topAlign">When passed as major version of the imported module, signifies that the version of the base module shall be forwarded.</td></tr>
</table></div>
<!-- @@@QQmlModuleImportSpecialVersions -->
</div>
<div class="func">
<h2>Function Documentation</h2>
<!-- $$$qmlAttachedPropertiesObject[overload1]$$$qmlAttachedPropertiesObjectconstQObject*bool -->
<h3 class="fn" translate="no" id="qmlAttachedPropertiesObject">template &lt;typename T&gt; <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span> *<span class="name">qmlAttachedPropertiesObject</span>(const <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span> *<i>attachee</i>, <span class="type">bool</span> <i>create</i> = true)</h3>
<p>The form of this template function is:</p>
<pre class="cpp" translate="no">
 <span class="keyword">template</span><span class="operator">&lt;</span><span class="keyword">typename</span> T<span class="operator">&gt;</span> <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span> <span class="operator">*</span>qmlAttachedPropertiesObject(<span class="keyword">const</span> <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span> <span class="operator">*</span>attachee<span class="operator">,</span> <span class="type">bool</span> create <span class="operator">=</span> <span class="keyword">true</span>)
</pre>
<p>This returns the attached object instance that has been attached to the specified <i translate="no">attachee</i> by the attaching type <i>T</i>.</p>
<p>If <i translate="no">create</i> is true and type <i>T</i> is a valid attaching type, this creates and returns a new attached object instance.</p>
<p>Returns <code translate="no">nullptr</code> if type <i>T</i> is not a valid attaching type, or if <i translate="no">create</i> is false and no attachment object instance has previously been created for <i translate="no">attachee</i>.</p>
<p><b>See also </b><a href="qqmlintegration-h-qtqml-proxy.html#QML_ATTACHED" translate="no">QML_ATTACHED</a>() and <a href="qtqml-cppintegration-definetypes.html#providing-attached-properties">Providing Attached Properties</a>.</p>
<!-- @@@qmlAttachedPropertiesObject -->
<!-- $$$qmlClearTypeRegistrations[overload1]$$$qmlClearTypeRegistrations -->
<h3 class="fn" translate="no" id="qmlClearTypeRegistrations"><span class="type">void</span> <span class="name">qmlClearTypeRegistrations</span>()</h3>
<p>Clears all stored type registrations, such as those produced with <a href="qqml-h-qtqml-proxy.html#qmlRegisterType" translate="no">qmlRegisterType</a>().</p>
<p>Do not call this function while a <a href="qqmlengine.html" translate="no">QQmlEngine</a> exists or behavior will be undefined. Any existing QQmlEngines must be deleted before calling this function. This function only affects the application global cache. Delete the <a href="qqmlengine.html" translate="no">QQmlEngine</a> to clear all cached data relating to that engine.</p>
<!-- @@@qmlClearTypeRegistrations -->
<!-- $$$qmlExtendedObject[overload1]$$$qmlExtendedObjectQObject* -->
<h3 class="fn" translate="no" id="qmlExtendedObject"><span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span> *<span class="name">qmlExtendedObject</span>(<span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span> *<i>base</i>)</h3>
<p>This function returns the extension object that belongs to <i translate="no">base</i>, if there is any. Otherwise it returns <code translate="no">nullptr</code>.</p>
<p><b>See also </b><a href="qqmlintegration-h-qtqml-proxy.html#QML_EXTENDED" translate="no">QML_EXTENDED</a>.</p>
<!-- @@@qmlExtendedObject -->
<!-- $$$qmlProtectModule[overload1]$$$qmlProtectModuleconstchar*int -->
<h3 class="fn" translate="no" id="qmlProtectModule"><span class="type">bool</span> <span class="name">qmlProtectModule</span>(const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>majVersion</i>)</h3>
<p>This function protects a module from further modification. This can be used to prevent other plugins from injecting types into your module. It can also be a performance improvement, as it allows the engine to skip checking for the possibility of new types or plugins when this import is reached.</p>
<p>Once qmlProtectModule has been called, a QML engine will not search for a new <code translate="no">qmldir</code> file to load the module anymore. It will re-use any <code translate="no">qmldir</code> files it has loaded before, though. Therefore, types present at this point continue to work. Mind that different QML engines may load different modules. The module protection, however, is global and affects all engines. The overhead of locating <code translate="no">qmldir</code> files and loading plugins may be noticeable with slow file systems. Therefore, protecting a module once you are sure you won't need to load it anymore can be a good optimization. Mind also that the module lock not only affects plugins but also any other qmldir directives, like <code translate="no">import</code> or <code translate="no">prefer</code>, as well as any composite types or scripts declared in a <code translate="no">qmldir</code> file.</p>
<p>In addition, after this function is called, any attempt to register C++ types into this uri, major version combination will lead to a runtime error.</p>
<p>Returns true if the module with <i translate="no">uri</i> as a <a href="qtqml-modules-identifiedmodules.html">module identifier</a> and <i translate="no">majVersion</i> as a major version number was found and locked, otherwise returns false. The module must contain exported types in order to be found.</p>
<!-- @@@qmlProtectModule -->
<!-- $$$qmlRegisterAnonymousType[overload1]$$$qmlRegisterAnonymousTypeconstchar*int -->
<h3 class="fn" translate="no" id="qmlRegisterAnonymousType">template &lt;typename T&gt; <span class="type">int</span> <span class="name">qmlRegisterAnonymousType</span>(const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>)</h3>
<p>This template function registers the C++ type in the QML system as an anonymous type. The resulting QML type does not have a name. Therefore, instances of this type cannot be created from the QML system. You can, however, access instances of the type when they are exposed as properties of other types.</p>
<p>Use this function when the type will not be referenced by name, specifically for C++ types that are used on the left-hand side of a property binding. To indicate to which module the type belongs use <i translate="no">uri</i> and <i translate="no">versionMajor</i>.</p>
<p>For example, consider the following two classes:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> Bar : <span class="keyword">public</span> <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span>
 {
     Q_OBJECT
     Q_PROPERTY(<span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> baz READ baz WRITE setBaz NOTIFY bazChanged)

 <span class="keyword">public</span>:
     Bar() {}

     <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> baz() <span class="keyword">const</span> { <span class="keyword">return</span> mBaz; }

     <span class="type">void</span> setBaz(<span class="keyword">const</span> <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> <span class="operator">&amp;</span>baz)
     {
         <span class="keyword">if</span> (baz <span class="operator">=</span><span class="operator">=</span> mBaz)
             <span class="keyword">return</span>;

         mBaz <span class="operator">=</span> baz;
         <span class="keyword">emit</span> bazChanged();
     }

 <span class="keyword">signals</span>:
     <span class="type">void</span> bazChanged();

 <span class="keyword">private</span>:
     <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> mBaz;
 };

 <span class="keyword">class</span> Foo : <span class="keyword">public</span> <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span>
 {
     Q_OBJECT
     Q_PROPERTY(Bar <span class="operator">*</span>bar READ bar CONSTANT FINAL)

 <span class="keyword">public</span>:
     Foo() {}

     Bar <span class="operator">*</span>bar() { <span class="keyword">return</span> <span class="operator">&amp;</span>mBar; }

 <span class="keyword">private</span>:
     Bar mBar;
 };
</pre>
<p>In QML, we assign a string to the <code translate="no">baz</code> property of <code translate="no">bar</code>:</p>
<pre class="cpp" translate="no">
 Foo {
     bar<span class="operator">.</span>baz: <span class="string">&quot;abc&quot;</span>
     Component<span class="operator">.</span>onCompleted: print(bar<span class="operator">.</span>baz)
 }
</pre>
<p>For the QML engine to know that the <code translate="no">Bar</code> type has a <code translate="no">baz</code> property, we have to make <code translate="no">Bar</code> known:</p>
<pre class="cpp" translate="no">
 qmlRegisterType<span class="operator">&lt;</span>Foo<span class="operator">&gt;</span>(<span class="string">&quot;App&quot;</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="string">&quot;Foo&quot;</span>);
 qmlRegisterAnonymousType<span class="operator">&lt;</span>Bar<span class="operator">&gt;</span>(<span class="string">&quot;App&quot;</span><span class="operator">,</span> <span class="number">1</span>);
</pre>
<p>As the <code translate="no">Foo</code> type is instantiated in QML, it must be registered with the version of <a href="qqml-h-qtqml-proxy.html#qmlRegisterType" translate="no">qmlRegisterType</a>() that takes an element name.</p>
<p>Returns the QML type id.</p>
<p><b>See also </b><a href="qqmlintegration-h-qtqml-proxy.html#QML_ANONYMOUS" translate="no">QML_ANONYMOUS</a> and <a href="qtqml-cppintegration-overview.html#choosing-the-correct-integration-method-between-c-and-qml">Choosing the Correct Integration Method Between C++ and QML</a>.</p>
<!-- @@@qmlRegisterAnonymousType -->
<!-- $$$qmlRegisterExtendedType[overload1]$$$qmlRegisterExtendedTypeconstchar*intintconstchar* -->
<h3 class="fn" translate="no" id="qmlRegisterExtendedType">template &lt;typename T, typename E&gt; <span class="type">int</span> <span class="name">qmlRegisterExtendedType</span>(const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>, <span class="type">int</span> <i>versionMinor</i>, const <span class="type">char</span> *<i>qmlName</i>)</h3>
<p>This template function registers the C++ type and its extension object in the QML system with the name <i translate="no">qmlName</i> in the library imported from <i translate="no">uri</i> having version number composed from <i translate="no">versionMajor</i> and <i translate="no">versionMinor</i>. Properties not available in the main type will be searched for in the extension object.</p>
<p>Returns the QML type id.</p>
<p><b>See also </b><a href="qqmlintegration-h-qtqml-proxy.html#QML_EXTENDED" translate="no">QML_EXTENDED</a>(), <a href="qqml-h-qtqml-proxy.html#qmlRegisterType" translate="no">qmlRegisterType</a>(), and <a href="qtqml-cppintegration-definetypes.html#registering-extension-objects">Registering Extension Objects</a>.</p>
<!-- @@@qmlRegisterExtendedType -->
<!-- $$$qmlRegisterExtendedUncreatableType[overload1]$$$qmlRegisterExtendedUncreatableTypeconstchar*intintconstchar*constQString& -->
<h3 class="fn" translate="no" id="qmlRegisterExtendedUncreatableType">template &lt;typename T, typename E&gt; <span class="type">int</span> <span class="name">qmlRegisterExtendedUncreatableType</span>(const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>, <span class="type">int</span> <i>versionMinor</i>, const <span class="type">char</span> *<i>qmlName</i>, const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>reason</i>)</h3>
<p>This template function registers the C++ type and its extension in the QML system with the name <i translate="no">qmlName</i> in the library imported from <i translate="no">uri</i> having version number composed from <i translate="no">versionMajor</i> and <i translate="no">versionMinor</i>.</p>
<p>While the type has a name and a type, it cannot be created. An error message with the given <i translate="no">reason</i> is printed if the user attempts to create an instance of this type.</p>
<p>This is useful where the type is only intended for providing attached properties, enum values or an abstract base class with its extension.</p>
<p>Returns the QML type id.</p>
<p><b>See also </b><a href="qqmlintegration-h-qtqml-proxy.html#QML_EXTENDED" translate="no">QML_EXTENDED</a>(), <a href="qqmlintegration-h-qtqml-proxy.html#QML_UNCREATABLE" translate="no">QML_UNCREATABLE</a>(), and <a href="qqml-h-qtqml-proxy.html#qmlRegisterUncreatableType" translate="no">qmlRegisterUncreatableType</a>().</p>
<!-- @@@qmlRegisterExtendedUncreatableType -->
<!-- $$$qmlRegisterModule[overload1]$$$qmlRegisterModuleconstchar*intint -->
<h3 class="fn" translate="no" id="qmlRegisterModule"><span class="type">void</span> <span class="name">qmlRegisterModule</span>(const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>, <span class="type">int</span> <i>versionMinor</i>)</h3>
<p>This function registers a module in a particular <i translate="no">uri</i> with a version specified in <i translate="no">versionMajor</i> and <i translate="no">versionMinor</i>.</p>
<p>This can be used to make a certain module version available, even if no types are registered for that version. This is particularly useful for keeping the versions of related modules in sync.</p>
<!-- @@@qmlRegisterModule -->
<!-- $$$qmlRegisterModuleImport[overload1]$$$qmlRegisterModuleImportconstchar*intconstchar*intint -->
<h3 class="fn" translate="no" id="qmlRegisterModuleImport"><span class="type">void</span> <span class="name">qmlRegisterModuleImport</span>(const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>moduleMajor</i>, const <span class="type">char</span> *<i>import</i>, <span class="type">int</span> <i>importMajor</i> = QQmlModuleImportLatest, <span class="type">int</span> <i>importMinor</i> = QQmlModuleImportLatest)</h3>
<p>Registers a qmldir-import for module <i translate="no">uri</i> of major version <i translate="no">moduleMajor</i>.</p>
<p>This has the same effect as an <code translate="no">import</code> statement in a qmldir file: Whenever <i translate="no">uri</i> of version <i translate="no">moduleMajor</i> is imported, <i translate="no">import</i> of version <i translate="no">importMajor</i>. <i translate="no">importMinor</i> is automatically imported, too. If <i translate="no">importMajor</i> is <a href="qqml-h-qtqml-proxy.html#QQmlModuleImportSpecialVersions-enum" translate="no">QQmlModuleImportLatest</a> the latest version available of that module is imported, and <i translate="no">importMinor</i> does not matter. If <i translate="no">importMinor</i> is <a href="qqml-h-qtqml-proxy.html#QQmlModuleImportSpecialVersions-enum" translate="no">QQmlModuleImportLatest</a> the latest minor version of a <i translate="no">importMajor</i> is chosen. If <i translate="no">importMajor</i> is <a href="qqml-h-qtqml-proxy.html#QQmlModuleImportSpecialVersions-enum" translate="no">QQmlModuleImportAuto</a> the version of <i translate="no">import</i> is version of <i translate="no">uri</i> being imported, and <i translate="no">importMinor</i> does not matter. If <i translate="no">moduleMajor</i> is <a href="qqml-h-qtqml-proxy.html#QQmlModuleImportSpecialVersions-enum" translate="no">QQmlModuleImportModuleAny</a> the module import is applied for any major version of <i translate="no">uri</i>. For example, you may specify that whenever any version of MyModule is imported, the latest version of MyOtherModule should be imported. Then, the following call would be appropriate:</p>
<pre class="cpp" translate="no">
 qmlRegisterModuleImport(<span class="string">&quot;MyModule&quot;</span><span class="operator">,</span> <span class="type"><a href="qqml-h-qtqml-proxy.html#QQmlModuleImportSpecialVersions-enum" translate="no">QQmlModuleImportModuleAny</a></span><span class="operator">,</span>
                         <span class="string">&quot;MyOtherModule&quot;</span><span class="operator">,</span> <span class="type"><a href="qqml-h-qtqml-proxy.html#QQmlModuleImportSpecialVersions-enum" translate="no">QQmlModuleImportLatest</a></span>);
</pre>
<p>Or, you may specify that whenever major version 5 of &quot;MyModule&quot; is imported, then version 3.14 of &quot;MyOtherModule&quot; should be imported:</p>
<pre class="cpp" translate="no">
 qmlRegisterModuleImport(<span class="string">&quot;MyModule&quot;</span><span class="operator">,</span> <span class="number">5</span><span class="operator">,</span> <span class="string">&quot;MyOtherModule&quot;</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> <span class="number">14</span>);
</pre>
<p>Finally, if you always want the same version of &quot;MyOtherModule&quot; to be imported whenever &quot;MyModule&quot; is imported, specify the following:</p>
<pre class="cpp" translate="no">
 qmlRegisterModuleImport(<span class="string">&quot;MyModule&quot;</span><span class="operator">,</span> <span class="type"><a href="qqml-h-qtqml-proxy.html#QQmlModuleImportSpecialVersions-enum" translate="no">QQmlModuleImportModuleAny</a></span><span class="operator">,</span>
                         <span class="string">&quot;MyOtherModule&quot;</span><span class="operator">,</span> <span class="type"><a href="qqml-h-qtqml-proxy.html#QQmlModuleImportSpecialVersions-enum" translate="no">QQmlModuleImportAuto</a></span>);
</pre>
<p><b>See also </b><a href="qqml-h-qtqml-proxy.html#qmlUnregisterModuleImport" translate="no">qmlUnregisterModuleImport</a>().</p>
<!-- @@@qmlRegisterModuleImport -->
<!-- $$$qmlRegisterRevision[overload1]$$$qmlRegisterRevisionconstchar*intint -->
<h3 class="fn" translate="no" id="qmlRegisterRevision">template &lt;typename T, int metaObjectRevision&gt; <span class="type">int</span> <span class="name">qmlRegisterRevision</span>(const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>, <span class="type">int</span> <i>versionMinor</i>)</h3>
<p>This template function registers the specified revision of a C++ type in the QML system with the library imported from <i translate="no">uri</i> having the version number composed from <i translate="no">versionMajor</i> and <i translate="no">versionMinor</i>.</p>
<p>Returns the QML type id.</p>
<pre class="cpp" translate="no">
 <span class="keyword">template</span><span class="operator">&lt;</span><span class="keyword">typename</span> T<span class="operator">,</span> <span class="type">int</span> metaObjectRevision<span class="operator">&gt;</span>
 <span class="type">int</span> qmlRegisterRevision(<span class="keyword">const</span> <span class="type">char</span> <span class="operator">*</span>uri<span class="operator">,</span> <span class="type">int</span> versionMajor<span class="operator">,</span> <span class="type">int</span> versionMinor);
</pre>
<p>This function is typically used to register the revision of a base class to use for the specified version of the type (see <a href="qtqml-cppintegration-definetypes.html#type-revisions-and-versions">Type Revisions and Versions</a>).</p>
<!-- @@@qmlRegisterRevision -->
<!-- $$$qmlRegisterSingletonInstance[overload1]$$$qmlRegisterSingletonInstanceconstchar*intintconstchar*QObject* -->
<h3 class="fn" translate="no" id="qmlRegisterSingletonInstance"><span class="type">int</span> <span class="name">qmlRegisterSingletonInstance</span>(const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>, <span class="type">int</span> <i>versionMinor</i>, const <span class="type">char</span> *<i>typeName</i>, <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span> *<i>cppObject</i>)</h3>
<p>This function is used to register a singleton object <i translate="no">cppObject</i>, with a particular <i translate="no">uri</i> and <i translate="no">typeName</i>. Its version is a combination of <i translate="no">versionMajor</i> and <i translate="no">versionMinor</i>.</p>
<p>Installing a singleton type into a URI allows you to provide arbitrary functionality (methods and properties) to QML code without requiring individual instances of the type to be instantiated by the client.</p>
<p>Use this function to register an object of the given type T as a singleton type.</p>
<p>A <a href="../qtcore/qobject.html" translate="no">QObject</a> singleton type may be referenced via the type name with which it was registered; in turn this type name may be used as the target in a <a href="qml-qtqml-connections.html" translate="no">Connections</a> type, or like any other type ID. However, there's one exception: a <a href="../qtcore/qobject.html" translate="no">QObject</a> singleton type property can't be aliased because the singleton type name does not identify an object within the same component as any other item.</p>
<div class="admonition note">
<p><b>Note: </b><i translate="no">cppObject</i> must outlive the QML engine in which it is used. Moreover, cppObject must have the same thread affinity as the engine. If you want separate singleton instances for multiple engines, you need to use <a href="qqml-h-qtqml-proxy.html#qmlRegisterSingletonType" translate="no">qmlRegisterSingletonType</a>. See Threads and QObjects for more information about thread safety.</p>
</div>
<p><b>NOTE:</b> qmlRegisterSingleton can only be used when all types of that module are registered procedurally.</p>
<p>Usage:</p>
<pre class="cpp" translate="no">
 <span class="comment">// First, define your QObject which provides the functionality.</span>
 <span class="keyword">class</span> SingletonTypeExample : <span class="keyword">public</span> <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span>
 {
     Q_OBJECT
     Q_PROPERTY(<span class="type">int</span> someProperty READ someProperty WRITE setSomeProperty NOTIFY somePropertyChanged)

 <span class="keyword">public</span>:
     <span class="keyword">explicit</span> SingletonTypeExample(<span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span><span class="operator">*</span> parent <span class="operator">=</span> nullptr) : <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span>(parent) {}

     Q_INVOKABLE <span class="type">int</span> doSomething()
     {
         setSomeProperty(<span class="number">5</span>);
         <span class="keyword">return</span> m_someProperty;
     }

     <span class="type">int</span> someProperty() <span class="keyword">const</span> { <span class="keyword">return</span> m_someProperty; }
     <span class="type">void</span> setSomeProperty(<span class="type">int</span> val) {
         <span class="keyword">if</span> (m_someProperty <span class="operator">!</span><span class="operator">=</span> val) {
             m_someProperty <span class="operator">=</span> val;
             <span class="keyword">emit</span> somePropertyChanged(val);
         }
     }

 <span class="keyword">signals</span>:
     <span class="type">void</span> somePropertyChanged(<span class="type">int</span> newValue);

 <span class="keyword">private</span>:
     <span class="type">int</span> m_someProperty <span class="operator">=</span> <span class="number">0</span>;
 };
</pre>
<pre class="cpp" translate="no">
 <span class="comment">// Second, create an instance of the object</span>

 <span class="comment">// allocate example before the engine to ensure that it outlives it</span>
 <span class="type"><a href="../qtcore/qscopedpointer.html" translate="no">QScopedPointer</a></span><span class="operator">&lt;</span>SingletonTypeExample<span class="operator">&gt;</span> example(<span class="keyword">new</span> SingletonTypeExample);
 <span class="type"><a href="qqmlengine.html" translate="no">QQmlEngine</a></span> engine;

 <span class="comment">// Third, register the singleton type provider with QML by calling this</span>
 <span class="comment">// function in an initialization function.</span>
 qmlRegisterSingletonInstance(<span class="string">&quot;Qt.example.qobjectSingleton&quot;</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="string">&quot;MyApi&quot;</span><span class="operator">,</span> example<span class="operator">.</span>get());
</pre>
<p>In order to use the registered singleton type in QML, you must import the URI with the corresponding version.</p>
<pre class="qml" translate="no">
 import QtQuick 2.0
 import Qt.example.qobjectSingleton 1.0
 <span class="type"><a href="../qtquick/qml-qtquick-item.html" translate="no">Item</a></span> {
     <span class="name">id</span>: <span class="name">root</span>
     property <span class="type"><a href="qml-int.html" translate="no">int</a></span> <span class="name">someValue</span>: <span class="name">MyApi</span>.<span class="name">someProperty</span>

     <span class="name">Component</span>.onCompleted: {
         <span class="name">console</span>.<span class="name">log</span>(<span class="name">MyApi</span>.<span class="name">doSomething</span>())
     }
 }
</pre>
<p><b>See also </b><a href="qqmlintegration-h-qtqml-proxy.html#QML_SINGLETON" translate="no">QML_SINGLETON</a> and <a href="qqml-h-qtqml-proxy.html#qmlRegisterSingletonType" translate="no">qmlRegisterSingletonType</a>.</p>
<!-- @@@qmlRegisterSingletonInstance -->
<!-- $$$qmlRegisterSingletonType[overload1]$$$qmlRegisterSingletonTypeconstQUrl&constchar*intintconstchar* -->
<h3 class="fn" translate="no" id="qmlRegisterSingletonType"><span class="type">int</span> <span class="name">qmlRegisterSingletonType</span>(const <span class="type"><a href="../qtcore/qurl.html" translate="no">QUrl</a></span> &amp;<i>url</i>, const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>, <span class="type">int</span> <i>versionMinor</i>, const <span class="type">char</span> *<i>qmlName</i>)</h3>
<p>This function may be used to register a singleton type with the name <i translate="no">qmlName</i>, in the library imported from <i translate="no">uri</i> having the version number composed from <i translate="no">versionMajor</i> and <i translate="no">versionMinor</i>. The type is defined by the QML file located at <i translate="no">url</i>. The url must be an absolute URL, i.e. url.isRelative() == false.</p>
<p>In addition the type's QML file must have pragma Singleton statement among its import statements.</p>
<p>A singleton type may be referenced via the type name with which it was registered, and this typename may be used as the target in a <a href="qml-qtqml-connections.html" translate="no">Connections</a> type or otherwise used as any other type id would. One exception to this is that a singleton type property may not be aliased (because the singleton type name does not identify an object within the same component as any other item).</p>
<p>Usage:</p>
<pre class="qml" translate="no">
 <span class="comment">// First, define your QML singleton type which provides the functionality.</span>
 pragma Singleton
 import QtQuick 2.0
 <span class="type"><a href="../qtquick/qml-qtquick-item.html" translate="no">Item</a></span> {
     property <span class="type"><a href="qml-int.html" translate="no">int</a></span> <span class="name">testProp1</span>: <span class="number">125</span>
 }
</pre>
<pre class="cpp" translate="no">
 <span class="comment">// Second, register the QML singleton type by calling this function in an initialization function.</span>
 qmlRegisterSingletonType(<span class="type"><a href="../qtcore/qurl.html" translate="no">QUrl</a></span>(<span class="string">&quot;file:///absolute/path/SingletonType.qml&quot;</span>)<span class="operator">,</span> <span class="string">&quot;Qt.example.qobjectSingleton&quot;</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="string">&quot;RegisteredSingleton&quot;</span>);
</pre>
<p>In order to use the registered singleton type in QML, you must import the singleton type.</p>
<pre class="qml" translate="no">
 import QtQuick 2.0
 import Qt.example.qobjectSingleton 1.0
 <span class="type"><a href="../qtquick/qml-qtquick-item.html" translate="no">Item</a></span> {
     <span class="name">id</span>: <span class="name">root</span>
     property <span class="type"><a href="qml-int.html" translate="no">int</a></span> <span class="name">someValue</span>: <span class="name">RegisteredSingleton</span>.<span class="name">testProp1</span>
 }
</pre>
<p>It is also possible to have QML singleton types registered without using the qmlRegisterSingletonType function. That can be done by adding a pragma Singleton statement among the imports of the type's QML file. In addition the type must be defined in a qmldir file with a singleton keyword and the qmldir must be imported by the QML files using the singleton.</p>
<p><b>See also </b><a href="qqmlintegration-h-qtqml-proxy.html#QML_SINGLETON" translate="no">QML_SINGLETON</a>.</p>
<!-- @@@qmlRegisterSingletonType -->
<!-- $$$qmlRegisterSingletonType$$$qmlRegisterSingletonTypeconstchar*intintconstchar*std::function<QJSValue(QQmlEngine*,QJSEngine*)> -->
<h3 class="fn" translate="no" id="qmlRegisterSingletonType-1"><span class="type">int</span> <span class="name">qmlRegisterSingletonType</span>(const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>, <span class="type">int</span> <i>versionMinor</i>, const <span class="type">char</span> *<i>typeName</i>, <span class="type">std::function</span>&lt;<span class="type"><a href="qjsvalue.html" translate="no">QJSValue</a></span> (<span class="type"><a href="qqmlengine.html" translate="no">QQmlEngine</a></span> *, <span class="type"><a href="qjsengine.html" translate="no">QJSEngine</a></span> *)&gt; <i>callback</i>)</h3>
<p>This function may be used to register a singleton type provider <i translate="no">callback</i> in a particular <i translate="no">uri</i> and <i translate="no">typeName</i> with a version specified in <i translate="no">versionMajor</i> and <i translate="no">versionMinor</i>.</p>
<p>Installing a singleton type allows developers to provide arbitrary functionality (methods and properties) to a client without requiring individual instances of the type to be instantiated by the client.</p>
<p>A singleton type may be either a <a href="../qtcore/qobject.html" translate="no">QObject</a> or a <a href="qjsvalue.html" translate="no">QJSValue</a>. This function should be used to register a singleton type provider function which returns a <a href="qjsvalue.html" translate="no">QJSValue</a> as a singleton type.</p>
<p><b>NOTE:</b> <a href="qjsvalue.html" translate="no">QJSValue</a> singleton type properties will <b>not</b> trigger binding re-evaluation if changed.</p>
<p>Usage:</p>
<pre class="cpp" translate="no">
 <span class="comment">// First, define the singleton type provider function (callback).</span>
 <span class="keyword">static</span> <span class="type"><a href="qjsvalue.html" translate="no">QJSValue</a></span> example_qjsvalue_singletontype_provider(<span class="type"><a href="qqmlengine.html" translate="no">QQmlEngine</a></span> <span class="operator">*</span>engine<span class="operator">,</span> <span class="type"><a href="qjsengine.html" translate="no">QJSEngine</a></span> <span class="operator">*</span>scriptEngine)
 {
     Q_UNUSED(engine)

     <span class="keyword">static</span> <span class="type">int</span> seedValue <span class="operator">=</span> <span class="number">5</span>;
     <span class="type"><a href="qjsvalue.html" translate="no">QJSValue</a></span> example <span class="operator">=</span> scriptEngine<span class="operator">-</span><span class="operator">&gt;</span>newObject();
     example<span class="operator">.</span>setProperty(<span class="string">&quot;someProperty&quot;</span><span class="operator">,</span> seedValue<span class="operator">+</span><span class="operator">+</span>);
     <span class="keyword">return</span> example;
 }

 <span class="comment">// Second, register the singleton type provider with QML by calling this function in an initialization function.</span>
 qmlRegisterSingletonType(<span class="string">&quot;Qt.example.qjsvalueApi&quot;</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="string">&quot;MyApi&quot;</span><span class="operator">,</span> example_qjsvalue_singletontype_provider);
</pre>
<p>Alternatively, you can use a C++11 lambda:</p>
<pre class="cpp" translate="no">
 qmlRegisterSingletonType(<span class="string">&quot;Qt.example.qjsvalueApi&quot;</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="string">&quot;MyApi&quot;</span><span class="operator">,</span> <span class="operator">[</span><span class="operator">]</span>(<span class="type"><a href="qqmlengine.html" translate="no">QQmlEngine</a></span> <span class="operator">*</span>engine<span class="operator">,</span> <span class="type"><a href="qjsengine.html" translate="no">QJSEngine</a></span> <span class="operator">*</span>scriptEngine) <span class="operator">-</span><span class="operator">&gt;</span> <span class="type"><a href="qjsvalue.html" translate="no">QJSValue</a></span> {
     Q_UNUSED(engine)

     <span class="keyword">static</span> <span class="type">int</span> seedValue <span class="operator">=</span> <span class="number">5</span>;
     <span class="type"><a href="qjsvalue.html" translate="no">QJSValue</a></span> example <span class="operator">=</span> scriptEngine<span class="operator">-</span><span class="operator">&gt;</span>newObject();
     example<span class="operator">.</span>setProperty(<span class="string">&quot;someProperty&quot;</span><span class="operator">,</span> seedValue<span class="operator">+</span><span class="operator">+</span>);
     <span class="keyword">return</span> example;
 });
</pre>
<p>In order to use the registered singleton type in QML, you must import the singleton type.</p>
<pre class="qml" translate="no">
 import QtQuick 2.0
 import Qt.example.qjsvalueApi 1.0 as ExampleApi
 <span class="type"><a href="../qtquick/qml-qtquick-item.html" translate="no">Item</a></span> {
     <span class="name">id</span>: <span class="name">root</span>
     property <span class="type"><a href="qml-int.html" translate="no">int</a></span> <span class="name">someValue</span>: <span class="name">ExampleApi</span>.<span class="name">MyApi</span>.<span class="name">someProperty</span>
 }
</pre>
<p><b>See also </b><a href="qqmlintegration-h-qtqml-proxy.html#QML_SINGLETON" translate="no">QML_SINGLETON</a> and <a href="qtqml-cppintegration-overview.html#choosing-the-correct-integration-method-between-c-and-qml">Choosing the Correct Integration Method Between C++ and QML</a>.</p>
<!-- @@@qmlRegisterSingletonType -->
<!-- $$$qmlRegisterSingletonType$$$qmlRegisterSingletonTypeconstchar*intintconstchar*std::function<QObject*(QQmlEngine*,QJSEngine*)> -->
<h3 class="fn" translate="no" id="qmlRegisterSingletonType-2">template &lt;typename T&gt; <span class="type">int</span> <span class="name">qmlRegisterSingletonType</span>(const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>, <span class="type">int</span> <i>versionMinor</i>, const <span class="type">char</span> *<i>typeName</i>, <span class="type">std::function</span>&lt;<span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span> *(<span class="type"><a href="qqmlengine.html" translate="no">QQmlEngine</a></span> *, <span class="type"><a href="qjsengine.html" translate="no">QJSEngine</a></span> *)&gt; <i>callback</i>)</h3>
<p>This function may be used to register a singleton type provider <i translate="no">callback</i> in a particular <i translate="no">uri</i> and <i translate="no">typeName</i> with a version specified in <i translate="no">versionMajor</i> and <i translate="no">versionMinor</i>.</p>
<p>Installing a singleton type into a uri allows developers to provide arbitrary functionality (methods and properties) to clients without requiring individual instances ot the type to be instantiated by the client.</p>
<p>A singleton type may be either a <a href="../qtcore/qobject.html" translate="no">QObject</a> or a <a href="qjsvalue.html" translate="no">QJSValue</a>. This function should be used to register a singleton type provider function which returns a <a href="../qtcore/qobject.html" translate="no">QObject</a> of the given type T as a singleton type.</p>
<p>A <a href="../qtcore/qobject.html" translate="no">QObject</a> singleton type may be referenced via the type name with which it was registered, and this typename may be used as the target in a <a href="qml-qtqml-connections.html" translate="no">Connections</a> type or otherwise used as any other type id would. One exception to this is that a <a href="../qtcore/qobject.html" translate="no">QObject</a> singleton type property may not be aliased.</p>
<p><b>NOTE:</b> A <a href="../qtcore/qobject.html" translate="no">QObject</a> singleton type instance returned from a singleton type provider is owned by the QML engine unless the object has explicit QQmlEngine::CppOwnership flag set.</p>
<p>Usage:</p>
<pre class="cpp" translate="no">
 <span class="comment">// First, define your QObject which provides the functionality.</span>
 <span class="keyword">class</span> SingletonTypeExample : <span class="keyword">public</span> <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span>
 {
     Q_OBJECT
     Q_PROPERTY (<span class="type">int</span> someProperty READ someProperty WRITE setSomeProperty NOTIFY somePropertyChanged)

 <span class="keyword">public</span>:
     SingletonTypeExample(<span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span> <span class="operator">*</span>parent <span class="operator">=</span> nullptr)
         : <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span>(parent)<span class="operator">,</span> m_someProperty(<span class="number">0</span>)
     {
     }

     <span class="operator">~</span>SingletonTypeExample() {}

     Q_INVOKABLE <span class="type">int</span> doSomething() { setSomeProperty(<span class="number">5</span>); <span class="keyword">return</span> m_someProperty; }

     <span class="type">int</span> someProperty() <span class="keyword">const</span> { <span class="keyword">return</span> m_someProperty; }
     <span class="type">void</span> setSomeProperty(<span class="type">int</span> val) { m_someProperty <span class="operator">=</span> val; <span class="keyword">emit</span> somePropertyChanged(val); }

 <span class="keyword">signals</span>:
     <span class="type">void</span> somePropertyChanged(<span class="type">int</span> newValue);

 <span class="keyword">private</span>:
     <span class="type">int</span> m_someProperty;
 };

 <span class="comment">// Second, define the singleton type provider function (callback).</span>
 <span class="keyword">static</span> <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span> <span class="operator">*</span>example_qobject_singletontype_provider(<span class="type"><a href="qqmlengine.html" translate="no">QQmlEngine</a></span> <span class="operator">*</span>engine<span class="operator">,</span> <span class="type"><a href="qjsengine.html" translate="no">QJSEngine</a></span> <span class="operator">*</span>scriptEngine)
 {
     Q_UNUSED(engine)
     Q_UNUSED(scriptEngine)

     SingletonTypeExample <span class="operator">*</span>example <span class="operator">=</span> <span class="keyword">new</span> SingletonTypeExample();
     <span class="keyword">return</span> example;
 }

 <span class="comment">// Third, register the singleton type provider with QML by calling this function in an initialization function.</span>
 qmlRegisterSingletonType<span class="operator">&lt;</span>SingletonTypeExample<span class="operator">&gt;</span>(<span class="string">&quot;Qt.example.qobjectSingleton&quot;</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="string">&quot;MyApi&quot;</span><span class="operator">,</span> example_qobject_singletontype_provider);
</pre>
<p>Alternatively, you can use a C++11 lambda:</p>
<pre class="cpp" translate="no">
 qmlRegisterSingletonType<span class="operator">&lt;</span>SingletonTypeExample<span class="operator">&gt;</span>(<span class="string">&quot;Qt.example.qobjectSingleton&quot;</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="string">&quot;MyApi&quot;</span><span class="operator">,</span> <span class="operator">[</span><span class="operator">]</span>(<span class="type"><a href="qqmlengine.html" translate="no">QQmlEngine</a></span> <span class="operator">*</span>engine<span class="operator">,</span> <span class="type"><a href="qjsengine.html" translate="no">QJSEngine</a></span> <span class="operator">*</span>scriptEngine) <span class="operator">-</span><span class="operator">&gt;</span> <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span> <span class="operator">*</span> {
     Q_UNUSED(engine)
     Q_UNUSED(scriptEngine)

     SingletonTypeExample <span class="operator">*</span>example <span class="operator">=</span> <span class="keyword">new</span> SingletonTypeExample();
     <span class="keyword">return</span> example;
 });
</pre>
<p>In order to use the registered singleton type in QML, you must import the singleton type.</p>
<pre class="qml" translate="no">
 import QtQuick 2.0
 import Qt.example.qobjectSingleton 1.0
 <span class="type"><a href="../qtquick/qml-qtquick-item.html" translate="no">Item</a></span> {
     <span class="name">id</span>: <span class="name">root</span>
     property <span class="type"><a href="qml-int.html" translate="no">int</a></span> <span class="name">someValue</span>: <span class="name">MyApi</span>.<span class="name">someProperty</span>

     <span class="name">Component</span>.onCompleted: {
         <span class="name">someValue</span> <span class="operator">=</span> <span class="name">MyApi</span>.<span class="name">doSomething</span>()
     }
 }
</pre>
<p><b>See also </b><a href="qqmlintegration-h-qtqml-proxy.html#QML_SINGLETON" translate="no">QML_SINGLETON</a> and <a href="qtqml-cppintegration-overview.html#choosing-the-correct-integration-method-between-c-and-qml">Choosing the Correct Integration Method Between C++ and QML</a>.</p>
<!-- @@@qmlRegisterSingletonType -->
<!-- $$$qmlRegisterType[overload1]$$$qmlRegisterTypeconstchar*intintconstchar* -->
<h3 class="fn" translate="no" id="qmlRegisterType">template &lt;typename T&gt; <span class="type">int</span> <span class="name">qmlRegisterType</span>(const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>, <span class="type">int</span> <i>versionMinor</i>, const <span class="type">char</span> *<i>qmlName</i>)</h3>
<p>This template function registers the C++ type in the QML system with the name <i translate="no">qmlName</i>, in the library imported from <i translate="no">uri</i> having the version number composed from <i translate="no">versionMajor</i> and <i translate="no">versionMinor</i>.</p>
<p>Returns the QML type id.</p>
<p>There are two forms of this template function:</p>
<pre class="cpp" translate="no">
 <span class="keyword">template</span><span class="operator">&lt;</span><span class="keyword">typename</span> T<span class="operator">&gt;</span>
 <span class="type">int</span> qmlRegisterType(<span class="keyword">const</span> <span class="type">char</span> <span class="operator">*</span>uri<span class="operator">,</span> <span class="type">int</span> versionMajor<span class="operator">,</span> <span class="type">int</span> versionMinor<span class="operator">,</span> <span class="keyword">const</span> <span class="type">char</span> <span class="operator">*</span>qmlName);

 <span class="keyword">template</span><span class="operator">&lt;</span><span class="keyword">typename</span> T<span class="operator">,</span> <span class="type">int</span> metaObjectRevision<span class="operator">&gt;</span>
 <span class="type">int</span> qmlRegisterType(<span class="keyword">const</span> <span class="type">char</span> <span class="operator">*</span>uri<span class="operator">,</span> <span class="type">int</span> versionMajor<span class="operator">,</span> <span class="type">int</span> versionMinor<span class="operator">,</span> <span class="keyword">const</span> <span class="type">char</span> <span class="operator">*</span>qmlName);
</pre>
<p>The former is the standard form which registers the type <i>T</i> as a new type. The latter allows a particular revision of a class to be registered in a specified version (see <a href="qtqml-cppintegration-definetypes.html#type-revisions-and-versions">Type Revisions and Versions</a>).</p>
<p>For example, this registers a C++ class <code translate="no">MySliderItem</code> as a QML type named <code translate="no">Slider</code> for version 1.0 of a type namespace called &quot;com.mycompany.qmlcomponents&quot;:</p>
<pre class="cpp" translate="no">
 qmlRegisterType<span class="operator">&lt;</span>MySliderItem<span class="operator">&gt;</span>(<span class="string">&quot;com.mycompany.qmlcomponents&quot;</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="string">&quot;Slider&quot;</span>);
</pre>
<p>Once this is registered, the type can be used in QML by importing the specified type namespace and version number:</p>
<pre class="qml" translate="no">
 import com.mycompany.qmlcomponents 1.0

 <span class="type"><a href="../qtquickcontrols/qml-qtquick-controls-slider.html" translate="no">Slider</a></span> {
     <span class="comment">// ...</span>
 }
</pre>
<p>Note that it's perfectly reasonable for a library to register types to older versions than the actual version of the library. Indeed, it is normal for the new library to allow QML written to previous versions to continue to work, even if more advanced versions of some of its types are available.</p>
<p><b>See also </b><a href="qqmlintegration-h-qtqml-proxy.html#QML_ELEMENT" translate="no">QML_ELEMENT</a>, <a href="qqmlintegration-h-qtqml-proxy.html#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>(), and <a href="qtqml-cppintegration-overview.html#choosing-the-correct-integration-method-between-c-and-qml">Choosing the Correct Integration Method Between C++ and QML</a>.</p>
<!-- @@@qmlRegisterType -->
<!-- $$$qmlRegisterType$$$qmlRegisterTypeconstQUrl&constchar*intintconstchar* -->
<h3 class="fn" translate="no" id="qmlRegisterType-1"><span class="type">int</span> <span class="name">qmlRegisterType</span>(const <span class="type"><a href="../qtcore/qurl.html" translate="no">QUrl</a></span> &amp;<i>url</i>, const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>, <span class="type">int</span> <i>versionMinor</i>, const <span class="type">char</span> *<i>qmlName</i>)</h3>
<p>This function registers a type in the QML system with the name <i translate="no">qmlName</i>, in the library imported from <i translate="no">uri</i> having the version number composed from <i translate="no">versionMajor</i> and <i translate="no">versionMinor</i>. The type is defined by the QML file located at <i translate="no">url</i>. The url must be an absolute URL, i.e. url.isRelative() == false.</p>
<p>Normally QML files can be loaded as types directly from other QML files, or using a qmldir file. This function allows registration of files to types from C++ code, such as when the type mapping needs to be procedurally determined at startup.</p>
<p>Returns -1 if the registration was not successful.</p>
<!-- @@@qmlRegisterType -->
<!-- $$$qmlRegisterTypeNotAvailable[overload1]$$$qmlRegisterTypeNotAvailableconstchar*intintconstchar*constQString& -->
<h3 class="fn" translate="no" id="qmlRegisterTypeNotAvailable"><span class="type">int</span> <span class="name">qmlRegisterTypeNotAvailable</span>(const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>, <span class="type">int</span> <i>versionMinor</i>, const <span class="type">char</span> *<i>qmlName</i>, const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>message</i>)</h3>
<p>This function registers a type in the QML system with the name <i translate="no">qmlName</i>, in the type namespace imported from <i translate="no">uri</i> having the version number composed from <i translate="no">versionMajor</i> and <i translate="no">versionMinor</i>, but any attempt to instantiate the type will produce the given error <i translate="no">message</i>.</p>
<p>Normally, the types exported by a plugin should be fixed. However, if a C++ type is not available, you should at least &quot;reserve&quot; the QML type name, and give the user of the unavailable type a meaningful error message.</p>
<p>Returns the QML type id.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="preprocessor">#ifdef NO_GAMES_ALLOWED</span>
 qmlRegisterTypeNotAvailable(<span class="string">&quot;MinehuntCore&quot;</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="string">&quot;Game&quot;</span><span class="operator">,</span> <span class="string">&quot;Get back to work, slacker!&quot;</span>);
 <span class="preprocessor">#else</span>
 qmlRegisterType<span class="operator">&lt;</span>MinehuntGame<span class="operator">&gt;</span>(<span class="string">&quot;MinehuntCore&quot;</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="string">&quot;Game&quot;</span>);
 <span class="preprocessor">#endif</span>
</pre>
<p>This will cause any QML which imports the &quot;MinehuntCore&quot; type namespace and attempts to use the type to produce an error message:</p>
<pre class="cpp" translate="no">
 fun<span class="operator">.</span>qml: Get back to work<span class="operator">,</span> slacker<span class="operator">!</span>
    Game {
    <span class="operator">^</span>
</pre>
<p>Without this, a generic &quot;Game is not a type&quot; message would be given.</p>
<p><b>See also </b><a href="qqmlintegration-h-qtqml-proxy.html#QML_UNAVAILABLE" translate="no">QML_UNAVAILABLE</a>, <a href="qqml-h-qtqml-proxy.html#qmlRegisterUncreatableType" translate="no">qmlRegisterUncreatableType</a>(), and <a href="qtqml-cppintegration-overview.html#choosing-the-correct-integration-method-between-c-and-qml">Choosing the Correct Integration Method Between C++ and QML</a>.</p>
<!-- @@@qmlRegisterTypeNotAvailable -->
<!-- $$$qmlRegisterUncreatableMetaObject[overload1]$$$qmlRegisterUncreatableMetaObjectconstQMetaObject&constchar*intintconstchar*constQString& -->
<h3 class="fn" translate="no" id="qmlRegisterUncreatableMetaObject"><span class="type">int</span> <span class="name">qmlRegisterUncreatableMetaObject</span>(const <span class="type"><a href="../qtcore/qmetaobject.html" translate="no">QMetaObject</a></span> &amp;<i>staticMetaObject</i>, const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>, <span class="type">int</span> <i>versionMinor</i>, const <span class="type">char</span> *<i>qmlName</i>, const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>reason</i>)</h3>
<p>This function registers the <i translate="no">staticMetaObject</i> and its extension in the QML system with the name <i translate="no">qmlName</i> in the library imported from <i translate="no">uri</i> having version number composed from <i translate="no">versionMajor</i> and <i translate="no">versionMinor</i>.</p>
<p>An instance of the meta object cannot be created. An error message with the given <i translate="no">reason</i> is printed if the user attempts to create it.</p>
<p>This function is useful for registering <a href="../qtcore/qobject.html#Q_NAMESPACE" translate="no">Q_NAMESPACE</a> namespaces.</p>
<p>Returns the QML type id.</p>
<p>For example:</p>
<pre class="cpp" translate="no">
 <span class="keyword">namespace</span> MyNamespace {
   Q_NAMESPACE
   <span class="keyword">enum</span> MyEnum {
       Key1<span class="operator">,</span>
       Key2<span class="operator">,</span>
   };
   Q_ENUM_NS(MyEnum)
 }

 <span class="comment">//...</span>
 qmlRegisterUncreatableMetaObject(MyNamespace<span class="operator">::</span>staticMetaObject<span class="operator">,</span> <span class="string">&quot;io.qt&quot;</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="string">&quot;MyNamespace&quot;</span><span class="operator">,</span> <span class="string">&quot;Access to enums &amp; flags only&quot;</span>);
</pre>
<p>On the QML side, you can now use the registered enums:</p>
<pre class="cpp" translate="no">
 Component<span class="operator">.</span>onCompleted: console<span class="operator">.</span>log(MyNamespace<span class="operator">.</span>Key2)
</pre>
<p><b>See also </b><a href="qqmlintegration-h-qtqml-proxy.html#QML_ELEMENT" translate="no">QML_ELEMENT</a>, <a href="qqmlintegration-h-qtqml-proxy.html#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>(), and <a href="qqmlintegration-h-qtqml-proxy.html#QML_UNCREATABLE" translate="no">QML_UNCREATABLE</a>().</p>
<!-- @@@qmlRegisterUncreatableMetaObject -->
<!-- $$$qmlRegisterUncreatableType[overload1]$$$qmlRegisterUncreatableTypeconstchar*intintconstchar*constQString& -->
<h3 class="fn" translate="no" id="qmlRegisterUncreatableType">template &lt;typename T&gt; <span class="type">int</span> <span class="name">qmlRegisterUncreatableType</span>(const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>, <span class="type">int</span> <i>versionMinor</i>, const <span class="type">char</span> *<i>qmlName</i>, const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>message</i>)</h3>
<p>This template function registers the C++ type in the QML system with the name <i translate="no">qmlName</i>, in the library imported from <i translate="no">uri</i> having the version number composed from <i translate="no">versionMajor</i> and <i translate="no">versionMinor</i>.</p>
<p>While the type has a name and a type, it cannot be created, and the given error <i translate="no">message</i> will result if creation is attempted.</p>
<p>This is useful where the type is only intended for providing attached properties or enum values.</p>
<p>Returns the QML type id.</p>
<p><b>See also </b><a href="qqmlintegration-h-qtqml-proxy.html#QML_UNCREATABLE" translate="no">QML_UNCREATABLE</a>(), <a href="qqml-h-qtqml-proxy.html#qmlRegisterTypeNotAvailable" translate="no">qmlRegisterTypeNotAvailable</a>(), and <a href="qtqml-cppintegration-overview.html#choosing-the-correct-integration-method-between-c-and-qml">Choosing the Correct Integration Method Between C++ and QML</a>.</p>
<!-- @@@qmlRegisterUncreatableType -->
<!-- $$$qmlTypeId[overload1]$$$qmlTypeIdconstchar*intintconstchar* -->
<h3 class="fn" translate="no" id="qmlTypeId"><span class="type">int</span> <span class="name">qmlTypeId</span>(const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>, <span class="type">int</span> <i>versionMinor</i>, const <span class="type">char</span> *<i>qmlName</i>)</h3>
<p>Returns the QML type id of a type that was registered with the name <i translate="no">qmlName</i> in a particular <i translate="no">uri</i> and a version specified in <i translate="no">versionMajor</i> and <i translate="no">versionMinor</i>.</p>
<p>This function returns the same value as the QML type registration functions such as <a href="qqml-h-qtqml-proxy.html#qmlRegisterType" translate="no">qmlRegisterType</a>() and <a href="qqml-h-qtqml-proxy.html#qmlRegisterSingletonType" translate="no">qmlRegisterSingletonType</a>().</p>
<p>If <i translate="no">qmlName</i>, <i translate="no">uri</i> and <i translate="no">versionMajor</i> match a registered type, but the specified minor version in <i translate="no">versionMinor</i> is higher, then the id of the type with the closest minor version is returned.</p>
<p>Returns -1 if no matching type was found or one of the given parameters was invalid.</p>
<div class="admonition note">
<p><b>Note: </b>: qmlTypeId tries to make modules available, even if they were not accessed by any engine yet. This can introduce overhead the first time a module is accessed. Trying to find types from a module which does not exist always introduces this overhead.</p>
</div>
<p><b>See also </b><a href="qqmlintegration-h-qtqml-proxy.html#QML_ELEMENT" translate="no">QML_ELEMENT</a>, <a href="qqmlintegration-h-qtqml-proxy.html#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>, <a href="qqmlintegration-h-qtqml-proxy.html#QML_SINGLETON" translate="no">QML_SINGLETON</a>, <a href="qqml-h-qtqml-proxy.html#qmlRegisterType" translate="no">qmlRegisterType</a>(), and <a href="qqml-h-qtqml-proxy.html#qmlRegisterSingletonType" translate="no">qmlRegisterSingletonType</a>().</p>
<!-- @@@qmlTypeId -->
<!-- $$$qmlUnregisterModuleImport[overload1]$$$qmlUnregisterModuleImportconstchar*intconstchar*intint -->
<h3 class="fn" translate="no" id="qmlUnregisterModuleImport"><span class="type">void</span> <span class="name">qmlUnregisterModuleImport</span>(const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>moduleMajor</i>, const <span class="type">char</span> *<i>import</i>, <span class="type">int</span> <i>importMajor</i> = QQmlModuleImportLatest, <span class="type">int</span> <i>importMinor</i> = QQmlModuleImportLatest)</h3>
<p>Removes a module import previously registered with <a href="qqml-h-qtqml-proxy.html#qmlRegisterModuleImport" translate="no">qmlRegisterModuleImport</a>()</p>
<p>Calling this function makes sure that <i translate="no">import</i> of version <i translate="no">importMajor</i>.<i translate="no">importMinor</i> is not automatically imported anymore when <i translate="no">uri</i> of version <i translate="no">moduleMajor</i> is. The version resolution works the same way as with <a href="qqml-h-qtqml-proxy.html#qmlRegisterModuleImport" translate="no">qmlRegisterModuleImport</a>().</p>
<p><b>See also </b><a href="qqml-h-qtqml-proxy.html#qmlRegisterModuleImport" translate="no">qmlRegisterModuleImport</a>().</p>
<!-- @@@qmlUnregisterModuleImport -->
</div>
<div class="macros">
<h2>Macro Documentation</h2>
<!-- $$$QML_DECLARE_TYPE[overload1]$$$QML_DECLARE_TYPE -->
<h3 class="fn" translate="no" id="QML_DECLARE_TYPE"><span class="name">QML_DECLARE_TYPE</span></h3>
<p>Equivalent to <code translate="no">Q_DECLARE_METATYPE(TYPE *)</code> and <code translate="no">Q_DECLARE_METATYPE(QQmlListProperty&lt;TYPE&gt;)</code></p>
<!-- @@@QML_DECLARE_TYPE -->
<!-- $$$QML_DECLARE_TYPEINFO[overload1]$$$QML_DECLARE_TYPEINFO -->
<h3 class="fn" translate="no" id="QML_DECLARE_TYPEINFO"><span class="name">QML_DECLARE_TYPEINFO</span>(<i>Type</i>, <i>Flags</i>)</h3>
<p>Declares additional properties of the given <i translate="no">Type</i> as described by the specified <i translate="no">Flags</i>.</p>
<p>Current the only supported type info is <code translate="no">QML_HAS_ATTACHED_PROPERTIES</code> which declares that the <i translate="no">Type</i> supports <a href="qtqml-syntax-objectattributes.html#attached-properties-and-attached-signal-handlers">attached properties</a>. QML_DECLARE_TYPEINFO() is not necessary if <i translate="no">Type</i> contains the <a href="qqmlintegration-h-qtqml-proxy.html#QML_ATTACHED" translate="no">QML_ATTACHED</a> macro.</p>
<!-- @@@QML_DECLARE_TYPEINFO -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <abbr title="Copyright">&copy;</abbr> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
