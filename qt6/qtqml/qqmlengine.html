<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qqmlengine.cpp -->
  <meta name="description" content="The QQmlEngine class provides an environment for instantiating QML components.">
  <title>QQmlEngine Class | Qt Qml | Qt 6.9.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li>Qt 6.9</li>
<li><a href="qtqml-index.html">Qt Qml</a></li>
<li><a href="qtqml-module.html" translate="no">C++ Classes</a></li>
<li>QQmlEngine</li>
<li id="buildversion"><a href="qtqml-index.html">Qt 6.9.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#properties">Properties</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#public-slots">Public Slots</a></li>
<li class="level1"><a href="#signals">Signals</a></li>
<li class="level1"><a href="#static-public-members">Static Public Members</a></li>
<li class="level1"><a href="#reimplemented-protected-functions">Reimplemented Protected Functions</a></li>
<li class="level1"><a href="#related-non-members">Related Non-Members</a></li>
<li class="level1"><a href="#macros">Macros</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QQmlEngine Class</h1>
<!-- $$$QQmlEngine-brief -->
<p>The QQmlEngine class provides an environment for instantiating QML components. <a href="#details">More...</a></p>
<!-- @@@QQmlEngine -->
<div class="table"><table class="alignedsummary requisites" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign"> <code translate="no">#include &lt;QQmlEngine&gt;</code></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> <code translate="no">find_package(Qt6 REQUIRED COMPONENTS Qml)</code><br/>
<code translate="no">target_link_libraries(mytarget PRIVATE Qt6::Qml)</code></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> <code translate="no">QT += qml</code></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="qjsengine.html" translate="no">QJSEngine</a></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherited By:</td><td class="memItemRight bottomAlign"> <p><a href="qqmlapplicationengine.html" translate="no">QQmlApplicationEngine</a></p>
</td></tr>
</table></div>
<ul>
<li><a href="qqmlengine-members.html">List of all members, including inherited members</a></li>
<li><a href="qqmlengine-obsolete.html">Deprecated members</a></li>
</ul>
<h2 id="properties">Properties</h2>
<ul>
<li class="fn" translate="no"><b><a href="qqmlengine.html#offlineStoragePath-prop" translate="no">offlineStoragePath</a></b> : QString</li>
</ul>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#QQmlEngine" translate="no">QQmlEngine</a></b>(QObject *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#dtor.QQmlEngine" translate="no">~QQmlEngine</a></b>() override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#addImageProvider" translate="no">addImageProvider</a></b>(const QString &amp;<i>providerId</i>, QQmlImageProviderBase *<i>provider</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#addImportPath" translate="no">addImportPath</a></b>(const QString &amp;<i>path</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#addPluginPath" translate="no">addPluginPath</a></b>(const QString &amp;<i>path</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#addUrlInterceptor" translate="no">addUrlInterceptor</a></b>(QQmlAbstractUrlInterceptor *<i>urlInterceptor</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QUrl </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#baseUrl" translate="no">baseUrl</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#clearComponentCache" translate="no">clearComponentCache</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#clearSingletons" translate="no">clearSingletons</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQmlImageProviderBase *</td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#imageProvider" translate="no">imageProvider</a></b>(const QString &amp;<i>providerId</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QStringList </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#importPathList" translate="no">importPathList</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQmlIncubationController *</td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#incubationController" translate="no">incubationController</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QUrl </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#interceptUrl" translate="no">interceptUrl</a></b>(const QUrl &amp;<i>url</i>, QQmlAbstractUrlInterceptor::DataType <i>type</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#markCurrentFunctionAsTranslationBinding" translate="no">markCurrentFunctionAsTranslationBinding</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QNetworkAccessManager *</td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#networkAccessManager" translate="no">networkAccessManager</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQmlNetworkAccessManagerFactory *</td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#networkAccessManagerFactory" translate="no">networkAccessManagerFactory</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#offlineStorageDatabaseFilePath" translate="no">offlineStorageDatabaseFilePath</a></b>(const QString &amp;<i>databaseName</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#offlineStoragePath-prop" translate="no">offlineStoragePath</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#outputWarningsToStandardError" translate="no">outputWarningsToStandardError</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QStringList </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#pluginPathList" translate="no">pluginPathList</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#removeImageProvider" translate="no">removeImageProvider</a></b>(const QString &amp;<i>providerId</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#removeUrlInterceptor" translate="no">removeUrlInterceptor</a></b>(QQmlAbstractUrlInterceptor *<i>urlInterceptor</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQmlContext *</td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#rootContext" translate="no">rootContext</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#setBaseUrl" translate="no">setBaseUrl</a></b>(const QUrl &amp;<i>url</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#setImportPathList" translate="no">setImportPathList</a></b>(const QStringList &amp;<i>paths</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#setIncubationController" translate="no">setIncubationController</a></b>(QQmlIncubationController *<i>controller</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#setNetworkAccessManagerFactory" translate="no">setNetworkAccessManagerFactory</a></b>(QQmlNetworkAccessManagerFactory *<i>factory</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#offlineStoragePath-prop" translate="no">setOfflineStoragePath</a></b>(const QString &amp;<i>dir</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#setOutputWarningsToStandardError" translate="no">setOutputWarningsToStandardError</a></b>(bool <i>enabled</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#setPluginPathList" translate="no">setPluginPathList</a></b>(const QStringList &amp;<i>paths</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#singletonInstance" translate="no">singletonInstance</a></b>(int <i>qmlTypeId</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.5)</code> T </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#singletonInstance-1" translate="no">singletonInstance</a></b>(QAnyStringView <i>uri</i>, QAnyStringView <i>typeName</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#trimComponentCache" translate="no">trimComponentCache</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;QQmlAbstractUrlInterceptor *&gt; </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#urlInterceptors" translate="no">urlInterceptors</a></b>() const</td></tr>
</table></div>
<h2 id="public-slots">Public Slots</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#retranslate" translate="no">retranslate</a></b>()</td></tr>
</table></div>
<h2 id="signals">Signals</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#exit" translate="no">exit</a></b>(int <i>retCode</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.5)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#offlineStoragePathChanged" translate="no">offlineStoragePathChanged</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#quit" translate="no">quit</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#warnings" translate="no">warnings</a></b>(const QList&lt;QQmlError&gt; &amp;<i>warnings</i>)</td></tr>
</table></div>
<h2 id="static-public-members">Static Public Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> QQmlContext *</td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#contextForObject" translate="no">contextForObject</a></b>(const QObject *<i>object</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#setContextForObject" translate="no">setContextForObject</a></b>(QObject *<i>object</i>, QQmlContext *<i>context</i>)</td></tr>
</table></div>
<h2 id="reimplemented-protected-functions">Reimplemented Protected Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#event" translate="no">event</a></b>(QEvent *<i>e</i>) override</td></tr>
</table></div>
<h2 id="related-non-members">Related Non-Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> QQmlContext *</td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#qmlContext" translate="no">qmlContext</a></b>(const QObject *<i>object</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQmlEngine *</td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#qmlEngine" translate="no">qmlEngine</a></b>(const QObject *<i>object</i>)</td></tr>
</table></div>
<h2 id="macros">Macros</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#QML_NAMESPACE_EXTENDED" translate="no">QML_NAMESPACE_EXTENDED</a></b>(<i>EXTENSION_NAMESPACE</i>)</td></tr>
</table></div>
<!-- $$$QQmlEngine-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>A QQmlEngine is used to manage <a href="qqmlcomponent.html" translate="no">components</a> and objects created from them and execute their bindings and functions. QQmlEngine also inherits from <a href="qjsengine.html" translate="no">QJSEngine</a> which allows seamless integration between your QML components and JavaScript code.</p>
<p>Each QML component is instantiated in a <a href="qqmlcontext.html" translate="no">QQmlContext</a>. In QML, contexts are arranged hierarchically and this hierarchy is managed by the QQmlEngine. By default, components are instantiated in the <a href="qqmlengine.html#rootContext" translate="no">root context</a>.</p>
</div>
<p><b>See also </b><a href="qqmlcomponent.html" translate="no">QQmlComponent</a>, <a href="qqmlcontext.html" translate="no">QQmlContext</a>, <a href="qtqml-javascript-qmlglobalobject.html">QML Global Object</a>, and <a href="qqmlapplicationengine.html" translate="no">QQmlApplicationEngine</a>.</p>
<!-- @@@QQmlEngine -->
<div class="prop">
<h2>Property Documentation</h2>
<!-- $$$offlineStoragePath-prop$$$offlineStoragePath$$$setOfflineStoragePathconstQString&$$$offlineStoragePathChanged -->
<h3 class="fn" translate="no" id="offlineStoragePath-prop"><span class="name">offlineStoragePath</span> : <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span></h3>
<p>This property holds the directory for storing offline user data</p>
<p>Returns the directory where SQL and other offline storage is placed.</p>
<p>The SQL databases created with <code translate="no">openDatabaseSync()</code> are stored here.</p>
<p>The default is QML/OfflineStorage in the platform-standard user application data directory.</p>
<p>Note that the path may not currently exist on the filesystem, so callers wanting to <i>create</i> new files at this location should create it first - see <a href="../qtcore/qdir.html#mkpath" translate="no">QDir::mkpath</a>().</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> QString </td><td class="memItemRight bottomAlign"><span class="name"><b>offlineStoragePath</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setOfflineStoragePath</b></span>(const QString &amp;<i>dir</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qqmlengine.html#offlineStoragePathChanged" translate="no">offlineStoragePathChanged</a></b></span>()</td></tr>
</table></div>
<p><b>See also </b><a href="../qtquick/qtquick-localstorage-qmlmodule.html" translate="no">Qt Quick Local Storage QML Types</a>.</p>
<!-- @@@offlineStoragePath -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QQmlEngine[overload1]$$$QQmlEngineQObject* -->
<h3 class="fn" translate="no" id="QQmlEngine"><code class="details extra" translate="no">[explicit]</code> QQmlEngine::<span class="name">QQmlEngine</span>(<span class="type"><a href="../qtcore/qobject.html#QObject" translate="no">QObject</a></span> *<i>parent</i> = nullptr)</h3>
<p>Create a new QQmlEngine with the given <i translate="no">parent</i>.</p>
<!-- @@@QQmlEngine -->
<!-- $$$~QQmlEngine[overload1]$$$~QQmlEngine -->
<h3 class="fn" translate="no" id="dtor.QQmlEngine"><code class="details extra" translate="no">[override virtual noexcept]</code> QQmlEngine::<span class="name">~QQmlEngine</span>()</h3>
<p>Destroys the <a href="qqmlengine.html" translate="no">QQmlEngine</a>.</p>
<p>Any <a href="qqmlcontext.html" translate="no">QQmlContext</a>'s created on this engine will be invalidated, but not destroyed (unless they are parented to the <a href="qqmlengine.html" translate="no">QQmlEngine</a> object).</p>
<p>See ~<a href="qjsengine.html#QJSEngine" translate="no">QJSEngine</a>() for details on cleaning up the JS engine.</p>
<!-- @@@~QQmlEngine -->
<!-- $$$addImageProvider[overload1]$$$addImageProviderconstQString&QQmlImageProviderBase* -->
<h3 class="fn" translate="no" id="addImageProvider"><span class="type">void</span> QQmlEngine::<span class="name">addImageProvider</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>providerId</i>, <span class="type"><a href="qqmlimageproviderbase.html" translate="no">QQmlImageProviderBase</a></span> *<i>provider</i>)</h3>
<p>Sets the <i translate="no">provider</i> to use for images requested via the <i>image</i>: url scheme, with host <i translate="no">providerId</i>. The <a href="qqmlengine.html" translate="no">QQmlEngine</a> takes ownership of <i translate="no">provider</i>.</p>
<p>Image providers enable support for pixmap and threaded image requests. See the <a href="../qtquick/qquickimageprovider.html" translate="no">QQuickImageProvider</a> documentation for details on implementing and using image providers.</p>
<p>All required image providers should be added to the engine before any QML sources files are loaded.</p>
<p><b>See also </b><a href="qqmlengine.html#removeImageProvider" translate="no">removeImageProvider</a>(), <a href="../qtquick/qquickimageprovider.html" translate="no">QQuickImageProvider</a>, and <a href="qqmlimageproviderbase.html" translate="no">QQmlImageProviderBase</a>.</p>
<!-- @@@addImageProvider -->
<!-- $$$addImportPath[overload1]$$$addImportPathconstQString& -->
<h3 class="fn" translate="no" id="addImportPath"><span class="type">void</span> QQmlEngine::<span class="name">addImportPath</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>path</i>)</h3>
<p>Adds <i translate="no">path</i> as a directory where the engine searches for installed modules in a URL-based directory structure.</p>
<p>The <i translate="no">path</i> may be a local filesystem directory, a <a href="../qtcore/resources.html">Qt Resource</a> path (<code translate="no">:/imports</code>), a <a href="../qtcore/resources.html">Qt Resource</a> url (<code translate="no">qrc:/imports</code>) or a URL.</p>
<p>The <i translate="no">path</i> will be converted into canonical form before it is added to the import path list.</p>
<p>The newly added <i translate="no">path</i> will be first in the <a href="qqmlengine.html#importPathList" translate="no">importPathList</a>().</p>
<p><b>See also</b> <a href="qqmlengine.html#setImportPathList" translate="no">setImportPathList</a>(), <a href="qtqml-modules-topic.html">QML Modules</a>, and <a href="qtqml-syntax-imports.html#qml-import-path">QML Import Path</a></p>
<!-- @@@addImportPath -->
<!-- $$$addPluginPath[overload1]$$$addPluginPathconstQString& -->
<h3 class="fn" translate="no" id="addPluginPath"><span class="type">void</span> QQmlEngine::<span class="name">addPluginPath</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>path</i>)</h3>
<p>Adds <i translate="no">path</i> as a directory where the engine searches for native plugins for imported modules (referenced in the <code translate="no">qmldir</code> file).</p>
<p>By default, the list contains only <code translate="no">.</code>, i.e. the engine searches in the directory of the <code translate="no">qmldir</code> file itself.</p>
<p>The newly added <i translate="no">path</i> will be first in the <a href="qqmlengine.html#pluginPathList" translate="no">pluginPathList</a>().</p>
<p><b>See also </b><a href="qqmlengine.html#setPluginPathList" translate="no">setPluginPathList</a>().</p>
<!-- @@@addPluginPath -->
<!-- $$$addUrlInterceptor[overload1]$$$addUrlInterceptorQQmlAbstractUrlInterceptor* -->
<h3 class="fn" translate="no" id="addUrlInterceptor"><span class="type">void</span> QQmlEngine::<span class="name">addUrlInterceptor</span>(<span class="type"><a href="qqmlabstracturlinterceptor.html" translate="no">QQmlAbstractUrlInterceptor</a></span> *<i>urlInterceptor</i>)</h3>
<p>Adds a <i translate="no">urlInterceptor</i> to be used when resolving URLs in QML. This also applies to URLs used for loading script files and QML types. The URL interceptors should not be modifed while the engine is loading files, or URL selection may be inconsistent. Multiple URL interceptors, when given, will be called in the order they were added for each URL.</p>
<p><a href="qqmlengine.html" translate="no">QQmlEngine</a> does not take ownership of the interceptor and won't delete it.</p>
<!-- @@@addUrlInterceptor -->
<!-- $$$baseUrl[overload1]$$$baseUrl -->
<h3 class="fn" translate="no" id="baseUrl"><span class="type"><a href="../qtcore/qurl.html" translate="no">QUrl</a></span> QQmlEngine::<span class="name">baseUrl</span>() const</h3>
<p>Return the base URL for this engine. The base URL is only used to resolve components when a relative URL is passed to the <a href="qqmlcomponent.html" translate="no">QQmlComponent</a> constructor.</p>
<p>If a base URL has not been explicitly set, this method returns the application's current working directory.</p>
<p><b>See also </b><a href="qqmlengine.html#setBaseUrl" translate="no">setBaseUrl</a>().</p>
<!-- @@@baseUrl -->
<!-- $$$clearComponentCache[overload1]$$$clearComponentCache -->
<h3 class="fn" translate="no" id="clearComponentCache"><span class="type">void</span> QQmlEngine::<span class="name">clearComponentCache</span>()</h3>
<p>Clears the engine's internal component cache.</p>
<p>This function causes the property metadata of most components previously loaded by the engine to be destroyed. It does so by dropping unreferenced components from the engine's component cache. It does not drop components that are still referenced since that would almost certainly lead to crashes further down the line.</p>
<p>If no components are referenced, this function returns the engine to a state where it does not contain any loaded component data. This may be useful in order to reload a smaller subset of the previous component set, or to load a new version of a previously loaded component.</p>
<p>Once the component cache has been cleared, components must be loaded before any new objects can be created.</p>
<div class="admonition note">
<p><b>Note: </b>Any existing objects created from QML components retain their types, even if you clear the component cache. This includes singleton objects. If you create more objects from the same QML code after clearing the cache, the new objects will be of different types than the old ones. Assigning such a new object to a property of its declared type belonging to an object created before clearing the cache won't work.</p>
</div>
<p>As a general rule of thumb, make sure that no objects created from QML components are alive when you clear the component cache.</p>
<p><b>See also </b><a href="qqmlengine.html#trimComponentCache" translate="no">trimComponentCache</a>() and <a href="qqmlengine.html#clearSingletons" translate="no">clearSingletons</a>().</p>
<!-- @@@clearComponentCache -->
<!-- $$$clearSingletons[overload1]$$$clearSingletons -->
<h3 class="fn" translate="no" id="clearSingletons"><span class="type">void</span> QQmlEngine::<span class="name">clearSingletons</span>()</h3>
<p>Clears all singletons the engine owns.</p>
<p>This function drops all singleton instances, deleting any QObjects owned by the engine among them. This is useful to make sure that no QML-created objects are left before calling <a href="qqmlengine.html#clearComponentCache" translate="no">clearComponentCache</a>().</p>
<p>QML properties holding <a href="../qtcore/qobject.html" translate="no">QObject</a>-based singleton instances become null if the engine owns the singleton or retain their value if the engine doesn't own it. The singletons are not automatically re-created by accessing existing QML-created objects. Only when new components are instantiated, the singletons are re-created.</p>
<p><b>See also </b><a href="qqmlengine.html#clearComponentCache" translate="no">clearComponentCache</a>().</p>
<!-- @@@clearSingletons -->
<!-- $$$contextForObject[overload1]$$$contextForObjectconstQObject* -->
<h3 class="fn" translate="no" id="contextForObject"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qqmlcontext.html" translate="no">QQmlContext</a></span> *QQmlEngine::<span class="name">contextForObject</span>(const <span class="type"><a href="../qtcore/qobject.html#QObject" translate="no">QObject</a></span> *<i>object</i>)</h3>
<p>Returns the <a href="qqmlcontext.html" translate="no">QQmlContext</a> for the <i translate="no">object</i>, or nullptr if no context has been set.</p>
<p>When the <a href="qqmlengine.html" translate="no">QQmlEngine</a> instantiates a <a href="../qtcore/qobject.html" translate="no">QObject</a>, an internal context is assigned to it automatically. Such internal contexts are read-only. You cannot set context properties on them.</p>
<p><b>See also </b><a href="qqmlengine.html#setContextForObject" translate="no">setContextForObject</a>(), <a href="qqmlengine.html#qmlContext" translate="no">qmlContext</a>(), <a href="qqmlengine.html#qmlEngine" translate="no">qmlEngine</a>(), and <a href="qqmlcontext.html#setContextProperty" translate="no">QQmlContext::setContextProperty</a>().</p>
<!-- @@@contextForObject -->
<!-- $$$event[overload1]$$$eventQEvent* -->
<h3 class="fn" translate="no" id="event"><code class="details extra" translate="no">[override virtual protected]</code> <span class="type">bool</span> QQmlEngine::<span class="name">event</span>(<span class="type"><a href="../qtcore/qevent.html" translate="no">QEvent</a></span> *<i>e</i>)</h3>
<p>Reimplements: <a href="../qtcore/qobject.html#event" translate="no">QObject::event</a>(QEvent *e).</p>
<!-- @@@event -->
<!-- $$$exit[overload1]$$$exitint -->
<h3 class="fn" translate="no" id="exit"><code class="details extra" translate="no">[signal]</code> <span class="type">void</span> QQmlEngine::<span class="name">exit</span>(<span class="type">int</span> <i>retCode</i>)</h3>
<p>This signal is emitted when the QML loaded by the engine would like to exit from the event loop with the specified return code <i translate="no">retCode</i>.</p>
<p><b>See also </b><a href="qqmlengine.html#quit" translate="no">quit</a>().</p>
<!-- @@@exit -->
<!-- $$$imageProvider[overload1]$$$imageProviderconstQString& -->
<h3 class="fn" translate="no" id="imageProvider"><span class="type"><a href="qqmlimageproviderbase.html" translate="no">QQmlImageProviderBase</a></span> *QQmlEngine::<span class="name">imageProvider</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>providerId</i>) const</h3>
<p>Returns the image provider set for <i translate="no">providerId</i> if found; otherwise returns <code translate="no">nullptr</code>.</p>
<p><b>See also </b><a href="../qtquick/qquickimageprovider.html" translate="no">QQuickImageProvider</a>.</p>
<!-- @@@imageProvider -->
<!-- $$$importPathList[overload1]$$$importPathList -->
<h3 class="fn" translate="no" id="importPathList"><span class="type"><a href="../qtcore/qstringlist.html" translate="no">QStringList</a></span> QQmlEngine::<span class="name">importPathList</span>() const</h3>
<p>Returns the list of directories where the engine searches for installed modules in a URL-based directory structure.</p>
<p>For example, if <code translate="no">/opt/MyApp/lib/imports</code> is in the path, then QML that imports <code translate="no">com.mycompany.Feature</code> will cause the <a href="qqmlengine.html" translate="no">QQmlEngine</a> to look in <code translate="no">/opt/MyApp/lib/imports/com/mycompany/Feature/</code> for the components provided by that module. A <code translate="no">qmldir</code> file is required for defining the type version mapping and possibly QML extensions plugins.</p>
<p>By default, this list contains the paths mentioned in <a href="qtqml-syntax-imports.html#qml-import-path">QML Import Path</a>.</p>
<p><b>See also </b><a href="qqmlengine.html#addImportPath" translate="no">addImportPath</a>() and <a href="qqmlengine.html#setImportPathList" translate="no">setImportPathList</a>().</p>
<!-- @@@importPathList -->
<!-- $$$incubationController[overload1]$$$incubationController -->
<h3 class="fn" translate="no" id="incubationController"><span class="type"><a href="qqmlincubationcontroller.html" translate="no">QQmlIncubationController</a></span> *QQmlEngine::<span class="name">incubationController</span>() const</h3>
<p>Returns the currently set incubation controller, or 0 if no controller has been set.</p>
<p><b>See also </b><a href="qqmlengine.html#setIncubationController" translate="no">setIncubationController</a>().</p>
<!-- @@@incubationController -->
<!-- $$$interceptUrl[overload1]$$$interceptUrlconstQUrl&QQmlAbstractUrlInterceptor::DataType -->
<h3 class="fn" translate="no" id="interceptUrl"><span class="type"><a href="../qtcore/qurl.html" translate="no">QUrl</a></span> QQmlEngine::<span class="name">interceptUrl</span>(const <span class="type"><a href="../qtcore/qurl.html" translate="no">QUrl</a></span> &amp;<i>url</i>, <span class="type"><a href="qqmlabstracturlinterceptor.html#DataType-enum" translate="no">QQmlAbstractUrlInterceptor::DataType</a></span> <i>type</i>) const</h3>
<p>Run the current URL interceptors on the given <i translate="no">url</i> of the given <i translate="no">type</i> and return the result.</p>
<!-- @@@interceptUrl -->
<!-- $$$markCurrentFunctionAsTranslationBinding[overload1]$$$markCurrentFunctionAsTranslationBinding -->
<h3 class="fn" translate="no" id="markCurrentFunctionAsTranslationBinding"><code class="details extra" translate="no">[since 6.6]</code> <span class="type">void</span> QQmlEngine::<span class="name">markCurrentFunctionAsTranslationBinding</span>()</h3>
<p>If this method is called inside of a function that is part of a binding in QML, the binding will be treated as a translation binding.</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> I18nAwareClass : <span class="keyword">public</span> <span class="type"><a href="../qtcore/qobject.html#QObject" translate="no">QObject</a></span> {

   <span class="comment">//...</span>

    <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> text() <span class="keyword">const</span>
    {
         <span class="keyword">if</span> (<span class="keyword">auto</span> engine <span class="operator">=</span> qmlEngine(<span class="keyword">this</span>))
             engine<span class="operator">-</span><span class="operator">&gt;</span>markCurrentFunctionAsTranslationBinding();
         <span class="keyword">return</span> tr(<span class="string">&quot;Hello, world!&quot;</span>);
    }
 };
</pre>
<div class="admonition note">
<p><b>Note: </b>This function is mostly useful if you wish to provide your own alternative to the qsTr function. To ensure that properties exposed from C++ classes are updated on language changes, it is instead recommended to react to <code translate="no">LanguageChange</code> events. That is a more general mechanism which also works when the class is used in a non-QML context, and has slightly less overhead. However, using <code translate="no">markCurrentFunctionAsTranslationBinding</code> can be acceptable when the class is already closely tied to the QML engine. For more details, see Prepare for Dynamic Language Changes</p>
</div>
<p>This function was introduced in Qt 6.6.</p>
<p><b>See also </b><a href="qqmlengine.html#retranslate" translate="no">QQmlEngine::retranslate</a>.</p>
<!-- @@@markCurrentFunctionAsTranslationBinding -->
<!-- $$$networkAccessManager[overload1]$$$networkAccessManager -->
<h3 class="fn" translate="no" id="networkAccessManager"><span class="type"><a href="../qtnetwork/qnetworkaccessmanager.html" translate="no">QNetworkAccessManager</a></span> *QQmlEngine::<span class="name">networkAccessManager</span>() const</h3>
<p>Returns a common <a href="../qtnetwork/qnetworkaccessmanager.html" translate="no">QNetworkAccessManager</a> which can be used by any QML type instantiated by this engine.</p>
<p>If a <a href="qqmlnetworkaccessmanagerfactory.html" translate="no">QQmlNetworkAccessManagerFactory</a> has been set and a <a href="../qtnetwork/qnetworkaccessmanager.html" translate="no">QNetworkAccessManager</a> has not yet been created, the <a href="qqmlnetworkaccessmanagerfactory.html" translate="no">QQmlNetworkAccessManagerFactory</a> will be used to create the <a href="../qtnetwork/qnetworkaccessmanager.html" translate="no">QNetworkAccessManager</a>; otherwise the returned <a href="../qtnetwork/qnetworkaccessmanager.html" translate="no">QNetworkAccessManager</a> will have no proxy or cache set.</p>
<p><b>See also </b><a href="qqmlengine.html#setNetworkAccessManagerFactory" translate="no">setNetworkAccessManagerFactory</a>().</p>
<!-- @@@networkAccessManager -->
<!-- $$$networkAccessManagerFactory[overload1]$$$networkAccessManagerFactory -->
<h3 class="fn" translate="no" id="networkAccessManagerFactory"><span class="type"><a href="qqmlnetworkaccessmanagerfactory.html" translate="no">QQmlNetworkAccessManagerFactory</a></span> *QQmlEngine::<span class="name">networkAccessManagerFactory</span>() const</h3>
<p>Returns the current <a href="qqmlnetworkaccessmanagerfactory.html" translate="no">QQmlNetworkAccessManagerFactory</a>.</p>
<p><b>See also </b><a href="qqmlengine.html#setNetworkAccessManagerFactory" translate="no">setNetworkAccessManagerFactory</a>().</p>
<!-- @@@networkAccessManagerFactory -->
<!-- $$$offlineStorageDatabaseFilePath[overload1]$$$offlineStorageDatabaseFilePathconstQString& -->
<h3 class="fn" translate="no" id="offlineStorageDatabaseFilePath"><span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> QQmlEngine::<span class="name">offlineStorageDatabaseFilePath</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>databaseName</i>) const</h3>
<p>Returns the file path where a <a href="../qtquick/qtquick-localstorage-qmlmodule.html" translate="no">Local Storage</a> database with the identifier <i translate="no">databaseName</i> is (or would be) located.</p>
<p><b>See also </b><a href="../qtquick/qtquick-localstorage-qmlmodule.html#opendatabasesync" translate="no">LocalStorage.openDatabaseSync()</a>.</p>
<!-- @@@offlineStorageDatabaseFilePath -->
<!-- $$$offlineStoragePathChanged -->
<h3 class="fn" translate="no" id="offlineStoragePathChanged"><code class="details extra" translate="no">[signal, since 6.5]</code> <span class="type">void</span> QQmlEngine::<span class="name">offlineStoragePathChanged</span>()</h3>
<p>This signal is emitted when <a href="qqmlengine.html#offlineStoragePath-prop" translate="no">offlineStoragePath</a> changes.</p>
<div class="admonition note"><p><b>Note: </b>Notifier signal for property <a href="qqmlengine.html#offlineStoragePath-prop" translate="no">offlineStoragePath</a>. </p>
</div><p>This function was introduced in Qt 6.5.</p>
<!-- @@@offlineStoragePathChanged -->
<!-- $$$outputWarningsToStandardError[overload1]$$$outputWarningsToStandardError -->
<h3 class="fn" translate="no" id="outputWarningsToStandardError"><span class="type">bool</span> QQmlEngine::<span class="name">outputWarningsToStandardError</span>() const</h3>
<p>Returns true if warning messages will be output to stderr in addition to being emitted by the <a href="qqmlengine.html#warnings" translate="no">warnings</a>() signal, otherwise false.</p>
<p>The default value is true.</p>
<p><b>See also </b><a href="qqmlengine.html#setOutputWarningsToStandardError" translate="no">setOutputWarningsToStandardError</a>().</p>
<!-- @@@outputWarningsToStandardError -->
<!-- $$$pluginPathList[overload1]$$$pluginPathList -->
<h3 class="fn" translate="no" id="pluginPathList"><span class="type"><a href="../qtcore/qstringlist.html" translate="no">QStringList</a></span> QQmlEngine::<span class="name">pluginPathList</span>() const</h3>
<p>Returns the list of directories where the engine searches for native plugins for imported modules (referenced in the <code translate="no">qmldir</code> file).</p>
<p>By default, the list contains only <code translate="no">.</code>, i.e. the engine searches in the directory of the <code translate="no">qmldir</code> file itself.</p>
<p><b>See also </b><a href="qqmlengine.html#addPluginPath" translate="no">addPluginPath</a>() and <a href="qqmlengine.html#setPluginPathList" translate="no">setPluginPathList</a>().</p>
<!-- @@@pluginPathList -->
<!-- $$$quit[overload1]$$$quit -->
<h3 class="fn" translate="no" id="quit"><code class="details extra" translate="no">[signal]</code> <span class="type">void</span> QQmlEngine::<span class="name">quit</span>()</h3>
<p>This signal is emitted when the QML loaded by the engine would like to quit.</p>
<p><b>See also </b><a href="qqmlengine.html#exit" translate="no">exit</a>().</p>
<!-- @@@quit -->
<!-- $$$removeImageProvider[overload1]$$$removeImageProviderconstQString& -->
<h3 class="fn" translate="no" id="removeImageProvider"><span class="type">void</span> QQmlEngine::<span class="name">removeImageProvider</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>providerId</i>)</h3>
<p>Removes the image provider for <i translate="no">providerId</i>.</p>
<p><b>See also </b><a href="qqmlengine.html#addImageProvider" translate="no">addImageProvider</a>() and <a href="../qtquick/qquickimageprovider.html" translate="no">QQuickImageProvider</a>.</p>
<!-- @@@removeImageProvider -->
<!-- $$$removeUrlInterceptor[overload1]$$$removeUrlInterceptorQQmlAbstractUrlInterceptor* -->
<h3 class="fn" translate="no" id="removeUrlInterceptor"><span class="type">void</span> QQmlEngine::<span class="name">removeUrlInterceptor</span>(<span class="type"><a href="qqmlabstracturlinterceptor.html" translate="no">QQmlAbstractUrlInterceptor</a></span> *<i>urlInterceptor</i>)</h3>
<p>Remove a <i translate="no">urlInterceptor</i> that was previously added using <a href="qqmlengine.html#addUrlInterceptor" translate="no">addUrlInterceptor</a>. The URL interceptors should not be modifed while the engine is loading files, or URL selection may be inconsistent.</p>
<p>This does not delete the interceptor, but merely removes it from the engine. You can re-use it on the same or a different engine afterwards.</p>
<!-- @@@removeUrlInterceptor -->
<!-- $$$retranslate[overload1]$$$retranslate -->
<h3 class="fn" translate="no" id="retranslate"><code class="details extra" translate="no">[slot]</code> <span class="type">void</span> QQmlEngine::<span class="name">retranslate</span>()</h3>
<p>Refreshes all binding expressions that use strings marked for translation.</p>
<p>Call this function after you have installed a new translator with <a href="../qtcore/qcoreapplication.html#installTranslator" translate="no">QCoreApplication::installTranslator</a>, to ensure that your user-interface shows up-to-date translations.</p>
<!-- @@@retranslate -->
<!-- $$$rootContext[overload1]$$$rootContext -->
<h3 class="fn" translate="no" id="rootContext"><span class="type"><a href="qqmlcontext.html" translate="no">QQmlContext</a></span> *QQmlEngine::<span class="name">rootContext</span>() const</h3>
<p>Returns the engine's root context.</p>
<p>The root context is automatically created by the <a href="qqmlengine.html" translate="no">QQmlEngine</a>. Data that should be available to all QML component instances instantiated by the engine should be put in the root context.</p>
<p>Additional data that should only be available to a subset of component instances should be added to sub-contexts parented to the root context.</p>
<!-- @@@rootContext -->
<!-- $$$setBaseUrl[overload1]$$$setBaseUrlconstQUrl& -->
<h3 class="fn" translate="no" id="setBaseUrl"><span class="type">void</span> QQmlEngine::<span class="name">setBaseUrl</span>(const <span class="type"><a href="../qtcore/qurl.html" translate="no">QUrl</a></span> &amp;<i>url</i>)</h3>
<p>Set the base URL for this engine to <i translate="no">url</i>.</p>
<p><b>See also </b><a href="qqmlengine.html#baseUrl" translate="no">baseUrl</a>().</p>
<!-- @@@setBaseUrl -->
<!-- $$$setContextForObject[overload1]$$$setContextForObjectQObject*QQmlContext* -->
<h3 class="fn" translate="no" id="setContextForObject"><code class="details extra" translate="no">[static]</code> <span class="type">void</span> QQmlEngine::<span class="name">setContextForObject</span>(<span class="type"><a href="../qtcore/qobject.html#QObject" translate="no">QObject</a></span> *<i>object</i>, <span class="type"><a href="qqmlcontext.html" translate="no">QQmlContext</a></span> *<i>context</i>)</h3>
<p>Sets the <a href="qqmlcontext.html" translate="no">QQmlContext</a> for the <i translate="no">object</i> to <i translate="no">context</i>. If the <i translate="no">object</i> already has a context, a warning is output, but the context is not changed.</p>
<p>When the <a href="qqmlengine.html" translate="no">QQmlEngine</a> instantiates a <a href="../qtcore/qobject.html" translate="no">QObject</a>, the context is set automatically.</p>
<p><b>See also </b><a href="qqmlengine.html#contextForObject" translate="no">contextForObject</a>().</p>
<!-- @@@setContextForObject -->
<!-- $$$setImportPathList[overload1]$$$setImportPathListconstQStringList& -->
<h3 class="fn" translate="no" id="setImportPathList"><span class="type">void</span> QQmlEngine::<span class="name">setImportPathList</span>(const <span class="type"><a href="../qtcore/qstringlist.html" translate="no">QStringList</a></span> &amp;<i>paths</i>)</h3>
<p>Sets <i translate="no">paths</i> as the list of directories where the engine searches for installed modules in a URL-based directory structure.</p>
<p>By default, this list contains the paths mentioned in <a href="qtqml-syntax-imports.html#qml-import-path">QML Import Path</a>.</p>
<div class="admonition warning">
<p><b>Warning: </b>Calling setImportPathList does not preserve the default import paths.</p>
</div>
<p><b>See also </b><a href="qqmlengine.html#importPathList" translate="no">importPathList</a>() and <a href="qqmlengine.html#addImportPath" translate="no">addImportPath</a>().</p>
<!-- @@@setImportPathList -->
<!-- $$$setIncubationController[overload1]$$$setIncubationControllerQQmlIncubationController* -->
<h3 class="fn" translate="no" id="setIncubationController"><span class="type">void</span> QQmlEngine::<span class="name">setIncubationController</span>(<span class="type"><a href="qqmlincubationcontroller.html" translate="no">QQmlIncubationController</a></span> *<i>controller</i>)</h3>
<p>Sets the engine's incubation <i translate="no">controller</i>. The engine can only have one active controller and it does not take ownership of it.</p>
<p><b>See also </b><a href="qqmlengine.html#incubationController" translate="no">incubationController</a>().</p>
<!-- @@@setIncubationController -->
<!-- $$$setNetworkAccessManagerFactory[overload1]$$$setNetworkAccessManagerFactoryQQmlNetworkAccessManagerFactory* -->
<h3 class="fn" translate="no" id="setNetworkAccessManagerFactory"><span class="type">void</span> QQmlEngine::<span class="name">setNetworkAccessManagerFactory</span>(<span class="type"><a href="qqmlnetworkaccessmanagerfactory.html" translate="no">QQmlNetworkAccessManagerFactory</a></span> *<i>factory</i>)</h3>
<p>Sets the <i translate="no">factory</i> to use for creating <a href="../qtnetwork/qnetworkaccessmanager.html" translate="no">QNetworkAccessManager</a>(s).</p>
<p><a href="../qtnetwork/qnetworkaccessmanager.html" translate="no">QNetworkAccessManager</a> is used for all network access by QML. By implementing a factory it is possible to create custom <a href="../qtnetwork/qnetworkaccessmanager.html" translate="no">QNetworkAccessManager</a> with specialized caching, proxy and cookie support.</p>
<p>The factory must be set before executing the engine.</p>
<div class="admonition note">
<p><b>Note: </b><a href="qqmlengine.html" translate="no">QQmlEngine</a> does not take ownership of the factory.</p>
</div>
<p><b>See also </b><a href="qqmlengine.html#networkAccessManagerFactory" translate="no">networkAccessManagerFactory</a>().</p>
<!-- @@@setNetworkAccessManagerFactory -->
<!-- $$$setOutputWarningsToStandardError[overload1]$$$setOutputWarningsToStandardErrorbool -->
<h3 class="fn" translate="no" id="setOutputWarningsToStandardError"><span class="type">void</span> QQmlEngine::<span class="name">setOutputWarningsToStandardError</span>(<span class="type">bool</span> <i>enabled</i>)</h3>
<p>Set whether warning messages will be output to stderr to <i translate="no">enabled</i>.</p>
<p>If <i translate="no">enabled</i> is true, any warning messages generated by QML will be output to stderr and emitted by the <a href="qqmlengine.html#warnings" translate="no">warnings</a>() signal. If <i translate="no">enabled</i> is false, only the <a href="qqmlengine.html#warnings" translate="no">warnings</a>() signal will be emitted. This allows applications to handle warning output themselves.</p>
<p>The default value is true.</p>
<p><b>See also </b><a href="qqmlengine.html#outputWarningsToStandardError" translate="no">outputWarningsToStandardError</a>().</p>
<!-- @@@setOutputWarningsToStandardError -->
<!-- $$$setPluginPathList[overload1]$$$setPluginPathListconstQStringList& -->
<h3 class="fn" translate="no" id="setPluginPathList"><span class="type">void</span> QQmlEngine::<span class="name">setPluginPathList</span>(const <span class="type"><a href="../qtcore/qstringlist.html" translate="no">QStringList</a></span> &amp;<i>paths</i>)</h3>
<p>Sets the list of directories where the engine searches for native plugins for imported modules (referenced in the <code translate="no">qmldir</code> file) to <i translate="no">paths</i>.</p>
<p>By default, the list contains only <code translate="no">.</code>, i.e. the engine searches in the directory of the <code translate="no">qmldir</code> file itself.</p>
<p><b>See also </b><a href="qqmlengine.html#pluginPathList" translate="no">pluginPathList</a>() and <a href="qqmlengine.html#addPluginPath" translate="no">addPluginPath</a>().</p>
<!-- @@@setPluginPathList -->
<!-- $$$singletonInstance[overload1]$$$singletonInstanceint -->
<h3 class="fn" translate="no" id="singletonInstance">template &lt;typename T&gt; <span class="type">T</span> QQmlEngine::<span class="name">singletonInstance</span>(<span class="type">int</span> <i>qmlTypeId</i>)</h3>
<p>Returns the instance of a singleton type that was registered under <i translate="no">qmlTypeId</i>.</p>
<p>The template argument <i>T</i> may be either <a href="qjsvalue.html" translate="no">QJSValue</a> or a pointer to a <a href="../qtcore/qobject.html" translate="no">QObject</a>-derived type and depends on how the singleton was registered. If no instance of <i>T</i> has been created yet, it is created now. If <i translate="no">qmlTypeId</i> does not represent a valid singleton type, either a default constructed <a href="qjsvalue.html" translate="no">QJSValue</a> or a <code translate="no">nullptr</code> is returned.</p>
<p><a href="../qtcore/qobject.html" translate="no">QObject</a>* example:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> MySingleton : <span class="keyword">public</span> <span class="type"><a href="../qtcore/qobject.html#QObject" translate="no">QObject</a></span> {
     Q_OBJECT

     <span class="comment">// Register as default constructed singleton.</span>
     QML_ELEMENT
     QML_SINGLETON

     <span class="keyword">static</span> <span class="type">int</span> typeId;
     <span class="comment">// ...</span>
 };

     MySingleton::typeId = qmlTypeId(...);

     <span class="comment">// Retrieve as QObject*</span>
     <span class="type"><a href="qqmlengine.html#QQmlEngine" translate="no">QQmlEngine</a></span> engine;
     MySingleton<span class="operator">*</span> instance <span class="operator">=</span> engine<span class="operator">.</span>singletonInstance<span class="operator">&lt;</span>MySingleton<span class="operator">*</span><span class="operator">&gt;</span>(MySingleton<span class="operator">::</span>typeId);
</pre>
<p><a href="qjsvalue.html" translate="no">QJSValue</a> example:</p>
<pre class="cpp" translate="no">
     // Register with QJSValue callback
     int typeId = qmlRegisterSingletonType(...);

     <span class="comment">// Retrieve as QJSValue</span>
     <span class="type"><a href="qqmlengine.html#QQmlEngine" translate="no">QQmlEngine</a></span> engine;
     <span class="type"><a href="qjsvalue.html" translate="no">QJSValue</a></span> instance <span class="operator">=</span> engine<span class="operator">.</span>singletonInstance<span class="operator">&lt;</span><span class="type"><a href="qjsvalue.html" translate="no">QJSValue</a></span><span class="operator">&gt;</span>(typeId);
</pre>
<p>It is recommended to store the QML type id, e.g. as a static member in the singleton class. The lookup via <a href="qqml-h-qtqml-proxy.html#qmlTypeId" translate="no">qmlTypeId</a>() is costly.</p>
<p><b>See also </b><a href="qqmlintegration-h-qtqml-proxy.html#QML_SINGLETON" translate="no">QML_SINGLETON</a>, <a href="qqml-h-qtqml-proxy.html#qmlRegisterSingletonType" translate="no">qmlRegisterSingletonType</a>(), and <a href="qqml-h-qtqml-proxy.html#qmlTypeId" translate="no">qmlTypeId</a>().</p>
<!-- @@@singletonInstance -->
<!-- $$$singletonInstance$$$singletonInstanceQAnyStringViewQAnyStringView -->
<h3 class="fn" translate="no" id="singletonInstance-1"><code class="details extra" translate="no">[since 6.5]</code> template &lt;typename T&gt; <span class="type">T</span> QQmlEngine::<span class="name">singletonInstance</span>(<span class="type"><a href="../qtcore/qanystringview.html" translate="no">QAnyStringView</a></span> <i>uri</i>, <span class="type"><a href="../qtcore/qanystringview.html" translate="no">QAnyStringView</a></span> <i>typeName</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns the instance of a singleton type named <i translate="no">typeName</i> from the module specified by <i translate="no">uri</i>.</p>
<p>This method can be used as an alternative to calling <a href="qqml-h-qtqml-proxy.html#qmlTypeId" translate="no">qmlTypeId</a> followed by the id based overload of singletonInstance. This is convenient when one only needs to do a one time setup of a singleton; if repeated access to the singleton is required, caching its typeId will allow faster subsequent access via the <a href="qqmlengine.html#singletonInstance" translate="no">type-id based overload</a>.</p>
<p>The template argument <i>T</i> may be either <a href="qjsvalue.html" translate="no">QJSValue</a> or a pointer to a <a href="../qtcore/qobject.html" translate="no">QObject</a>-derived type and depends on how the singleton was registered. If no instance of <i>T</i> has been created yet, it is created now. If <i translate="no">typeName</i> does not represent a valid singleton type, either a default constructed <a href="qjsvalue.html" translate="no">QJSValue</a> or a <code translate="no">nullptr</code> is returned.</p>
<pre class="cpp" translate="no">
     <span class="type"><a href="qqmlengine.html#QQmlEngine" translate="no">QQmlEngine</a></span> engine;
     MySingleton <span class="operator">*</span>singleton <span class="operator">=</span> engine<span class="operator">.</span>singletonInstance<span class="operator">&lt;</span>MySingleton <span class="operator">*</span><span class="operator">&gt;</span>(<span class="string">&quot;mymodule&quot;</span><span class="operator">,</span> <span class="string">&quot;MySingleton&quot;</span>);
 <span class="comment">/
</pre>
<p>This function was introduced in Qt 6.5.</p>
<p><b>See also </b><a href="qqmlintegration-h-qtqml-proxy.html#QML_SINGLETON" translate="no">QML_SINGLETON</a>, <a href="qqml-h-qtqml-proxy.html#qmlRegisterSingletonType" translate="no">qmlRegisterSingletonType</a>(), and <a href="qqml-h-qtqml-proxy.html#qmlTypeId" translate="no">qmlTypeId</a>().</p>
<!-- @@@singletonInstance -->
<!-- $$$trimComponentCache[overload1]$$$trimComponentCache -->
<h3 class="fn" translate="no" id="trimComponentCache"><span class="type">void</span> QQmlEngine::<span class="name">trimComponentCache</span>()</h3>
<p>Trims the engine's internal component cache.</p>
<p>This function causes the property metadata of any loaded components which are not currently in use to be destroyed.</p>
<p>A component is considered to be in use if there are any extant instances of the component itself, any instances of other components that use the component, or any objects instantiated by any of those components.</p>
<p><b>See also </b><a href="qqmlengine.html#clearComponentCache" translate="no">clearComponentCache</a>().</p>
<!-- @@@trimComponentCache -->
<!-- $$$urlInterceptors[overload1]$$$urlInterceptors -->
<h3 class="fn" translate="no" id="urlInterceptors"><span class="type"><a href="../qtcore/qlist.html" translate="no">QList</a></span>&lt;<span class="type"><a href="qqmlabstracturlinterceptor.html" translate="no">QQmlAbstractUrlInterceptor</a></span> *&gt; QQmlEngine::<span class="name">urlInterceptors</span>() const</h3>
<p>Returns the list of currently active URL interceptors.</p>
<!-- @@@urlInterceptors -->
<!-- $$$warnings[overload1]$$$warningsconstQList<QQmlError>& -->
<h3 class="fn" translate="no" id="warnings"><code class="details extra" translate="no">[signal]</code> <span class="type">void</span> QQmlEngine::<span class="name">warnings</span>(const <span class="type"><a href="../qtcore/qlist.html" translate="no">QList</a></span>&lt;<span class="type"><a href="qqmlerror.html" translate="no">QQmlError</a></span>&gt; &amp;<i>warnings</i>)</h3>
<p>This signal is emitted when <i translate="no">warnings</i> messages are generated by QML.</p>
<!-- @@@warnings -->
</div>
<div class="relnonmem">
<h2>Related Non-Members</h2>
<!-- $$$qmlContext[overload1]$$$qmlContextconstQObject* -->
<h3 class="fn" translate="no" id="qmlContext"><span class="type"><a href="qqmlcontext.html" translate="no">QQmlContext</a></span> *<span class="name">qmlContext</span>(const <span class="type"><a href="../qtcore/qobject.html#QObject" translate="no">QObject</a></span> *<i>object</i>)</h3>
<p>Returns the <a href="qqmlcontext.html" translate="no">QQmlContext</a> associated with <i translate="no">object</i>, if any. This is equivalent to <a href="qqmlengine.html#contextForObject" translate="no">QQmlEngine::contextForObject</a>(object).</p>
<div class="admonition note">
<p><b>Note: </b>Add <code translate="no">#include &lt;QtQml&gt;</code> to use this function.</p>
</div>
<p><b>See also </b><a href="qqmlengine.html#contextForObject" translate="no">contextForObject</a>() and <a href="qqmlengine.html#qmlEngine" translate="no">qmlEngine</a>().</p>
<!-- @@@qmlContext -->
<!-- $$$qmlEngine[overload1]$$$qmlEngineconstQObject* -->
<h3 class="fn" translate="no" id="qmlEngine"><span class="type"><a href="qqmlengine.html#QQmlEngine" translate="no">QQmlEngine</a></span> *<span class="name">qmlEngine</span>(const <span class="type"><a href="../qtcore/qobject.html#QObject" translate="no">QObject</a></span> *<i>object</i>)</h3>
<p>Returns the <a href="qqmlengine.html" translate="no">QQmlEngine</a> associated with <i translate="no">object</i>, if any. This is equivalent to <a href="qqmlengine.html#contextForObject" translate="no">QQmlEngine::contextForObject</a>(object)-&gt;engine(), but more efficient.</p>
<div class="admonition note">
<p><b>Note: </b>Add <code translate="no">#include &lt;QtQml&gt;</code> to use this function.</p>
</div>
<p><b>See also </b><a href="qqmlengine.html#contextForObject" translate="no">contextForObject</a>() and <a href="qqmlengine.html#qmlContext" translate="no">qmlContext</a>().</p>
<!-- @@@qmlEngine -->
</div>
<div class="macros">
<h2>Macro Documentation</h2>
<!-- $$$QML_NAMESPACE_EXTENDED[overload1]$$$QML_NAMESPACE_EXTENDED -->
<h3 class="fn" translate="no" id="QML_NAMESPACE_EXTENDED"><span class="name">QML_NAMESPACE_EXTENDED</span>(<i>EXTENSION_NAMESPACE</i>)</h3>
<p>Behaves the same way as <a href="qqmlintegration-h-qtqml-proxy.html#QML_EXTENDED_NAMESPACE" translate="no">QML_EXTENDED_NAMESPACE</a> with the distinction that what is being extended is a namespace and not a type.</p>
<p>Declares that the enclosing <b>namespace</b> uses <i translate="no">EXTENSION_NAMESPACE</i> as an extension to provide further enumerations in QML. This takes effect if the extended namespace is exposed to QML using a <a href="qqmlintegration-h-qtqml-proxy.html#QML_ELEMENT" translate="no">QML_ELEMENT</a> or <a href="qqmlintegration-h-qtqml-proxy.html#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>() macro. The enumerations need to be exposed to the metaobject system for this to work.</p>
<p>For example, in the following C++ code,</p>
<pre class="cpp" translate="no">
 <span class="keyword">namespace</span> NS2 {
     Q_NAMESPACE

     <span class="keyword">enum</span> <span class="keyword">class</span> E2 { D <span class="operator">=</span> <span class="number">3</span><span class="operator">,</span> E<span class="operator">,</span> F };
     Q_ENUM_NS(E2)
 }

 <span class="keyword">namespace</span> NS1 {
     Q_NAMESPACE
     QML_ELEMENT

     <span class="keyword">enum</span> <span class="keyword">class</span> E1 { A<span class="operator">,</span> B<span class="operator">,</span> C };
     Q_ENUM_NS(E1)

     <span class="comment">// Extends NS1 with NS2</span>
     QML_NAMESPACE_EXTENDED(NS2)
 }
</pre>
<p>the namespace <code translate="no">NS1</code> is extended with <code translate="no">NS2</code> and the <code translate="no">E2</code> enum becomes available within <code translate="no">NS1</code> from QML.</p>
<pre class="qml" translate="no">
 <span class="type"><a href="../qtquick/qml-qtquick-item.html" translate="no">Item</a></span> {
     <span class="name">Component</span>.onCompleted: <span class="name">console</span>.<span class="name">log</span>(<span class="name">NS1</span>.<span class="name">E1</span>.<span class="name">A</span>, <span class="name">NS1</span>.<span class="name">E2</span>.<span class="name">D</span>)
 }
</pre>
<div class="admonition note">
<p><b>Note: </b><i translate="no">EXTENSION_NAMESPACE</i> can also be a <a href="../qtcore/qobject.html" translate="no">QObject</a> or QGadget; in that case - and in contrast to <a href="qqmlintegration-h-qtqml-proxy.html#QML_EXTENDED" translate="no">QML_EXTENDED</a>, which also exposes methods and properties - only its enumerations are exposed.</p>
</div>
<div class="admonition note">
<p><b>Note: </b><i translate="no">EXTENSION_NAMESPACE</i> must have a metaobject; i.e. it must either be a namespace which contains the <a href="../qtcore/qobject.html#Q_NAMESPACE" translate="no">Q_NAMESPACE</a> macro or a <a href="../qtcore/qobject.html" translate="no">QObject</a>/QGadget.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The class name needs to be fully qualified, even if you're already inside the namespace.</p>
</div>
<p><b>See also </b><a href="qqmlintegration-h-qtqml-proxy.html#QML_EXTENDED_NAMESPACE" translate="no">QML_EXTENDED_NAMESPACE</a>(), <a href="qqmlintegration-h-qtqml-proxy.html#QML_ELEMENT" translate="no">QML_ELEMENT</a>, <a href="qqmlintegration-h-qtqml-proxy.html#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>(), <a href="qqmlintegration-h-qtqml-proxy.html#QML_EXTENDED" translate="no">QML_EXTENDED</a>(), <a href="qtqml-cppintegration-definetypes.html#registering-extension-objects">Registering Extension Objects</a>, <a href="../qtcore/qobject.html#Q_ENUM" translate="no">Q_ENUM</a>, and <a href="../qtcore/qobject.html#Q_ENUM_NS" translate="no">Q_ENUM_NS</a>.</p>
<!-- @@@QML_NAMESPACE_EXTENDED -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <abbr title="Copyright">&copy;</abbr> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
