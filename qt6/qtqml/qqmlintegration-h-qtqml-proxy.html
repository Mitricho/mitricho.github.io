<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>qqmlintegration.h Proxy Page | Qt Qml | Qt 6.9.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li>Qt 6.9</li>
<li><a href="qtqml-index.html">Qt Qml</a></li>
<li>qqmlintegration.h Proxy Page</li>
<li id="buildversion"><a href="qtqml-index.html">Qt 6.9.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<h1 class="title">qqmlintegration.h Proxy Page</h1>
<h2 id="macros">Macros</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qqmlintegration-h-qtqml-proxy.html#QML_ADDED_IN_VERSION" translate="no">QML_ADDED_IN_VERSION</a></b>(<i>MAJOR</i>, <i>MINOR</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qqmlintegration-h-qtqml-proxy.html#QML_ANONYMOUS" translate="no">QML_ANONYMOUS</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qqmlintegration-h-qtqml-proxy.html#QML_ATTACHED" translate="no">QML_ATTACHED</a></b>(<i>ATTACHED_TYPE</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.5)</code> </td><td class="memItemRight bottomAlign"><b><a href="qqmlintegration-h-qtqml-proxy.html#QML_CONSTRUCTIBLE_VALUE" translate="no">QML_CONSTRUCTIBLE_VALUE</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qqmlintegration-h-qtqml-proxy.html#QML_ELEMENT" translate="no">QML_ELEMENT</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qqmlintegration-h-qtqml-proxy.html#QML_EXTENDED" translate="no">QML_EXTENDED</a></b>(<i>EXTENDED_TYPE</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qqmlintegration-h-qtqml-proxy.html#QML_EXTENDED_NAMESPACE" translate="no">QML_EXTENDED_NAMESPACE</a></b>(<i>EXTENSION_NAMESPACE</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qqmlintegration-h-qtqml-proxy.html#QML_EXTRA_VERSION" translate="no">QML_EXTRA_VERSION</a></b>(<i>MAJOR</i>, <i>MINOR</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qqmlintegration-h-qtqml-proxy.html#QML_FOREIGN" translate="no">QML_FOREIGN</a></b>(<i>FOREIGN_TYPE</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qqmlintegration-h-qtqml-proxy.html#QML_FOREIGN_NAMESPACE" translate="no">QML_FOREIGN_NAMESPACE</a></b>(<i>FOREIGN_NAMESPACE</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qqmlintegration-h-qtqml-proxy.html#QML_IMPLEMENTS_INTERFACES" translate="no">QML_IMPLEMENTS_INTERFACES</a></b>(<i>interfaces</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qqmlintegration-h-qtqml-proxy.html#QML_INTERFACE" translate="no">QML_INTERFACE</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qqmlintegration-h-qtqml-proxy.html#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a></b>(<i>name</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qqmlintegration-h-qtqml-proxy.html#QML_REMOVED_IN_VERSION" translate="no">QML_REMOVED_IN_VERSION</a></b>(<i>MAJOR</i>, <i>MINOR</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qqmlintegration-h-qtqml-proxy.html#QML_SEQUENTIAL_CONTAINER" translate="no">QML_SEQUENTIAL_CONTAINER</a></b>(<i>VALUE_TYPE</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qqmlintegration-h-qtqml-proxy.html#QML_SINGLETON" translate="no">QML_SINGLETON</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.5)</code> </td><td class="memItemRight bottomAlign"><b><a href="qqmlintegration-h-qtqml-proxy.html#QML_STRUCTURED_VALUE" translate="no">QML_STRUCTURED_VALUE</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qqmlintegration-h-qtqml-proxy.html#QML_UNAVAILABLE" translate="no">QML_UNAVAILABLE</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qqmlintegration-h-qtqml-proxy.html#QML_UNCREATABLE" translate="no">QML_UNCREATABLE</a></b>(<i>reason</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qqmlintegration-h-qtqml-proxy.html#QML_VALUE_TYPE" translate="no">QML_VALUE_TYPE</a></b>(<i>name</i>)</td></tr>
</table></div>
<div class="macros">
<h2>Macro Documentation</h2>
<!-- $$$QML_ADDED_IN_VERSION[overload1]$$$QML_ADDED_IN_VERSION -->
<h3 class="fn" translate="no" id="QML_ADDED_IN_VERSION"><span class="name">QML_ADDED_IN_VERSION</span>(<i>MAJOR</i>, <i>MINOR</i>)</h3>
<p>Declares that the enclosing type or namespace was added in the specified <i translate="no">MAJOR</i>.<i translate="no">MINOR</i> version. The version is assumed to be in line with any revisions given by <a href="../qtcore/qobject.html#Q_REVISION" translate="no">Q_REVISION</a>() macros on methods, slots, or signals, and any REVISION() attributes on properties declared with <a href="../qtcore/qobject.html#Q_PROPERTY" translate="no">Q_PROPERTY</a>().</p>
<p>QML_ADDED_IN_VERSION() only takes effect if the type or namespace is available in QML, by having a <a href="qqmlintegration-h-qtqml-proxy.html#QML_ELEMENT" translate="no">QML_ELEMENT</a>, <a href="qqmlintegration-h-qtqml-proxy.html#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>(), <a href="qqmlintegration-h-qtqml-proxy.html#QML_ANONYMOUS" translate="no">QML_ANONYMOUS</a>, or <a href="qqmlintegration-h-qtqml-proxy.html#QML_INTERFACE" translate="no">QML_INTERFACE</a> macro.</p>
<p>If the QML module the type belongs to is imported with a lower version than the one determined this way, the QML type is invisible.</p>
<p><b>See also </b><a href="qqmlintegration-h-qtqml-proxy.html#QML_ELEMENT" translate="no">QML_ELEMENT</a> and <a href="qqmlintegration-h-qtqml-proxy.html#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>.</p>
<!-- @@@QML_ADDED_IN_VERSION -->
<!-- $$$QML_ANONYMOUS[overload1]$$$QML_ANONYMOUS -->
<h3 class="fn" translate="no" id="QML_ANONYMOUS"><span class="name">QML_ANONYMOUS</span></h3>
<p>Declares the enclosing type to be available, but anonymous in QML. The type cannot be created or used to declare properties in QML, but when passed from C++, it is recognized. In QML, you can use properties of this type if they are declared in C++.</p>
<p><b>See also </b><a href="qqmlintegration-h-qtqml-proxy.html#QML_ELEMENT" translate="no">QML_ELEMENT</a>, <a href="qqmlintegration-h-qtqml-proxy.html#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>(), <a href="qqmlintegration-h-qtqml-proxy.html#QML_UNCREATABLE" translate="no">QML_UNCREATABLE</a>(), and <a href="qqmlintegration-h-qtqml-proxy.html#QML_INTERFACE" translate="no">QML_INTERFACE</a>.</p>
<!-- @@@QML_ANONYMOUS -->
<!-- $$$QML_ATTACHED[overload1]$$$QML_ATTACHED -->
<h3 class="fn" translate="no" id="QML_ATTACHED"><span class="name">QML_ATTACHED</span>(<i>ATTACHED_TYPE</i>)</h3>
<p>Declares that the enclosing type attaches <i translate="no">ATTACHED_TYPE</i> as an <a href="qtqml-syntax-objectattributes.html#attached-properties-and-attached-signal-handlers">attached property</a> to other types. This takes effect if the type is exposed to QML using a <a href="qqmlintegration-h-qtqml-proxy.html#QML_ELEMENT" translate="no">QML_ELEMENT</a> or <a href="qqmlintegration-h-qtqml-proxy.html#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>() macro.</p>
<div class="admonition note">
<p><b>Note: </b>The class name needs to be fully qualified, even if you're already inside the namespace.</p>
</div>
<p><b>See also </b><a href="qqmlintegration-h-qtqml-proxy.html#QML_ELEMENT" translate="no">QML_ELEMENT</a>, <a href="qqmlintegration-h-qtqml-proxy.html#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>(), <a href="qqml-h-qtqml-proxy.html#qmlAttachedPropertiesObject" translate="no">qmlAttachedPropertiesObject</a>(), and <a href="qtqml-cppintegration-definetypes.html#providing-attached-properties">Providing Attached Properties</a>.</p>
<!-- @@@QML_ATTACHED -->
<!-- $$$QML_CONSTRUCTIBLE_VALUE[overload1]$$$QML_CONSTRUCTIBLE_VALUE -->
<h3 class="fn" translate="no" id="QML_CONSTRUCTIBLE_VALUE"><code class="details extra" translate="no">[since 6.5]</code> <span class="name">QML_CONSTRUCTIBLE_VALUE</span></h3>
<p>Marks the surrounding value type as constructible. That is, any <a href="../qtcore/qobject.html#Q_INVOKABLE" translate="no">Q_INVOKABLE</a> constructors of the type that take exactly one argument can be used when assigning a JavaScript value to a property of this type.</p>
<p>You can declare a constructible value type as follows:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> MyValueType
 {
     Q_GADGET
     QML_VALUE_TYPE(myValueType)
     QML_CONSTRUCTIBLE_VALUE
 <span class="keyword">public</span>:
     Q_INVOKABLE MyValueType(<span class="type">double</span> d);

     <span class="comment">// ...</span>
 };
</pre>
<p>With the above type, the following QML code will produce a <code translate="no">MyValueType</code> value using the given constructor and assign it to the property.</p>
<pre class="qml" translate="no">
 <span class="type"><a href="qml-qtqml-qtobject.html" translate="no">QtObject</a></span> {
     property <span class="type">myValueType</span> <span class="name">v</span>: <span class="number">5.4</span>
 }
</pre>
<p>You can also construct lists of values this way:</p>
<pre class="qml" translate="no">
 <span class="type"><a href="qml-qtqml-qtobject.html" translate="no">QtObject</a></span> {
     property list&lt;<span class="type">myValueType</span>&gt; <span class="name">v</span>: [<span class="number">5.4</span>, <span class="number">4.5</span>, <span class="number">3.3</span>]
 }
</pre>
<p>If you make value types <a href="qtqml-documents-structure.html#valuetypebehavior">addressable</a>, you can use such a type in a <a href="qtqml-javascript-hostenvironment.html#type-annotations-and-assertions">type assertion</a> to explicitly construct it:</p>
<pre class="qml" translate="no">
 pragma ValueTypeBehavior: Addressable

 <span class="type"><a href="qml-qtqml-qtobject.html" translate="no">QtObject</a></span> {
     <span class="keyword">function</span> <span class="name">process</span>(d: <span class="name">real</span>) {
         let v = <span class="name">d</span> <span class="operator">as</span> <span class="name">myValueType</span>;
         <span class="comment">// v is a myValueType now, not a number</span>
     }
 }
</pre>
<p>This macro was introduced in Qt 6.5.</p>
<p><b>See also </b><a href="qqmlintegration-h-qtqml-proxy.html#QML_VALUE_TYPE" translate="no">QML_VALUE_TYPE</a>.</p>
<!-- @@@QML_CONSTRUCTIBLE_VALUE -->
<!-- $$$QML_ELEMENT[overload1]$$$QML_ELEMENT -->
<h3 class="fn" translate="no" id="QML_ELEMENT"><span class="name">QML_ELEMENT</span></h3>
<p>Declares the enclosing type or namespace to be available in QML, using its class or namespace name as the QML element name.</p>
<p>For example, this makes the C++ class <code translate="no">Slider</code> available as a QML type named <code translate="no">Slider</code>. All its properties, invokable methods and enums are exposed.</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> Slider : <span class="keyword">public</span> <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span>
 {
     Q_OBJECT
     QML_ELEMENT
     Q_PROPERTY(<span class="type">int</span> value READ value WRITE setValue NOTIFY valueChanged FINAL)
     <span class="comment">// ...</span>
 <span class="keyword">public</span>:
     <span class="keyword">enum</span> Slippiness {
         Dry<span class="operator">,</span> Wet<span class="operator">,</span> Icy
     };
     Q_ENUM(Slippiness)

     Q_INVOKABLE <span class="type">void</span> slide(Slippiness slippiness);

     <span class="comment">// ...</span>
 }
</pre>
<p>You can use the build system to register the type in the type namespace <i>com.mycompany.qmlcomponents</i> with major version <code translate="no">1</code>. For qmake, specify the following in your project file:</p>
<pre class="cpp plain" translate="no">
 CONFIG += qmltypes
 QML_IMPORT_NAME = com.mycompany.qmlcomponents
 QML_IMPORT_MAJOR_VERSION = 1
</pre>
<p>With CMake, you pass the URI and version to qt_add_qml_module</p>
<pre class="cpp plain" translate="no">
 qt6_add_qml_module(myapp
   URI com.mycompany.qmlcomponents
   VERSION 1.0
 )
</pre>
<p>Once registered, the type can be used in QML by importing the same type namespace and version number:</p>
<pre class="qml" translate="no">
 import com.mycompany.qmlcomponents 1.0

 <span class="type"><a href="../qtquickcontrols/qml-qtquick-controls-slider.html" translate="no">Slider</a></span> {
     <span class="name">value</span>: <span class="number">12</span>
     <span class="name">Component</span>.onCompleted: <span class="name">slide</span>(<span class="name">Slider</span>.<span class="name">Icy</span>)

     <span class="comment">// ...</span>
 }
</pre>
<p>You can also make namespaces tagged with <a href="../qtcore/qobject.html#Q_NAMESPACE" translate="no">Q_NAMESPACE</a> available this way, in order to expose any enums tagged with <a href="../qtcore/qobject.html#Q_ENUM_NS" translate="no">Q_ENUM_NS</a> they contain:</p>
<pre class="cpp" translate="no">
 <span class="keyword">namespace</span> MyNamespace {
   Q_NAMESPACE
   QML_ELEMENT

   <span class="keyword">enum</span> MyEnum {
       Key1<span class="operator">,</span>
       Key2<span class="operator">,</span>
   };
   Q_ENUM_NS(MyEnum)
 }
</pre>
<p>In QML, you can then use the enums:</p>
<pre class="qml" translate="no">
 Component.onCompleted: console.log(MyNamespace.Key2)
</pre>
<p><b>NOTE:</b> When classes have the same name but are located in different namespaces using QML_ELEMENT on both of them will cause a conflict. Make sure to use <a href="qqmlintegration-h-qtqml-proxy.html#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>() for one of them instead.</p>
<div class="admonition note">
<p><b>Note: </b>The class name needs to be fully qualified, even if you're already inside the namespace.</p>
</div>
<p><b>See also </b><a href="qtqml-cppintegration-overview.html#choosing-the-correct-integration-method-between-c-and-qml">Choosing the Correct Integration Method Between C++ and QML</a>, <a href="qqmlintegration-h-qtqml-proxy.html#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>(), <a href="../qtcore/qobject.html#Q_REVISION" translate="no">Q_REVISION</a>(), and <a href="qqmlintegration-h-qtqml-proxy.html#QML_ADDED_IN_VERSION" translate="no">QML_ADDED_IN_VERSION</a>().</p>
<!-- @@@QML_ELEMENT -->
<!-- $$$QML_EXTENDED[overload1]$$$QML_EXTENDED -->
<h3 class="fn" translate="no" id="QML_EXTENDED"><span class="name">QML_EXTENDED</span>(<i>EXTENDED_TYPE</i>)</h3>
<p>Declares that the enclosing type uses <i translate="no">EXTENDED_TYPE</i> as an extension to provide further properties, methods, and enumerations in QML. This takes effect if the type is exposed to QML using a <a href="qqmlintegration-h-qtqml-proxy.html#QML_ELEMENT" translate="no">QML_ELEMENT</a> or <a href="qqmlintegration-h-qtqml-proxy.html#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>() macro.</p>
<div class="admonition warning">
<p><b>Warning: </b>Members of <i translate="no">EXTENDED_TYPE</i> are implicitly treated as FINAL.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The class name needs to be fully qualified, even if you're already inside the namespace.</p>
</div>
<p><b>See also </b><a href="qqmlintegration-h-qtqml-proxy.html#QML_ELEMENT" translate="no">QML_ELEMENT</a>, <a href="qqmlintegration-h-qtqml-proxy.html#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>(), <a href="qqmlintegration-h-qtqml-proxy.html#QML_EXTENDED_NAMESPACE" translate="no">QML_EXTENDED_NAMESPACE</a>(), and <a href="qtqml-cppintegration-definetypes.html#registering-extension-objects">Registering Extension Objects</a>.</p>
<!-- @@@QML_EXTENDED -->
<!-- $$$QML_EXTENDED_NAMESPACE[overload1]$$$QML_EXTENDED_NAMESPACE -->
<h3 class="fn" translate="no" id="QML_EXTENDED_NAMESPACE"><span class="name">QML_EXTENDED_NAMESPACE</span>(<i>EXTENSION_NAMESPACE</i>)</h3>
<p>Declares that the enclosing <b>type</b> uses <i translate="no">EXTENSION_NAMESPACE</i> as an extension to provide further enumerations in QML. This takes effect if the type is exposed to QML using a <a href="qqmlintegration-h-qtqml-proxy.html#QML_ELEMENT" translate="no">QML_ELEMENT</a> or <a href="qqmlintegration-h-qtqml-proxy.html#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>() macro. The enumerations need to be exposed to the metaobject system for this to work.</p>
<p>For example, give the following C++ code</p>
<pre class="cpp" translate="no">
 <span class="keyword">namespace</span> MyNamespace {
     Q_NAMESPACE
     <span class="keyword">enum</span> MyEnum { MyEnumerator <span class="operator">=</span> <span class="number">10</span> };
     Q_ENUM_NS(MyEnum)
 }

 <span class="keyword">class</span> QmlType : <span class="keyword">public</span> <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span>
 {
     Q_OBJECT
     QML_ELEMENT
     QML_EXTENDED_NAMESPACE(MyNamespace)
 }
</pre>
<p>we can access the enum in QML:</p>
<pre class="qml" translate="no">
 <span class="type">QmlType</span> {
     property <span class="type"><a href="qml-int.html" translate="no">int</a></span> <span class="name">i</span>: <span class="name">QmlType</span>.<span class="name">MyEnumerator</span> <span class="comment">// i will be 10</span>
 }
</pre>
<div class="admonition note">
<p><b>Note: </b><i translate="no">EXTENSION_NAMESPACE</i> can also be a <a href="../qtcore/qobject.html" translate="no">QObject</a> or QGadget; in that case - and in contrast to <a href="qqmlintegration-h-qtqml-proxy.html#QML_EXTENDED" translate="no">QML_EXTENDED</a>, which also exposes methods and properties - only its enumerations are exposed.</p>
</div>
<div class="admonition note">
<p><b>Note: </b><i translate="no">EXTENSION_NAMESPACE</i> must have a metaobject; i.e. it must either be a namespace which contains the <a href="../qtcore/qobject.html#Q_NAMESPACE" translate="no">Q_NAMESPACE</a> macro or a <a href="../qtcore/qobject.html" translate="no">QObject</a>/QGadget.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The class name needs to be fully qualified, even if you're already inside the namespace.</p>
</div>
<p><b>See also </b><a href="qqmlengine.html#QML_NAMESPACE_EXTENDED" translate="no">QML_NAMESPACE_EXTENDED</a>(), <a href="qqmlintegration-h-qtqml-proxy.html#QML_ELEMENT" translate="no">QML_ELEMENT</a>, <a href="qqmlintegration-h-qtqml-proxy.html#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>(), <a href="qqmlintegration-h-qtqml-proxy.html#QML_EXTENDED" translate="no">QML_EXTENDED</a>(), <a href="qtqml-cppintegration-definetypes.html#registering-extension-objects">Registering Extension Objects</a>, <a href="../qtcore/qobject.html#Q_ENUM" translate="no">Q_ENUM</a>, and <a href="../qtcore/qobject.html#Q_ENUM_NS" translate="no">Q_ENUM_NS</a>.</p>
<!-- @@@QML_EXTENDED_NAMESPACE -->
<!-- $$$QML_EXTRA_VERSION[overload1]$$$QML_EXTRA_VERSION -->
<h3 class="fn" translate="no" id="QML_EXTRA_VERSION"><span class="name">QML_EXTRA_VERSION</span>(<i>MAJOR</i>, <i>MINOR</i>)</h3>
<p>Declare that the type should also be available in version <i translate="no">MAJOR</i>.<i translate="no">MINOR</i>. This can be helpful if a type should be available in multiple major versions.</p>
<p>Types are automatically registered for:</p>
<ul>
<li>The major version they were introduced in, see <a href="qqmlintegration-h-qtqml-proxy.html#QML_ADDED_IN_VERSION" translate="no">QML_ADDED_IN_VERSION</a>.</li>
<li>Any major versions any their members were introduced in.</li>
<li>The current major version of their module, unless they were <a href="qqmlintegration-h-qtqml-proxy.html#QML_REMOVED_IN_VERSION" translate="no">QML_REMOVED_IN_VERSION</a> before that.</li>
</ul>
<p>Notably, they are not automatically registered in any <a href="qt-add-qml-module.html#registering-past-major-versions">PAST_MAJOR_VERSIONS</a> between the above. You can use QML_EXTRA_VERSION to manually register your types in further major versions.</p>
<div class="admonition note">
<p><b>Note: </b>Keeping multiple <a href="qt-add-qml-module.html#registering-past-major-versions">PAST_MAJOR_VERSIONS</a> around is computationally expensive.</p>
</div>
<p><b>See also </b><a href="qqmlintegration-h-qtqml-proxy.html#QML_ELEMENT" translate="no">QML_ELEMENT</a> and <a href="qqmlintegration-h-qtqml-proxy.html#QML_ADDED_IN_VERSION" translate="no">QML_ADDED_IN_VERSION</a>.</p>
<!-- @@@QML_EXTRA_VERSION -->
<!-- $$$QML_FOREIGN[overload1]$$$QML_FOREIGN -->
<h3 class="fn" translate="no" id="QML_FOREIGN"><span class="name">QML_FOREIGN</span>(<i>FOREIGN_TYPE</i>)</h3>
<p>Declares that any <a href="qqmlintegration-h-qtqml-proxy.html#QML_ELEMENT" translate="no">QML_ELEMENT</a>, <a href="qqmlintegration-h-qtqml-proxy.html#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>(), <a href="qqmlintegration-h-qtqml-proxy.html#QML_ANONYMOUS" translate="no">QML_ANONYMOUS</a>, <a href="qqmlintegration-h-qtqml-proxy.html#QML_INTERFACE" translate="no">QML_INTERFACE</a>, <a href="qqmlintegration-h-qtqml-proxy.html#QML_UNCREATABLE" translate="no">QML_UNCREATABLE</a>(), <a href="qqmlintegration-h-qtqml-proxy.html#QML_SINGLETON" translate="no">QML_SINGLETON</a>, <a href="qqmlintegration-h-qtqml-proxy.html#QML_ADDED_IN_VERSION" translate="no">QML_ADDED_IN_VERSION</a>(), <a href="qqmlintegration-h-qtqml-proxy.html#QML_REMOVED_IN_VERSION" translate="no">QML_REMOVED_IN_VERSION</a>(), <a href="qqmlintegration-h-qtqml-proxy-obsolete.html#QML_ADDED_IN_MINOR_VERSION" class="obsolete" translate="no">QML_ADDED_IN_MINOR_VERSION</a>(), <a href="qqmlintegration-h-qtqml-proxy-obsolete.html#QML_REMOVED_IN_MINOR_VERSION" class="obsolete" translate="no">QML_REMOVED_IN_MINOR_VERSION</a>(), <a href="qqmlintegration-h-qtqml-proxy.html#QML_EXTENDED" translate="no">QML_EXTENDED</a>(), <a href="qqmlintegration-h-qtqml-proxy.html#QML_EXTENDED_NAMESPACE" translate="no">QML_EXTENDED_NAMESPACE</a>(), or <a href="qqmlengine.html#QML_NAMESPACE_EXTENDED" translate="no">QML_NAMESPACE_EXTENDED</a>() macros in the enclosing C++ type do not apply to the enclosing type but instead to <i translate="no">FOREIGN_TYPE</i>. The enclosing type still needs to be registered with the <a href="../qtcore/metaobjects.html">meta object system</a> using a <a href="../qtcore/qobject.html#Q_GADGET" translate="no">Q_GADGET</a> or <a href="../qtcore/qobject.html#Q_OBJECT" translate="no">Q_OBJECT</a> macro.</p>
<p>This is useful for registering types that cannot be amended to add the macros, for example because they belong to 3rdparty libraries. To register a namespace, see <a href="qqmlintegration-h-qtqml-proxy.html#QML_FOREIGN_NAMESPACE" translate="no">QML_FOREIGN_NAMESPACE</a>().</p>
<div class="admonition note">
<p><b>Note: </b>You may want to use <a href="qqmlintegration-h-qtqml-proxy.html#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>() instead of <a href="qqmlintegration-h-qtqml-proxy.html#QML_ELEMENT" translate="no">QML_ELEMENT</a>. With <a href="qqmlintegration-h-qtqml-proxy.html#QML_ELEMENT" translate="no">QML_ELEMENT</a>, the element is named after the struct it is contained in, not the foreign type. The <a href="qtqml-tutorials-extending-qml-advanced-example.html#foreign-objects-integration">Foreign objects integration</a> chapter in <a href="qtqml-tutorials-extending-qml-advanced-example.html">Writing advanced QML Extensions with C++</a> demonstrates this.</p>
</div>
<div class="admonition note">
<p><b>Note: </b><a href="qqmlintegration-h-qtqml-proxy.html#QML_ATTACHED" translate="no">QML_ATTACHED</a>() can currently not be redirected like this. It has to be specificed in the same type that implements qmlAttachedProperties().</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The class name needs to be fully qualified, even if you're already inside the namespace.</p>
</div>
<p><b>See also </b><a href="qqmlintegration-h-qtqml-proxy.html#QML_ELEMENT" translate="no">QML_ELEMENT</a>, <a href="qqmlintegration-h-qtqml-proxy.html#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>(), and <a href="qqmlintegration-h-qtqml-proxy.html#QML_FOREIGN_NAMESPACE" translate="no">QML_FOREIGN_NAMESPACE</a>().</p>
<!-- @@@QML_FOREIGN -->
<!-- $$$QML_FOREIGN_NAMESPACE[overload1]$$$QML_FOREIGN_NAMESPACE -->
<h3 class="fn" translate="no" id="QML_FOREIGN_NAMESPACE"><span class="name">QML_FOREIGN_NAMESPACE</span>(<i>FOREIGN_NAMESPACE</i>)</h3>
<p>Declares that any <a href="qqmlintegration-h-qtqml-proxy.html#QML_ELEMENT" translate="no">QML_ELEMENT</a>, <a href="qqmlintegration-h-qtqml-proxy.html#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>(), <a href="qqmlintegration-h-qtqml-proxy.html#QML_ANONYMOUS" translate="no">QML_ANONYMOUS</a>, <a href="qqmlintegration-h-qtqml-proxy.html#QML_INTERFACE" translate="no">QML_INTERFACE</a>, <a href="qqmlintegration-h-qtqml-proxy.html#QML_UNCREATABLE" translate="no">QML_UNCREATABLE</a>(), <a href="qqmlintegration-h-qtqml-proxy.html#QML_SINGLETON" translate="no">QML_SINGLETON</a>, <a href="qqmlintegration-h-qtqml-proxy.html#QML_ADDED_IN_VERSION" translate="no">QML_ADDED_IN_VERSION</a>(), <a href="qqmlintegration-h-qtqml-proxy.html#QML_REMOVED_IN_VERSION" translate="no">QML_REMOVED_IN_VERSION</a>(), <a href="qqmlintegration-h-qtqml-proxy-obsolete.html#QML_ADDED_IN_MINOR_VERSION" class="obsolete" translate="no">QML_ADDED_IN_MINOR_VERSION</a>(), or <a href="qqmlintegration-h-qtqml-proxy-obsolete.html#QML_REMOVED_IN_MINOR_VERSION" class="obsolete" translate="no">QML_REMOVED_IN_MINOR_VERSION</a>() macros in the enclosing C++ namespace do not apply to the enclosing type but instead to <i translate="no">FOREIGN_NAMESPACE</i>. The enclosing namespace still needs to be registered with the <a href="../qtcore/metaobjects.html">meta object system</a> using a <a href="../qtcore/qobject.html#Q_NAMESPACE" translate="no">Q_NAMESPACE</a> macro.</p>
<p>This is useful for registering namespaces that cannot be amended to add the macros, for example because they belong to 3rdparty libraries.</p>
<p><b>See also </b><a href="qqmlintegration-h-qtqml-proxy.html#QML_ELEMENT" translate="no">QML_ELEMENT</a>, <a href="qqmlintegration-h-qtqml-proxy.html#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>(), and <a href="qqmlintegration-h-qtqml-proxy.html#QML_FOREIGN" translate="no">QML_FOREIGN</a>().</p>
<!-- @@@QML_FOREIGN_NAMESPACE -->
<!-- $$$QML_IMPLEMENTS_INTERFACES[overload1]$$$QML_IMPLEMENTS_INTERFACES -->
<h3 class="fn" translate="no" id="QML_IMPLEMENTS_INTERFACES"><span class="name">QML_IMPLEMENTS_INTERFACES</span>(<i>interfaces</i>)</h3>
<p>This macro tells Qt which QML <i translate="no">interfaces</i> the class implements. This macro should only be used for interfacing with classes using <a href="qqmlintegration-h-qtqml-proxy.html#QML_INTERFACE" translate="no">QML_INTERFACE</a>, use <a href="../qtcore/qobject.html#Q_INTERFACES" translate="no">Q_INTERFACES</a> otherwise. It's required in order for declarative registration via <a href="qqmlintegration-h-qtqml-proxy.html#QML_ELEMENT" translate="no">QML_ELEMENT</a> to function properly.</p>
<p><b>See also </b><a href="qqmlintegration-h-qtqml-proxy.html#QML_INTERFACE" translate="no">QML_INTERFACE</a> and <a href="../qtcore/qobject.html#Q_INTERFACES" translate="no">Q_INTERFACES</a>.</p>
<!-- @@@QML_IMPLEMENTS_INTERFACES -->
<!-- $$$QML_INTERFACE[overload1]$$$QML_INTERFACE -->
<h3 class="fn" translate="no" id="QML_INTERFACE"><span class="name">QML_INTERFACE</span></h3>
<p>This macro registers the enclosing C++ type in the QML system as an interface.</p>
<p>Types registered as an interface in QML should also declare themselves as an interface with the <a href="../qtcore/metaobjects.html">meta object system</a>. For example:</p>
<pre class="cpp" translate="no">
 <span class="keyword">struct</span> FooInterface
 {
     QML_INTERFACE
 <span class="keyword">public</span>:
     <span class="keyword">virtual</span> <span class="operator">~</span>FooInterface();
     <span class="keyword">virtual</span> <span class="type">void</span> doSomething() <span class="operator">=</span> <span class="number">0</span>;
 };

 Q_DECLARE_INTERFACE(FooInterface<span class="operator">,</span> <span class="string">&quot;org.foo.FooInterface&quot;</span>)
</pre>
<p>When registered with QML in this way, they can be used as property types:</p>
<p><a href="../qtcore/qobject.html#Q_PROPERTY" translate="no">Q_PROPERTY</a>(FooInterface *foo READ foo WRITE setFoo)</p>
<p>When you assign a <a href="../qtcore/qobject.html" translate="no">QObject</a> sub-class to this property, the QML engine does the interface cast to <code translate="no">FooInterface*</code> automatically.</p>
<p>Interface types are implicitly anonymous and uncreatable in QML.</p>
<p><b>NOTE:</b> When inheriting from types using QML_INTERFACE, use <a href="qqmlintegration-h-qtqml-proxy.html#QML_IMPLEMENTS_INTERFACES" translate="no">QML_IMPLEMENTS_INTERFACES</a> instead of <a href="../qtcore/qobject.html#Q_INTERFACES" translate="no">Q_INTERFACES</a>.</p>
<p><b>See also </b><a href="qqmlintegration-h-qtqml-proxy.html#QML_IMPLEMENTS_INTERFACES" translate="no">QML_IMPLEMENTS_INTERFACES</a>(), <a href="qqmlintegration-h-qtqml-proxy.html#QML_ELEMENT" translate="no">QML_ELEMENT</a>, <a href="qqmlintegration-h-qtqml-proxy.html#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>(), <a href="qqmlintegration-h-qtqml-proxy.html#QML_UNCREATABLE" translate="no">QML_UNCREATABLE</a>(), and <a href="qqmlintegration-h-qtqml-proxy.html#QML_ANONYMOUS" translate="no">QML_ANONYMOUS</a>.</p>
<!-- @@@QML_INTERFACE -->
<!-- $$$QML_NAMED_ELEMENT[overload1]$$$QML_NAMED_ELEMENT -->
<h3 class="fn" translate="no" id="QML_NAMED_ELEMENT"><span class="name">QML_NAMED_ELEMENT</span>(<i>name</i>)</h3>
<p>Declares the enclosing type or namespace to be available in QML, using <i translate="no">name</i> as the element name. Otherwise behaves the same as <a href="qqmlintegration-h-qtqml-proxy.html#QML_ELEMENT" translate="no">QML_ELEMENT</a>.</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> SqlEventDatabase : <span class="keyword">public</span> <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span>
 {
     Q_OBJECT
     QML_NAMED_ELEMENT(EventDatabase)

     <span class="comment">// ...</span>
 };
</pre>
<p><b>See also </b><a href="qtqml-cppintegration-overview.html#choosing-the-correct-integration-method-between-c-and-qml">Choosing the Correct Integration Method Between C++ and QML</a> and <a href="qqmlintegration-h-qtqml-proxy.html#QML_ELEMENT" translate="no">QML_ELEMENT</a>.</p>
<!-- @@@QML_NAMED_ELEMENT -->
<!-- $$$QML_REMOVED_IN_VERSION[overload1]$$$QML_REMOVED_IN_VERSION -->
<h3 class="fn" translate="no" id="QML_REMOVED_IN_VERSION"><span class="name">QML_REMOVED_IN_VERSION</span>(<i>MAJOR</i>, <i>MINOR</i>)</h3>
<p>Declares that the enclosing type or namespace was removed in the specified <i translate="no">MAJOR</i>.<i translate="no">MINOR</i> version. This is primarily useful when replacing the implementation of a QML type. If a corresponding <a href="qqmlintegration-h-qtqml-proxy.html#QML_ADDED_IN_VERSION" translate="no">QML_ADDED_IN_VERSION</a>() is present on a different type or namespace of the same QML name, then the removed type is used when importing versions of the module lower than <i translate="no">MAJOR</i>.<i translate="no">MINOR</i>, and the added type is used when importing versions of the module greater or equal <i translate="no">MAJOR</i>.<i translate="no">MINOR</i>.</p>
<p>QML_REMOVED_IN_VERSION() only takes effect if type or namespace is available in QML, by having a <a href="qqmlintegration-h-qtqml-proxy.html#QML_ELEMENT" translate="no">QML_ELEMENT</a>, <a href="qqmlintegration-h-qtqml-proxy.html#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>(), <a href="qqmlintegration-h-qtqml-proxy.html#QML_ANONYMOUS" translate="no">QML_ANONYMOUS</a>, or <a href="qqmlintegration-h-qtqml-proxy.html#QML_INTERFACE" translate="no">QML_INTERFACE</a> macro.</p>
<p><b>See also </b><a href="qqmlintegration-h-qtqml-proxy.html#QML_ELEMENT" translate="no">QML_ELEMENT</a> and <a href="qqmlintegration-h-qtqml-proxy.html#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>.</p>
<!-- @@@QML_REMOVED_IN_VERSION -->
<!-- $$$QML_SEQUENTIAL_CONTAINER[overload1]$$$QML_SEQUENTIAL_CONTAINER -->
<h3 class="fn" translate="no" id="QML_SEQUENTIAL_CONTAINER"><span class="name">QML_SEQUENTIAL_CONTAINER</span>(<i>VALUE_TYPE</i>)</h3>
<p>This macro declares the enclosing or referenced type as a sequential container managing a sequence of <i translate="no">VALUE_TYPE</i> elements. <i translate="no">VALUE_TYPE</i> can be an actual <a href="qtqml-typesystem-valuetypes.html">value type</a> or a pointer to an <a href="qtqml-typesystem-objecttypes.html">object type</a>. You will rarely be able to add this macro to the actual container declaration since containers are usually templates. You should use <a href="qqmlintegration-h-qtqml-proxy.html#QML_FOREIGN" translate="no">QML_FOREIGN</a> to attach the type registration to a template instantiation. Using this technique you can, for example, declare sequential containers like this:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> IntDequeRegistration
 {
   Q_GADGET
   QML_FOREIGN(std<span class="operator">::</span>deque<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span>)
   QML_ANONYMOUS
   QML_SEQUENTIAL_CONTAINER(<span class="type">int</span>)
 };
</pre>
<p>After this, you can use the container like a JavaScript array in QML.</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> Maze
 {
   Q_OBJECT
   Q_ELEMENT
   <span class="comment">// 0: North, 1: East, 2: South, 3: West</span>
   Q_PROPERTY(std<span class="operator">::</span>deque<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> solution READ solution CONSTANT FINAL)
   <span class="operator">[</span><span class="operator">.</span><span class="operator">.</span><span class="operator">.</span><span class="operator">]</span>
 }
</pre>
<pre class="cpp" translate="no">
 Item {
   Maze {
     id: maze
   }

   function showSolution() {
       maze<span class="operator">.</span>solution<span class="operator">.</span>forEach(<span class="operator">[</span><span class="operator">.</span><span class="operator">.</span><span class="operator">.</span><span class="operator">]</span>)
   }
 }
</pre>
<div class="admonition note">
<p><b>Note: </b>For <a href="qtqml-typesystem-valuetypes.html">QML Value Types</a> <a href="../qtcore/qlist.html" translate="no">QList</a> is automatically registered as sequential container. For <a href="qtqml-typesystem-objecttypes.html">QML Object Types</a> <a href="qqmllistproperty.html" translate="no">QQmlListProperty</a> is. You don't have to add these registrations.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>You cannot currently give the container a custom name. Any argument passed to <a href="qqmlintegration-h-qtqml-proxy.html#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a> is ignored. The automatically registered sequential containers are available under the familiar <i>list&lt;...&gt;</i> names, for example <i>list&lt;<a href="qml-qtqml-qtobject.html" translate="no">QtObject</a>&gt;</i> or <i>list&lt;font&gt;</i>.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The class name needs to be fully qualified, even if you're already inside the namespace.</p>
</div>
<p><b>See also </b><a href="qqmlintegration-h-qtqml-proxy.html#QML_ANONYMOUS" translate="no">QML_ANONYMOUS</a> and <a href="qqmlintegration-h-qtqml-proxy.html#QML_FOREIGN" translate="no">QML_FOREIGN</a>().</p>
<!-- @@@QML_SEQUENTIAL_CONTAINER -->
<!-- $$$QML_SINGLETON[overload1]$$$QML_SINGLETON -->
<h3 class="fn" translate="no" id="QML_SINGLETON"><span class="name">QML_SINGLETON</span></h3>
<p>Declares the enclosing type to be a singleton in QML. This only takes effect if the type is a <a href="../qtcore/qobject.html#Q_OBJECT" translate="no">Q_OBJECT</a> and is available in QML (by having a <a href="qqmlintegration-h-qtqml-proxy.html#QML_ELEMENT" translate="no">QML_ELEMENT</a> or <a href="qqmlintegration-h-qtqml-proxy.html#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>() macro). By default, each <a href="qqmlengine.html" translate="no">QQmlEngine</a> will try to create a singleton instance using either the type's default constructor or a static factory function of the signature <code translate="no">T *create(QQmlEngine *, QJSEngine *)</code> when the type is first accessed. If both do exist and are accessible, the default constructor is preferred. If there is no default constructor and no factory function the singleton is inaccessible. The QML engine generally assumes ownership of the singleton and will delete it when the engine itself is destroyed. You can prevent this by calling <a href="qjsengine.html#setObjectOwnership" translate="no">QJSEngine::setObjectOwnership</a>() on the singleton.</p>
<p>In order to declare a default-constructible class as singleton, all you have to do is add QML_SINGLETON:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> MySingleton : <span class="keyword">public</span> <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span>
 {
     Q_OBJECT
     QML_ELEMENT
     QML_SINGLETON
     <span class="comment">// Q_PROPERTY( ... )</span>
 <span class="keyword">public</span>:
     <span class="comment">// members, Q_INVOKABLE functions, etc.</span>
 };
</pre>
<p>If the singleton class is not default-constructible, but you can modify it, you can add a factory function to it, in order to make it accessible:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> MySingleton : <span class="keyword">public</span> <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span>
 {
     Q_OBJECT
     QML_ELEMENT
     QML_SINGLETON
     <span class="comment">// Q_PROPERTY( ... )</span>

 <span class="keyword">public</span>:
     <span class="keyword">static</span> MySingleton <span class="operator">*</span>create(<span class="type"><a href="qqmlengine.html" translate="no">QQmlEngine</a></span> <span class="operator">*</span>qmlEngine<span class="operator">,</span> <span class="type"><a href="qjsengine.html" translate="no">QJSEngine</a></span> <span class="operator">*</span>jsEngine)
     {
         MySingleton <span class="operator">*</span>result <span class="operator">=</span> nullptr;
         <span class="comment">// Create the object using some custom constructor or factory.</span>
         <span class="comment">// The QML engine will assume ownership and delete it, eventually.</span>
         <span class="keyword">return</span> result;
     }

     <span class="comment">// members, Q_INVOKABLE functions, etc</span>
 };
</pre>
<p>If you cannot modify the class and it does not have a default constructor or a suitable factory function, you can provide a <a href="qqmlintegration-h-qtqml-proxy.html#QML_FOREIGN" translate="no">QML_FOREIGN</a> wrapper to define the factory function:</p>
<pre class="cpp" translate="no">
 <span class="keyword">struct</span> SingletonForeign
 {
     Q_GADGET
     QML_FOREIGN(MySingleton)
     QML_SINGLETON
     QML_NAMED_ELEMENT(MySingleton)
 <span class="keyword">public</span>:

     <span class="keyword">static</span> MySingleton <span class="operator">*</span>create(<span class="type"><a href="qqmlengine.html" translate="no">QQmlEngine</a></span> <span class="operator">*</span><span class="operator">,</span> <span class="type"><a href="qjsengine.html" translate="no">QJSEngine</a></span> <span class="operator">*</span>engine)
     {
         MySingleton <span class="operator">*</span>result <span class="operator">=</span> nullptr;
         <span class="comment">// Create the instance using some custom constructor or factory.</span>
         <span class="comment">// The QML engine will assume ownership and delete it, eventually.</span>
         <span class="keyword">return</span> result;
     }
 };
</pre>
<p>Finally, if you want to provide one specific singleton object, the creation of which you cannot control, you can return that from a factory function. This is a replacement for the <a href="qqml-h-qtqml-proxy.html#qmlRegisterSingletonInstance" translate="no">qmlRegisterSingletonInstance</a> function. If you were calling</p>
<pre class="cpp" translate="no">
 qmlRegisterSingletonInstance(<span class="string">&quot;MyModule&quot;</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="string">&quot;MySingleton&quot;</span><span class="operator">,</span> myObject);
</pre>
<p>with myObject being of type <code translate="no">MySingleton *</code>, you can do the following instead:</p>
<pre class="cpp" translate="no">
 <span class="keyword">struct</span> SingletonForeign
 {
     Q_GADGET
     QML_FOREIGN(MySingleton)
     QML_SINGLETON
     QML_NAMED_ELEMENT(MySingleton)
 <span class="keyword">public</span>:

     <span class="comment">// Initialize this using myObject where you would previously</span>
     <span class="comment">// call qmlRegisterSingletonInstance().</span>
     <span class="keyword">inline</span> <span class="keyword">static</span> MySingleton <span class="operator">*</span>s_singletonInstance <span class="operator">=</span> nullptr;

     <span class="keyword">static</span> MySingleton <span class="operator">*</span>create(<span class="type"><a href="qqmlengine.html" translate="no">QQmlEngine</a></span> <span class="operator">*</span><span class="operator">,</span> <span class="type"><a href="qjsengine.html" translate="no">QJSEngine</a></span> <span class="operator">*</span>engine)
     {
         <span class="comment">// The instance has to exist before it is used. We cannot replace it.</span>
         Q_ASSERT(s_singletonInstance);

         <span class="comment">// The engine has to have the same thread affinity as the singleton.</span>
         Q_ASSERT(engine<span class="operator">-</span><span class="operator">&gt;</span>thread() <span class="operator">=</span><span class="operator">=</span> s_singletonInstance<span class="operator">-</span><span class="operator">&gt;</span>thread());

         <span class="comment">// There can only be one engine accessing the singleton.</span>
         <span class="keyword">if</span> (s_engine)
             Q_ASSERT(engine <span class="operator">=</span><span class="operator">=</span> s_engine);
         <span class="keyword">else</span>
             s_engine <span class="operator">=</span> engine;

         <span class="comment">// Explicitly specify C++ ownership so that the engine doesn't delete</span>
         <span class="comment">// the instance.</span>
         <span class="type"><a href="qjsengine.html" translate="no">QJSEngine</a></span><span class="operator">::</span>setObjectOwnership(s_singletonInstance<span class="operator">,</span>
                                       <span class="type"><a href="qjsengine.html" translate="no">QJSEngine</a></span><span class="operator">::</span>CppOwnership);
         <span class="keyword">return</span> s_singletonInstance;
     }

 <span class="keyword">private</span>:
     <span class="keyword">inline</span> <span class="keyword">static</span> <span class="type"><a href="qjsengine.html" translate="no">QJSEngine</a></span> <span class="operator">*</span>s_engine <span class="operator">=</span> nullptr;
 };
</pre>
<p>This way, the pre-existing class <code translate="no">MySingleton</code> is declared to be a QML singleton, called <code translate="no">MySingleton</code>. You can specify an instance for it any time before it is used by setting the <code translate="no">s_singletonInstance</code> member. None of this requires modification of <code translate="no">MySingleton</code> itself.</p>
<div class="admonition note">
<p><b>Note: </b>This pattern doesn't work if either the singleton is accessed by multiple QML engines, or if the QML engine accessing it has a different thread affinity than the singleton object itself. As shown above, you can check the parameters to the <code translate="no">create()</code> method for identity and thread affinity of the engine in order to assert on that.</p>
</div>
<p><b>See also </b><a href="qqmlintegration-h-qtqml-proxy.html#QML_ELEMENT" translate="no">QML_ELEMENT</a>, <a href="qqmlintegration-h-qtqml-proxy.html#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>(), <a href="qqml-h-qtqml-proxy.html#qmlRegisterSingletonInstance" translate="no">qmlRegisterSingletonInstance</a>(), <a href="qqmlengine.html#singletonInstance" translate="no">QQmlEngine::singletonInstance</a>(), and <a href="qml-singleton.html">Singletons in QML</a>.</p>
<!-- @@@QML_SINGLETON -->
<!-- $$$QML_STRUCTURED_VALUE[overload1]$$$QML_STRUCTURED_VALUE -->
<h3 class="fn" translate="no" id="QML_STRUCTURED_VALUE"><code class="details extra" translate="no">[since 6.5]</code> <span class="name">QML_STRUCTURED_VALUE</span></h3>
<p>Marks the surrounding value type as structured. Structured value types can and will preferably be constructed property-by-property from a JavaScript object. A structured value type, however is always <a href="qqmlintegration-h-qtqml-proxy.html#QML_CONSTRUCTIBLE_VALUE" translate="no">QML_CONSTRUCTIBLE_VALUE</a>, too. This means, you can still provide <a href="../qtcore/qobject.html#Q_INVOKABLE" translate="no">Q_INVOKABLE</a> constructors in order to handle construction from primitive types.</p>
<p>You can declare a structured value type as follows:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> MyValueType
 {
     Q_GADGET
     QML_VALUE_TYPE(myValueType)
     QML_STRUCTURED_VALUE
     Q_PROPERTY(<span class="type">double</span> d READ d WRITE setD)
     Q_PROPERTY(string e READ e WRITE setE)

     <span class="comment">// ...</span>
 };
</pre>
<p>Then you can populate a property of this type as follows:</p>
<pre class="qml" translate="no">
 <span class="type"><a href="qml-qtqml-qtobject.html" translate="no">QtObject</a></span> {
     property <span class="type">myValueType</span> <span class="name">v</span>: ({d: <span class="number">4.4</span>, e: <span class="string">&quot;a string&quot;</span>})
 }
</pre>
<p>The extra parentheses are necessary to disambiguate the JavaScript object from what might be interpreted as a JavaScript code block.</p>
<p>You can also construct lists of values this way:</p>
<pre class="qml" translate="no">
 <span class="type"><a href="qml-qtqml-qtobject.html" translate="no">QtObject</a></span> {
     property list&lt;<span class="type">myValueType</span>&gt; <span class="name">v</span>: [
         {d: <span class="number">4.4</span>, e: <span class="string">&quot;a string&quot;</span>},
         {d: <span class="number">7.1</span>, e: <span class="string">&quot;another string&quot;</span>}
     ]
 }
</pre>
<p>If you make value types <a href="qtqml-documents-structure.html#valuetypebehavior">addressable</a>, you can use such a type in a <a href="qtqml-javascript-hostenvironment.html#type-annotations-and-assertions">type assertion</a> to explicitly construct it:</p>
<pre class="qml" translate="no">
 pragma ValueTypeBehavior: Addressable

 <span class="type"><a href="qml-qtqml-qtobject.html" translate="no">QtObject</a></span> {
     <span class="keyword">function</span> <span class="name">process</span>(d: <span class="name">real</span>) {
         let v = {d: <span class="name">d</span>, e: <span class="name">objectName</span>} <span class="operator">as</span> <span class="name">myValueType</span>;
         <span class="comment">// v is a myValueType now</span>
     }
 }
</pre>
<p>This macro was introduced in Qt 6.5.</p>
<p><b>See also </b><a href="qqmlintegration-h-qtqml-proxy.html#QML_VALUE_TYPE" translate="no">QML_VALUE_TYPE</a> and <a href="qqmlintegration-h-qtqml-proxy.html#QML_CONSTRUCTIBLE_VALUE" translate="no">QML_CONSTRUCTIBLE_VALUE</a>.</p>
<!-- @@@QML_STRUCTURED_VALUE -->
<!-- $$$QML_UNAVAILABLE[overload1]$$$QML_UNAVAILABLE -->
<h3 class="fn" translate="no" id="QML_UNAVAILABLE"><span class="name">QML_UNAVAILABLE</span></h3>
<p>This macro declares the enclosing type to be unavailable in QML. It registers an internal dummy type called <code translate="no">QQmlTypeNotAvailable</code> as <a href="qqmlintegration-h-qtqml-proxy.html#QML_FOREIGN" translate="no">QML_FOREIGN</a>() type, using any further QML macros you specify.</p>
<p>Normally, the types exported by a module should be fixed. However, if a C++ type is not available, you should at least &quot;reserve&quot; the QML type name, and give the user of the unavailable type a meaningful error message.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="preprocessor">#ifdef NO_GAMES_ALLOWED</span>
 <span class="keyword">struct</span> MinehuntGame
 {
     Q_GADGET
     QML_NAMED_ELEMENT(Game)
     QML_UNAVAILABLE
     QML_UNCREATABLE(<span class="string">&quot;Get back to work, slacker!&quot;</span>);
 };
 <span class="preprocessor">#else</span>
 <span class="keyword">class</span> MinehuntGame : <span class="keyword">public</span> <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span>
 {
     Q_OBJECT
     QML_NAMED_ELEMENT(Game)
     <span class="comment">// ...</span>
 };
 <span class="preprocessor">#endif</span>
</pre>
<p>This will cause any QML which attempts to use the &quot;Game&quot; type to produce an error message:</p>
<pre class="cpp plain" translate="no">
 fun.qml: Get back to work, slacker!
    Game {
    ^
</pre>
<p>Using this technique, you only need a <a href="../qtcore/qobject.html#Q_GADGET" translate="no">Q_GADGET</a> struct to customize the error message, not a full-blown <a href="../qtcore/qobject.html" translate="no">QObject</a>. Without <a href="qqmlintegration-h-qtqml-proxy.html#QML_UNCREATABLE" translate="no">QML_UNCREATABLE</a>(), QML_UNAVAILABLE still results in a more specific error message than the usual &quot;is not a type&quot; for completely unknown types.</p>
<div class="admonition note">
<p><b>Note: </b>The class name needs to be fully qualified, even if you're already inside the namespace.</p>
</div>
<p><b>See also </b><a href="qqmlintegration-h-qtqml-proxy.html#QML_ELEMENT" translate="no">QML_ELEMENT</a>, <a href="qqmlintegration-h-qtqml-proxy.html#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>(), <a href="qqmlintegration-h-qtqml-proxy.html#QML_UNCREATABLE" translate="no">QML_UNCREATABLE</a>(), and <a href="qqmlintegration-h-qtqml-proxy.html#QML_FOREIGN" translate="no">QML_FOREIGN</a>().</p>
<!-- @@@QML_UNAVAILABLE -->
<!-- $$$QML_UNCREATABLE[overload1]$$$QML_UNCREATABLE -->
<h3 class="fn" translate="no" id="QML_UNCREATABLE"><span class="name">QML_UNCREATABLE</span>(<i>reason</i>)</h3>
<p>Declares that the enclosing type shall not be creatable from QML. This takes effect if the type is available in QML, by having a <a href="qqmlintegration-h-qtqml-proxy.html#QML_ELEMENT" translate="no">QML_ELEMENT</a> or <a href="qqmlintegration-h-qtqml-proxy.html#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>() macro. The <i translate="no">reason</i> will be emitted as error message if an attempt to create the type from QML is detected.</p>
<p>Some QML types are implicitly uncreatable, in particular types exposed with <a href="qqmlintegration-h-qtqml-proxy.html#QML_ANONYMOUS" translate="no">QML_ANONYMOUS</a> or namespaces exposed with <a href="qqmlintegration-h-qtqml-proxy.html#QML_ELEMENT" translate="no">QML_ELEMENT</a> or <a href="qqmlintegration-h-qtqml-proxy.html#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>().</p>
<p>Since Qt 6.0 you can use &quot;&quot; instead of a reason to use a standard message instead.</p>
<p><b>See also </b><a href="qqmlintegration-h-qtqml-proxy.html#QML_ELEMENT" translate="no">QML_ELEMENT</a>, <a href="qqmlintegration-h-qtqml-proxy.html#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>(), and <a href="qqmlintegration-h-qtqml-proxy.html#QML_ANONYMOUS" translate="no">QML_ANONYMOUS</a>.</p>
<!-- @@@QML_UNCREATABLE -->
<!-- $$$QML_VALUE_TYPE[overload1]$$$QML_VALUE_TYPE -->
<h3 class="fn" translate="no" id="QML_VALUE_TYPE"><span class="name">QML_VALUE_TYPE</span>(<i>name</i>)</h3>
<p>Declares the enclosing type or namespace to be available in QML, using <i translate="no">name</i> as the name. The type has to be a value type and the name has to be lower case.</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> MyValueType
 {
     Q_GADGET
     QML_VALUE_TYPE(myValueType)

     <span class="comment">// ...</span>
 };
</pre>
<p><b>See also </b><a href="qtqml-cppintegration-overview.html#choosing-the-correct-integration-method-between-c-and-qml">Choosing the Correct Integration Method Between C++ and QML</a> and <a href="qqmlintegration-h-qtqml-proxy.html#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>.</p>
<!-- @@@QML_VALUE_TYPE -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <abbr title="Copyright">&copy;</abbr> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
