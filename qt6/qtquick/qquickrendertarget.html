<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qquickrendertarget.cpp -->
  <meta name="description" content="The QQuickRenderTarget class provides an opaque container for native graphics resources specifying a render target, and associated metadata.">
  <title>QQuickRenderTarget Class | Qt Quick | Qt 6.9.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li>Qt 6.9</li>
<li><a href="qtquick-index.html">Qt Quick</a></li>
<li><a href="qtquick-module.html" translate="no">C++ Classes</a></li>
<li>QQuickRenderTarget</li>
<li id="buildversion"><a href="qtquick-index.html">Qt 6.9.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#static-public-members">Static Public Members</a></li>
<li class="level1"><a href="#related-non-members">Related Non-Members</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QQuickRenderTarget Class</h1>
<!-- $$$QQuickRenderTarget-brief -->
<p>The QQuickRenderTarget class provides an opaque container for native graphics resources specifying a render target, and associated metadata. <a href="#details">More...</a></p>
<!-- @@@QQuickRenderTarget -->
<div class="table"><table class="alignedsummary requisites" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign"> <code translate="no">#include &lt;QQuickRenderTarget&gt;</code></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> <code translate="no">find_package(Qt6 REQUIRED COMPONENTS Quick)</code><br/>
<code translate="no">target_link_libraries(mytarget PRIVATE Qt6::Quick)</code></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> <code translate="no">QT += quick</code></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 6.0</td></tr>
</table></div>
<ul>
<li><a href="qquickrendertarget-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.8)</code> enum class </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#Flag-enum" translate="no">Flag</a></b> { MultisampleResolve }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#Flag-enum" translate="no">Flags</a></b></td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#QQuickRenderTarget" translate="no">QQuickRenderTarget</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#dtor.QQuickRenderTarget" translate="no">~QQuickRenderTarget</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.8)</code> QRhiTexture *</td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#depthTexture" translate="no">depthTexture</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.3)</code> qreal </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#devicePixelRatio" translate="no">devicePixelRatio</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#isNull" translate="no">isNull</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#mirrorVertically" translate="no">mirrorVertically</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.8)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#setDepthTexture" translate="no">setDepthTexture</a></b>(QRhiTexture *<i>texture</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.3)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#setDevicePixelRatio" translate="no">setDevicePixelRatio</a></b>(qreal <i>ratio</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> void </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#setMirrorVertically" translate="no">setMirrorVertically</a></b>(bool <i>enable</i>)</td></tr>
</table></div>
<h2 id="static-public-members">Static Public Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> QQuickRenderTarget </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#fromD3D11Texture" translate="no">fromD3D11Texture</a></b>(void *<i>texture</i>, uint <i>format</i>, const QSize &amp;<i>pixelSize</i>, int <i>sampleCount</i> = 1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQuickRenderTarget </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#fromD3D11Texture-1" translate="no">fromD3D11Texture</a></b>(void *<i>texture</i>, const QSize &amp;<i>pixelSize</i>, int <i>sampleCount</i> = 1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.8)</code> QQuickRenderTarget </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#fromD3D11Texture-2" translate="no">fromD3D11Texture</a></b>(void *<i>texture</i>, uint <i>format</i>, QSize <i>pixelSize</i>, int <i>sampleCount</i>, QQuickRenderTarget::Flags <i>flags</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> QQuickRenderTarget </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#fromD3D12Texture" translate="no">fromD3D12Texture</a></b>(void *<i>texture</i>, int <i>resourceState</i>, uint <i>format</i>, const QSize &amp;<i>pixelSize</i>, int <i>sampleCount</i> = 1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.8)</code> QQuickRenderTarget </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#fromD3D12Texture-1" translate="no">fromD3D12Texture</a></b>(void *<i>texture</i>, int <i>resourceState</i>, uint <i>format</i>, uint <i>viewFormat</i>, QSize <i>pixelSize</i>, int <i>sampleCount</i>, int <i>arraySize</i>, QQuickRenderTarget::Flags <i>flags</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> QQuickRenderTarget </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#fromMetalTexture" translate="no">fromMetalTexture</a></b>(MTLTexture *<i>texture</i>, uint <i>format</i>, const QSize &amp;<i>pixelSize</i>, int <i>sampleCount</i> = 1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQuickRenderTarget </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#fromMetalTexture-1" translate="no">fromMetalTexture</a></b>(MTLTexture *<i>texture</i>, const QSize &amp;<i>pixelSize</i>, int <i>sampleCount</i> = 1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.8)</code> QQuickRenderTarget </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#fromMetalTexture-2" translate="no">fromMetalTexture</a></b>(MTLTexture *<i>texture</i>, uint <i>format</i>, uint <i>viewFormat</i>, QSize <i>pixelSize</i>, int <i>sampleCount</i>, int <i>arraySize</i>, QQuickRenderTarget::Flags <i>flags</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.2)</code> QQuickRenderTarget </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#fromOpenGLRenderBuffer" translate="no">fromOpenGLRenderBuffer</a></b>(uint <i>renderbufferId</i>, const QSize &amp;<i>pixelSize</i>, int <i>sampleCount</i> = 1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> QQuickRenderTarget </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#fromOpenGLTexture" translate="no">fromOpenGLTexture</a></b>(uint <i>textureId</i>, uint <i>format</i>, const QSize &amp;<i>pixelSize</i>, int <i>sampleCount</i> = 1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQuickRenderTarget </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#fromOpenGLTexture-1" translate="no">fromOpenGLTexture</a></b>(uint <i>textureId</i>, const QSize &amp;<i>pixelSize</i>, int <i>sampleCount</i> = 1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.8)</code> QQuickRenderTarget </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#fromOpenGLTexture-2" translate="no">fromOpenGLTexture</a></b>(uint <i>textureId</i>, uint <i>format</i>, QSize <i>pixelSize</i>, int <i>sampleCount</i>, int <i>arraySize</i>, QQuickRenderTarget::Flags <i>flags</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> QQuickRenderTarget </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#fromPaintDevice" translate="no">fromPaintDevice</a></b>(QPaintDevice *<i>device</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.6)</code> QQuickRenderTarget </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#fromRhiRenderTarget" translate="no">fromRhiRenderTarget</a></b>(QRhiRenderTarget *<i>renderTarget</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.4)</code> QQuickRenderTarget </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#fromVulkanImage" translate="no">fromVulkanImage</a></b>(VkImage <i>image</i>, VkImageLayout <i>layout</i>, VkFormat <i>format</i>, const QSize &amp;<i>pixelSize</i>, int <i>sampleCount</i> = 1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQuickRenderTarget </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#fromVulkanImage-1" translate="no">fromVulkanImage</a></b>(VkImage <i>image</i>, VkImageLayout <i>layout</i>, const QSize &amp;<i>pixelSize</i>, int <i>sampleCount</i> = 1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> <code class="summary extra" translate="no">(since 6.8)</code> QQuickRenderTarget </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#fromVulkanImage-2" translate="no">fromVulkanImage</a></b>(VkImage <i>image</i>, VkImageLayout <i>layout</i>, VkFormat <i>format</i>, VkFormat <i>viewFormat</i>, QSize <i>pixelSize</i>, int <i>sampleCount</i>, int <i>arraySize</i>, QQuickRenderTarget::Flags <i>flags</i>)</td></tr>
</table></div>
<h2 id="related-non-members">Related Non-Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#operator-not-eq" translate="no">operator!=</a></b>(const QQuickRenderTarget &amp;<i>a</i>, const QQuickRenderTarget &amp;<i>b</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickrendertarget.html#operator-eq-eq" translate="no">operator==</a></b>(const QQuickRenderTarget &amp;<i>a</i>, const QQuickRenderTarget &amp;<i>b</i>)</td></tr>
</table></div>
<!-- $$$QQuickRenderTarget-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
</div>
<p><b>See also </b><a href="qquickwindow.html#setRenderTarget" translate="no">QQuickWindow::setRenderTarget</a>() and <a href="qquickgraphicsdevice.html" translate="no">QQuickGraphicsDevice</a>.</p>
<!-- @@@QQuickRenderTarget -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$Flag$$$MultisampleResolve -->
<h3 class="flags" id="Flag-enum"><code class="details extra" translate="no">[since 6.8]</code> enum class QQuickRenderTarget::<span class="name">Flag</span><br/>flags QQuickRenderTarget::<span class="name">Flags</span></h3>
<p>Flags for the static <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> constructor functions.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QQuickRenderTarget::Flag::MultisampleResolve</code></td><td class="topAlign tblval"><code translate="no">0x01</code></td><td class="topAlign">Indicates that the <code translate="no">sampleCount</code> argument is not the number of samples for the provided texture (and that the texture is still a non-multisample texture), but rather the desired samples for multisample antialiasing. Triggers automatically creating and managing an intermediate multisample texture (or texture array) as the color buffer, transparently to the application. The samples are resolved into the provided texture at the end of the render pass automatically. When this flag is not set, and the <code translate="no">sampleCount</code> argument is greater than 1, it implies the provided texture is multisample. The flag has no effect is the <code translate="no">sampleCount</code> is 1 (indicating that multisampling is not involved).</td></tr>
</table></div>
<p>This enum was introduced in Qt 6.8.</p>
<p>The Flags type is a typedef for <a href="../qtcore/qflags.html">QFlags</a>&lt;Flag&gt;. It stores an OR combination of Flag values.</p>
<!-- @@@Flag -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QQuickRenderTarget[overload1]$$$QQuickRenderTarget -->
<h3 class="fn" translate="no" id="QQuickRenderTarget">QQuickRenderTarget::<span class="name">QQuickRenderTarget</span>()</h3>
<p>Constructs a default QQuickRenderTarget that does not reference any native objects.</p>
<!-- @@@QQuickRenderTarget -->
<!-- $$$~QQuickRenderTarget[overload1]$$$~QQuickRenderTarget -->
<h3 class="fn" translate="no" id="dtor.QQuickRenderTarget"><code class="details extra" translate="no">[noexcept]</code> QQuickRenderTarget::<span class="name">~QQuickRenderTarget</span>()</h3>
<p>Destructor.</p>
<!-- @@@~QQuickRenderTarget -->
<!-- $$$depthTexture[overload1]$$$depthTexture -->
<h3 class="fn" translate="no" id="depthTexture"><code class="details extra" translate="no">[since 6.8]</code> <span class="type"><a href="../qtgui/qrhitexture.html" translate="no">QRhiTexture</a></span> *QQuickRenderTarget::<span class="name">depthTexture</span>() const</h3>
<p>Returns the currently set depth texture or, in most cases, <code translate="no">nullptr</code>.</p>
<p>The value is only non-null when <a href="qquickrendertarget.html#setDepthTexture" translate="no">setDepthTexture</a>() was called.</p>
<p>This function was introduced in Qt 6.8.</p>
<p><b>See also </b><a href="qquickrendertarget.html#setDepthTexture" translate="no">setDepthTexture</a>().</p>
<!-- @@@depthTexture -->
<!-- $$$devicePixelRatio[overload1]$$$devicePixelRatio -->
<h3 class="fn" translate="no" id="devicePixelRatio"><code class="details extra" translate="no">[since 6.3]</code> <span class="type"><a href="../qtcore/qttypes.html#qreal-typedef" translate="no">qreal</a></span> QQuickRenderTarget::<span class="name">devicePixelRatio</span>() const</h3>
<p>Returns the device pixel ratio for the render target. This is the ratio between <i>device pixels</i> and <i>device independent pixels</i>.</p>
<p>The default device pixel ratio is 1.0.</p>
<p>This function was introduced in Qt 6.3.</p>
<p><b>See also </b><a href="qquickrendertarget.html#setDevicePixelRatio" translate="no">setDevicePixelRatio</a>().</p>
<!-- @@@devicePixelRatio -->
<!-- $$$fromD3D11Texture[overload1]$$$fromD3D11Texturevoid*uintconstQSize&int -->
<h3 class="fn" translate="no" id="fromD3D11Texture"><code class="details extra" translate="no">[static, since 6.4]</code> <span class="type"><a href="qquickrendertarget.html#QQuickRenderTarget" translate="no">QQuickRenderTarget</a></span> QQuickRenderTarget::<span class="name">fromD3D11Texture</span>(<span class="type">void</span> *<i>texture</i>, <span class="type"><a href="../qtcore/qttypes.html#uint-typedef" translate="no">uint</a></span> <i>format</i>, const <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> &amp;<i>pixelSize</i>, <span class="type">int</span> <i>sampleCount</i> = 1)</h3>
<p>Returns a new <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> referencing a D3D11 texture object specified by <i translate="no">texture</i>.</p>
<p><i translate="no">format</i> specifies the DXGI_FORMAT of the texture. Only texture formats that are supported by Qt's rendering infrastructure should be used.</p>
<p><i translate="no">pixelSize</i> specifies the size of the image, in pixels. Currently only 2D textures are supported.</p>
<p><i translate="no">sampleCount</i> specifies the number of samples. 0 or 1 means no multisampling, while a value like 4 or 8 states that the native object is a multisample texture.</p>
<p>The texture is used as the first color attachment of the render target used by the Qt Quick scenegraph. A depth-stencil buffer, if applicable, is created and used automatically.</p>
<div class="admonition note">
<p><b>Note: </b>the resulting <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> does not own any native resources, it merely contains references and the associated metadata of the size and sample count. It is the caller's responsibility to ensure that the native resource exists as long as necessary.</p>
</div>
<p>This function was introduced in Qt 6.4.</p>
<p><b>See also </b><a href="qquickwindow.html#setRenderTarget" translate="no">QQuickWindow::setRenderTarget</a>() and <a href="qquickrendercontrol.html" translate="no">QQuickRenderControl</a>.</p>
<!-- @@@fromD3D11Texture -->
<!-- $$$fromD3D11Texture$$$fromD3D11Texturevoid*constQSize&int -->
<h3 class="fn" translate="no" id="fromD3D11Texture-1"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qquickrendertarget.html#QQuickRenderTarget" translate="no">QQuickRenderTarget</a></span> QQuickRenderTarget::<span class="name">fromD3D11Texture</span>(<span class="type">void</span> *<i>texture</i>, const <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> &amp;<i>pixelSize</i>, <span class="type">int</span> <i>sampleCount</i> = 1)</h3>
<p>This is an overloaded function.</p>
<p>Returns a new <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> referencing a D3D11 texture object specified by <i translate="no">texture</i>. The texture is assumed to have a format of DXGI_FORMAT_R8G8B8A8_UNORM.</p>
<p><i translate="no">pixelSize</i> specifies the size of the image, in pixels. Currently only 2D textures are supported.</p>
<p><i translate="no">sampleCount</i> specifies the number of samples. 0 or 1 means no multisampling, while a value like 4 or 8 states that the native object is a multisample texture.</p>
<p>The texture is used as the first color attachment of the render target used by the Qt Quick scenegraph. A depth-stencil buffer, if applicable, is created and used automatically.</p>
<div class="admonition note">
<p><b>Note: </b>the resulting <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> does not own any native resources, it merely contains references and the associated metadata of the size and sample count. It is the caller's responsibility to ensure that the native resource exists as long as necessary.</p>
</div>
<p><b>See also </b><a href="qquickwindow.html#setRenderTarget" translate="no">QQuickWindow::setRenderTarget</a>() and <a href="qquickrendercontrol.html" translate="no">QQuickRenderControl</a>.</p>
<!-- @@@fromD3D11Texture -->
<!-- $$$fromD3D11Texture$$$fromD3D11Texturevoid*uintQSizeintQQuickRenderTarget::Flags -->
<h3 class="fn" translate="no" id="fromD3D11Texture-2"><code class="details extra" translate="no">[static, since 6.8]</code> <span class="type"><a href="qquickrendertarget.html#QQuickRenderTarget" translate="no">QQuickRenderTarget</a></span> QQuickRenderTarget::<span class="name">fromD3D11Texture</span>(<span class="type">void</span> *<i>texture</i>, <span class="type"><a href="../qtcore/qttypes.html#uint-typedef" translate="no">uint</a></span> <i>format</i>, <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> <i>pixelSize</i>, <span class="type">int</span> <i>sampleCount</i>, <span class="type"><a href="qquickrendertarget.html#Flag-enum" translate="no">QQuickRenderTarget::Flags</a></span> <i>flags</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a new <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> referencing a D3D11 texture object specified by <i translate="no">texture</i>.</p>
<p><i translate="no">format</i> specifies the DXGI_FORMAT of the texture. Only texture formats that are supported by Qt's rendering infrastructure should be used.</p>
<p><i translate="no">pixelSize</i> specifies the size of the image, in pixels. Currently only 2D textures are supported.</p>
<p><i translate="no">sampleCount</i> specifies the number of samples. 0 or 1 means no multisampling, while a value like 4 or 8 states that the native object is a multisample texture, except when <i translate="no">flags</i> contains <a href="qquickrendertarget.html#Flag-enum" translate="no">MultisampleResolve</a>. In that case, <i translate="no">texture</i> is assumed to be a non-multisample 2D texture and <i translate="no">sampleCount</i> defines the number of samples desired. The resulting <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> will use an intermediate, automatically created multisample texture as its color attachment, and will resolve the samples into <i translate="no">texture</i>. This is the recommended approach to perform MSAA when the native texture is not already multisample.</p>
<p>The texture is used as the first color attachment of the render target used by the Qt Quick scenegraph. A depth-stencil buffer, if applicable, is created and used automatically. When the color buffer is multisample, the depth-stencil buffer will automatically be multisample too.</p>
<div class="admonition note">
<p><b>Note: </b>the resulting <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> does not own any native resources, it merely contains references and the associated metadata of the size and sample count. It is the caller's responsibility to ensure that the native resource exists as long as necessary.</p>
</div>
<p>This function was introduced in Qt 6.8.</p>
<p><b>See also </b><a href="qquickwindow.html#setRenderTarget" translate="no">QQuickWindow::setRenderTarget</a>(), <a href="qquickrendercontrol.html" translate="no">QQuickRenderControl</a>, and <a href="qquickrendertarget.html#fromD3D11Texture" translate="no">fromD3D11Texture</a>().</p>
<!-- @@@fromD3D11Texture -->
<!-- $$$fromD3D12Texture[overload1]$$$fromD3D12Texturevoid*intuintconstQSize&int -->
<h3 class="fn" translate="no" id="fromD3D12Texture"><code class="details extra" translate="no">[static, since 6.6]</code> <span class="type"><a href="qquickrendertarget.html#QQuickRenderTarget" translate="no">QQuickRenderTarget</a></span> QQuickRenderTarget::<span class="name">fromD3D12Texture</span>(<span class="type">void</span> *<i>texture</i>, <span class="type">int</span> <i>resourceState</i>, <span class="type"><a href="../qtcore/qttypes.html#uint-typedef" translate="no">uint</a></span> <i>format</i>, const <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> &amp;<i>pixelSize</i>, <span class="type">int</span> <i>sampleCount</i> = 1)</h3>
<p>Returns a new <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> referencing a D3D12 texture object specified by <i translate="no">texture</i>.</p>
<p><i translate="no">resourceState</i> must a valid bitmask with bits from D3D12_RESOURCE_STATES, specifying the resource's current state.</p>
<p><i translate="no">format</i> specifies the DXGI_FORMAT of the texture. Only texture formats that are supported by Qt's rendering infrastructure should be used.</p>
<p><i translate="no">pixelSize</i> specifies the size of the image, in pixels. Currently only 2D textures are supported.</p>
<p><i translate="no">sampleCount</i> specifies the number of samples. 0 or 1 means no multisampling, while a value like 4 or 8 states that the native object is a multisample texture.</p>
<p>The texture is used as the first color attachment of the render target used by the Qt Quick scenegraph. A depth-stencil buffer, if applicable, is created and used automatically.</p>
<div class="admonition note">
<p><b>Note: </b>the resulting <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> does not own any native resources, it merely contains references and the associated metadata of the size and sample count. It is the caller's responsibility to ensure that the native resource exists as long as necessary.</p>
</div>
<p>This function was introduced in Qt 6.6.</p>
<p><b>See also </b><a href="qquickwindow.html#setRenderTarget" translate="no">QQuickWindow::setRenderTarget</a>() and <a href="qquickrendercontrol.html" translate="no">QQuickRenderControl</a>.</p>
<!-- @@@fromD3D12Texture -->
<!-- $$$fromD3D12Texture$$$fromD3D12Texturevoid*intuintuintQSizeintintQQuickRenderTarget::Flags -->
<h3 class="fn" translate="no" id="fromD3D12Texture-1"><code class="details extra" translate="no">[static, since 6.8]</code> <span class="type"><a href="qquickrendertarget.html#QQuickRenderTarget" translate="no">QQuickRenderTarget</a></span> QQuickRenderTarget::<span class="name">fromD3D12Texture</span>(<span class="type">void</span> *<i>texture</i>, <span class="type">int</span> <i>resourceState</i>, <span class="type"><a href="../qtcore/qttypes.html#uint-typedef" translate="no">uint</a></span> <i>format</i>, <span class="type"><a href="../qtcore/qttypes.html#uint-typedef" translate="no">uint</a></span> <i>viewFormat</i>, <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> <i>pixelSize</i>, <span class="type">int</span> <i>sampleCount</i>, <span class="type">int</span> <i>arraySize</i>, <span class="type"><a href="qquickrendertarget.html#Flag-enum" translate="no">QQuickRenderTarget::Flags</a></span> <i>flags</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a new <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> referencing a D3D12 2D texture or 2D texture array object specified by <i translate="no">texture</i>.</p>
<p><i translate="no">resourceState</i> must a valid bitmask with bits from D3D12_RESOURCE_STATES, specifying the resource's current state.</p>
<p><i translate="no">format</i> specifies the DXGI_FORMAT of the texture. Only texture formats that are supported by Qt's rendering infrastructure should be used.</p>
<p><i translate="no">viewFormat</i> is the DXGI_FORMAT used for the render target view (RTV). Often the same as <i translate="no">format</i>. Functional only when <a href="https://microsoft.github.io/DirectX-Specs/d3d/RelaxedCasting.html">relaxed format casting</a> is supported by the driver, the argument is ignored otherwise. In practice support is expected to be always available on Windows 10 1703 and newer.</p>
<p><i translate="no">pixelSize</i> specifies the size of the image, in pixels. Currently only 2D textures and 2D texture arrays are supported.</p>
<p><i translate="no">sampleCount</i> specifies the number of samples. 0 or 1 means no multisampling, while a value like 4 or 8 states that the native object is a multisample texture, except when <i translate="no">flags</i> contains <a href="qquickrendertarget.html#Flag-enum" translate="no">MultisampleResolve</a>. In that case, <i translate="no">texture</i> is assumed to be a non-multisample 2D texture or 2D texture array, and <i translate="no">sampleCount</i> defines the number of samples desired. The resulting <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> will use an intermediate, automatically created multisample texture (or texture array) as its color attachment, and will resolve the samples into <i translate="no">texture</i>. This is the recommended approach to perform MSAA when the native D3D12 texture is not already multisample.</p>
<p>The number of array elements (layers) is given in <i translate="no">arraySize</i>. When greater than 1, it implies multiview rendering (<a href="https://microsoft.github.io/DirectX-Specs/d3d/ViewInstancing.html">view instancing</a>), which can be relevant with VR/AR especially. <i translate="no">arraySize</i> is the number of views, typically <code translate="no">2</code>. See <a href="qsgmaterial.html#viewCount" translate="no">QSGMaterial::viewCount</a>() for details on enabling multiview rendering within the Qt Quick scenegraph.</p>
<p>The texture is used as the first color attachment of the render target used by the Qt Quick scenegraph. A depth-stencil buffer, if applicable, is created and used automatically. When the color buffer is multisample, the depth-stencil buffer will automatically be multisample too. For multiview rendering, the depth-stencil texture will automatically be made an array with a matching <i translate="no">arraySize</i>.</p>
<div class="admonition note">
<p><b>Note: </b>the resulting <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> does not own any native resources, it merely contains references and the associated metadata of the size and sample count. It is the caller's responsibility to ensure that the native resource exists as long as necessary.</p>
</div>
<p>This function was introduced in Qt 6.8.</p>
<p><b>See also </b><a href="qquickwindow.html#setRenderTarget" translate="no">QQuickWindow::setRenderTarget</a>() and <a href="qquickrendercontrol.html" translate="no">QQuickRenderControl</a>.</p>
<!-- @@@fromD3D12Texture -->
<!-- $$$fromMetalTexture[overload1]$$$fromMetalTextureMTLTexture*uintconstQSize&int -->
<h3 class="fn" translate="no" id="fromMetalTexture"><code class="details extra" translate="no">[static, since 6.4]</code> <span class="type"><a href="qquickrendertarget.html#QQuickRenderTarget" translate="no">QQuickRenderTarget</a></span> QQuickRenderTarget::<span class="name">fromMetalTexture</span>(<span class="type">MTLTexture</span> *<i>texture</i>, <span class="type"><a href="../qtcore/qttypes.html#uint-typedef" translate="no">uint</a></span> <i>format</i>, const <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> &amp;<i>pixelSize</i>, <span class="type">int</span> <i>sampleCount</i> = 1)</h3>
<p>Returns a new <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> referencing a Metal texture object specified by <i translate="no">texture</i>.</p>
<p><i translate="no">format</i> specifies the MTLPixelFormat of the texture. Only texture formats that are supported by Qt's rendering infrastructure should be used.</p>
<p><i translate="no">pixelSize</i> specifies the size of the image, in pixels. Currently only 2D textures are supported.</p>
<p><i translate="no">sampleCount</i> specifies the number of samples. 0 or 1 means no multisampling, while a value like 4 or 8 states that the native object is a multisample texture.</p>
<p>The texture is used as the first color attachment of the render target used by the Qt Quick scenegraph. A depth-stencil buffer, if applicable, is created and used automatically.</p>
<div class="admonition note">
<p><b>Note: </b>the resulting <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> does not own any native resources, it merely contains references and the associated metadata of the size and sample count. It is the caller's responsibility to ensure that the native resource exists as long as necessary.</p>
</div>
<p>This function was introduced in Qt 6.4.</p>
<p><b>See also </b><a href="qquickwindow.html#setRenderTarget" translate="no">QQuickWindow::setRenderTarget</a>() and <a href="qquickrendercontrol.html" translate="no">QQuickRenderControl</a>.</p>
<!-- @@@fromMetalTexture -->
<!-- $$$fromMetalTexture$$$fromMetalTextureMTLTexture*constQSize&int -->
<h3 class="fn" translate="no" id="fromMetalTexture-1"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qquickrendertarget.html#QQuickRenderTarget" translate="no">QQuickRenderTarget</a></span> QQuickRenderTarget::<span class="name">fromMetalTexture</span>(<span class="type">MTLTexture</span> *<i>texture</i>, const <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> &amp;<i>pixelSize</i>, <span class="type">int</span> <i>sampleCount</i> = 1)</h3>
<p>This is an overloaded function.</p>
<p>Returns a new <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> referencing a Metal texture object specified by <i translate="no">texture</i>. The texture is assumed to have a format of MTLPixelFormatRGBA8Unorm.</p>
<p><i translate="no">pixelSize</i> specifies the size of the image, in pixels. Currently only 2D textures are supported.</p>
<p><i translate="no">sampleCount</i> specifies the number of samples. 0 or 1 means no multisampling, while a value like 4 or 8 states that the native object is a multisample texture.</p>
<p>The texture is used as the first color attachment of the render target used by the Qt Quick scenegraph. A depth-stencil buffer, if applicable, is created and used automatically.</p>
<div class="admonition note">
<p><b>Note: </b>the resulting <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> does not own any native resources, it merely contains references and the associated metadata of the size and sample count. It is the caller's responsibility to ensure that the native resource exists as long as necessary.</p>
</div>
<p><b>See also </b><a href="qquickwindow.html#setRenderTarget" translate="no">QQuickWindow::setRenderTarget</a>() and <a href="qquickrendercontrol.html" translate="no">QQuickRenderControl</a>.</p>
<!-- @@@fromMetalTexture -->
<!-- $$$fromMetalTexture$$$fromMetalTextureMTLTexture*uintuintQSizeintintQQuickRenderTarget::Flags -->
<h3 class="fn" translate="no" id="fromMetalTexture-2"><code class="details extra" translate="no">[static, since 6.8]</code> <span class="type"><a href="qquickrendertarget.html#QQuickRenderTarget" translate="no">QQuickRenderTarget</a></span> QQuickRenderTarget::<span class="name">fromMetalTexture</span>(<span class="type">MTLTexture</span> *<i>texture</i>, <span class="type"><a href="../qtcore/qttypes.html#uint-typedef" translate="no">uint</a></span> <i>format</i>, <span class="type"><a href="../qtcore/qttypes.html#uint-typedef" translate="no">uint</a></span> <i>viewFormat</i>, <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> <i>pixelSize</i>, <span class="type">int</span> <i>sampleCount</i>, <span class="type">int</span> <i>arraySize</i>, <span class="type"><a href="qquickrendertarget.html#Flag-enum" translate="no">QQuickRenderTarget::Flags</a></span> <i>flags</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a new <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> referencing a Metal 2D texture or 2D texture array given in <i translate="no">texture</i>.</p>
<p><i translate="no">format</i> specifies the MTLPixelFormat of the texture. Only texture formats that are supported by Qt's rendering infrastructure should be used.</p>
<p><i translate="no">viewFormat</i> is usually set to the same value as <i translate="no">format</i>. In some cases, such as when rendering into a texture with a <code translate="no">_SRGB</code> format and the implicit linear-&gt;sRGB conversion on shader writes is not wanted, the value can be different. Note however that the value may be ignored by Qt, when at run time <a href="../qtgui/qrhi.html" translate="no">QRhi</a> reports that the <a href="../qtgui/qrhi.html#Feature-enum" translate="no">QRhi::TextureViewFormat</a> feature is unsupported.</p>
<p><i translate="no">pixelSize</i> specifies the size of the image, in pixels. Currently only 2D textures and 2D texture arrays are supported.</p>
<p><i translate="no">sampleCount</i> specifies the number of samples. 0 or 1 means no multisampling, while a value like 4 or 8 states that the native object is a multisample texture, except when <i translate="no">flags</i> contains <a href="qquickrendertarget.html#Flag-enum" translate="no">MultisampleResolve</a>. In that case, <i translate="no">texture</i> is assumed to be a non-multisample 2D texture or 2D texture array, and <i translate="no">sampleCount</i> defines the number of samples desired. The resulting <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> will use an intermediate, automatically created multisample texture (or texture array) as its color attachment, and will resolve the samples into <i translate="no">texture</i>. This is the recommended approach to perform MSAA when the native Metal texture is not already multisample.</p>
<p>The number of array elements (layers) is given in <i translate="no">arraySize</i>. When greater than 1, it implies multiview rendering, which can be relevant with VR/AR especially. <i translate="no">arraySize</i> is the number of views, typically <code translate="no">2</code>. See <a href="qsgmaterial.html#viewCount" translate="no">QSGMaterial::viewCount</a>() for details on enabling multiview rendering within the Qt Quick scenegraph.</p>
<p>The texture is used as the first color attachment of the render target used by the Qt Quick scenegraph. A depth-stencil buffer, if applicable, is created and used automatically. When the color buffer is multisample, the depth-stencil buffer will automatically be multisample too. For multiview rendering, the depth-stencil texture will automatically be made an array with a matching <i translate="no">arraySize</i>.</p>
<div class="admonition note">
<p><b>Note: </b>the resulting <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> does not own any native resources, it merely contains references and the associated metadata of the size and sample count. It is the caller's responsibility to ensure that the native resource exists as long as necessary.</p>
</div>
<p>This function was introduced in Qt 6.8.</p>
<p><b>See also </b><a href="qquickwindow.html#setRenderTarget" translate="no">QQuickWindow::setRenderTarget</a>() and <a href="qquickrendercontrol.html" translate="no">QQuickRenderControl</a>.</p>
<!-- @@@fromMetalTexture -->
<!-- $$$fromOpenGLRenderBuffer[overload1]$$$fromOpenGLRenderBufferuintconstQSize&int -->
<h3 class="fn" translate="no" id="fromOpenGLRenderBuffer"><code class="details extra" translate="no">[static, since 6.2]</code> <span class="type"><a href="qquickrendertarget.html#QQuickRenderTarget" translate="no">QQuickRenderTarget</a></span> QQuickRenderTarget::<span class="name">fromOpenGLRenderBuffer</span>(<span class="type"><a href="../qtcore/qttypes.html#uint-typedef" translate="no">uint</a></span> <i>renderbufferId</i>, const <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> &amp;<i>pixelSize</i>, <span class="type">int</span> <i>sampleCount</i> = 1)</h3>
<p>Returns a new <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> referencing an OpenGL renderbuffer object specified by <i translate="no">renderbufferId</i>.</p>
<p>The renderbuffer will be used as the color attachment for the internal framebuffer object. This function is provided to allow targeting renderbuffers that are created by the application with some external buffer underneath, such as an EGLImageKHR. Once the application has called <a href="https://www.khronos.org/registry/OpenGL/extensions/OES/OES_EGL_image.txt">glEGLImageTargetRenderbufferStorageOES</a>, the renderbuffer can be passed to this function.</p>
<p><i translate="no">pixelSize</i> specifies the size of the image, in pixels.</p>
<p><i translate="no">sampleCount</i> specifies the number of samples. 0 or 1 means no multisampling, while a value like 4 or 8 states that the native object is a multisample renderbuffer.</p>
<div class="admonition note">
<p><b>Note: </b>the resulting <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> does not own any native resources, it merely contains references and the associated metadata of the size and sample count. It is the caller's responsibility to ensure that the native resource exists as long as necessary.</p>
</div>
<p>This function was introduced in Qt 6.2.</p>
<p><b>See also </b><a href="qquickwindow.html#setRenderTarget" translate="no">QQuickWindow::setRenderTarget</a>() and <a href="qquickrendercontrol.html" translate="no">QQuickRenderControl</a>.</p>
<!-- @@@fromOpenGLRenderBuffer -->
<!-- $$$fromOpenGLTexture[overload1]$$$fromOpenGLTextureuintuintconstQSize&int -->
<h3 class="fn" translate="no" id="fromOpenGLTexture"><code class="details extra" translate="no">[static, since 6.4]</code> <span class="type"><a href="qquickrendertarget.html#QQuickRenderTarget" translate="no">QQuickRenderTarget</a></span> QQuickRenderTarget::<span class="name">fromOpenGLTexture</span>(<span class="type"><a href="../qtcore/qttypes.html#uint-typedef" translate="no">uint</a></span> <i>textureId</i>, <span class="type"><a href="../qtcore/qttypes.html#uint-typedef" translate="no">uint</a></span> <i>format</i>, const <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> &amp;<i>pixelSize</i>, <span class="type">int</span> <i>sampleCount</i> = 1)</h3>
<p>Returns a new <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> referencing an OpenGL texture object specified by <i translate="no">textureId</i>.</p>
<p><i translate="no">format</i> specifies the native internal format of the texture. Only texture formats that are supported by Qt's rendering infrastructure should be used.</p>
<p><i translate="no">pixelSize</i> specifies the size of the image, in pixels. Currently only 2D textures are supported.</p>
<p><i translate="no">sampleCount</i> specifies the number of samples. 0 or 1 means no multisampling, while a value like 4 or 8 states that the native object is a multisample texture.</p>
<p>The texture is used as the first color attachment of the render target used by the Qt Quick scenegraph. A depth-stencil buffer, if applicable, is created and used automatically.</p>
<p>The OpenGL object name <i translate="no">textureId</i> must be a valid name in the rendering context used by the Qt Quick scenegraph.</p>
<div class="admonition note">
<p><b>Note: </b>the resulting <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> does not own any native resources, it merely contains references and the associated metadata of the size and sample count. It is the caller's responsibility to ensure that the native resource exists as long as necessary.</p>
</div>
<p>This function was introduced in Qt 6.4.</p>
<p><b>See also </b><a href="qquickwindow.html#setRenderTarget" translate="no">QQuickWindow::setRenderTarget</a>() and <a href="qquickrendercontrol.html" translate="no">QQuickRenderControl</a>.</p>
<!-- @@@fromOpenGLTexture -->
<!-- $$$fromOpenGLTexture$$$fromOpenGLTextureuintconstQSize&int -->
<h3 class="fn" translate="no" id="fromOpenGLTexture-1"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qquickrendertarget.html#QQuickRenderTarget" translate="no">QQuickRenderTarget</a></span> QQuickRenderTarget::<span class="name">fromOpenGLTexture</span>(<span class="type"><a href="../qtcore/qttypes.html#uint-typedef" translate="no">uint</a></span> <i>textureId</i>, const <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> &amp;<i>pixelSize</i>, <span class="type">int</span> <i>sampleCount</i> = 1)</h3>
<p>This is an overloaded function.</p>
<p>Returns a new <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> referencing an OpenGL texture object specified by <i translate="no">textureId</i>. The texture is assumed to have a format of GL_RGBA (GL_RGBA8).</p>
<p><i translate="no">pixelSize</i> specifies the size of the image, in pixels. Currently only 2D textures are supported.</p>
<p><i translate="no">sampleCount</i> specifies the number of samples. 0 or 1 means no multisampling, while a value like 4 or 8 states that the native object is a multisample texture.</p>
<p>The texture is used as the first color attachment of the render target used by the Qt Quick scenegraph. A depth-stencil buffer, if applicable, is created and used automatically.</p>
<p>The OpenGL object name <i translate="no">textureId</i> must be a valid name in the rendering context used by the Qt Quick scenegraph.</p>
<div class="admonition note">
<p><b>Note: </b>the resulting <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> does not own any native resources, it merely contains references and the associated metadata of the size and sample count. It is the caller's responsibility to ensure that the native resource exists as long as necessary.</p>
</div>
<p><b>See also </b><a href="qquickwindow.html#setRenderTarget" translate="no">QQuickWindow::setRenderTarget</a>() and <a href="qquickrendercontrol.html" translate="no">QQuickRenderControl</a>.</p>
<!-- @@@fromOpenGLTexture -->
<!-- $$$fromOpenGLTexture$$$fromOpenGLTextureuintuintQSizeintintQQuickRenderTarget::Flags -->
<h3 class="fn" translate="no" id="fromOpenGLTexture-2"><code class="details extra" translate="no">[static, since 6.8]</code> <span class="type"><a href="qquickrendertarget.html#QQuickRenderTarget" translate="no">QQuickRenderTarget</a></span> QQuickRenderTarget::<span class="name">fromOpenGLTexture</span>(<span class="type"><a href="../qtcore/qttypes.html#uint-typedef" translate="no">uint</a></span> <i>textureId</i>, <span class="type"><a href="../qtcore/qttypes.html#uint-typedef" translate="no">uint</a></span> <i>format</i>, <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> <i>pixelSize</i>, <span class="type">int</span> <i>sampleCount</i>, <span class="type">int</span> <i>arraySize</i>, <span class="type"><a href="qquickrendertarget.html#Flag-enum" translate="no">QQuickRenderTarget::Flags</a></span> <i>flags</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a new <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> referencing an OpenGL 2D texture or texture array object specified by <i translate="no">textureId</i>.</p>
<p><i translate="no">format</i> specifies the native internal format of the texture. Only texture formats that are supported by Qt's rendering infrastructure should be used.</p>
<p><i translate="no">pixelSize</i> specifies the size of the image, in pixels. Currently only 2D textures and 2D texture arrays are supported.</p>
<p><i translate="no">sampleCount</i> specifies the number of samples. 0 or 1 means no multisampling, while a value like 4 or 8 states that the native object is a multisample texture, except when <i translate="no">flags</i> contains <a href="qquickrendertarget.html#Flag-enum" translate="no">MultisampleResolve</a>. In that case, <i translate="no">textureId</i> is assumed to be a non-multisample 2D texture or 2D texture array, and <i translate="no">sampleCount</i> defines the number of samples desired. The resulting <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> will use an intermediate, automatically created multisample texture (or texture array) as its color attachment, and will resolve the samples into <i translate="no">textureId</i>. This is the recommended approach to perform MSAA when the native OpenGL texture is not already multisample.</p>
<p>When <i translate="no">arraySize</i> is greater than 1, it implies multiview rendering (<a href="https://registry.khronos.org/OpenGL/extensions/OVR/OVR_multiview.txt">GL_OVR_multiview</a>, <a href="../qtgui/qrhicolorattachment.html#setMultiViewCount" translate="no">QRhiColorAttachment::setMultiViewCount</a>()), which can be relevant with VR/AR especially. In this case <i translate="no">arraySize</i> is the number of views, typically <code translate="no">2</code>. See <a href="qsgmaterial.html#viewCount" translate="no">QSGMaterial::viewCount</a>() for details on enabling multiview rendering within the Qt Quick scenegraph.</p>
<p>A depth-stencil buffer, if applicable, is created and used automatically. When the color buffer is multisample, the depth-stencil buffer will automatically be multisample too. For multiview rendering, the depth-stencil texture will automatically be made an array with a matching <i translate="no">arraySize</i>.</p>
<p>The OpenGL object name <i translate="no">textureId</i> must be a valid 2D texture name in the rendering context used by the Qt Quick scenegraph. When <i translate="no">arraySize</i> is greater than 1, <i translate="no">textureId</i> must be a valid 2D texture array name.</p>
<div class="admonition note">
<p><b>Note: </b>the resulting <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> does not own any native resources, it merely contains references and the associated metadata of the size and sample count. It is the caller's responsibility to ensure that the native resource exists as long as necessary.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The implementation of this overload is not compatible with OpenGL ES 2.0 or 3.0, and requires OpenGL ES 3.1 at minimum. (or OpenGL 3.0 on desktop)</p>
</div>
<p>This function was introduced in Qt 6.8.</p>
<p><b>See also </b><a href="qquickwindow.html#setRenderTarget" translate="no">QQuickWindow::setRenderTarget</a>(), <a href="qquickrendercontrol.html" translate="no">QQuickRenderControl</a>, and <a href="qquickrendertarget.html#fromOpenGLTexture" translate="no">fromOpenGLTexture</a>().</p>
<!-- @@@fromOpenGLTexture -->
<!-- $$$fromPaintDevice[overload1]$$$fromPaintDeviceQPaintDevice* -->
<h3 class="fn" translate="no" id="fromPaintDevice"><code class="details extra" translate="no">[static, since 6.4]</code> <span class="type"><a href="qquickrendertarget.html#QQuickRenderTarget" translate="no">QQuickRenderTarget</a></span> QQuickRenderTarget::<span class="name">fromPaintDevice</span>(<span class="type"><a href="../qtgui/qpaintdevice.html" translate="no">QPaintDevice</a></span> *<i>device</i>)</h3>
<p>Returns a new <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> referencing a paint device object specified by <i translate="no">device</i>.</p>
<p>This option of redirecting rendering to a <a href="../qtgui/qpaintdevice.html" translate="no">QPaintDevice</a> is available only when running with the <code translate="no">software</code> backend of Qt Quick.</p>
<div class="admonition note">
<p><b>Note: </b>The <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> does not take ownship of <i translate="no">device</i>, it is the caller's responsibility to ensure the object exists as long as necessary.</p>
</div>
<p>This function was introduced in Qt 6.4.</p>
<p><b>See also </b><a href="qquickwindow.html#setRenderTarget" translate="no">QQuickWindow::setRenderTarget</a>() and <a href="qquickrendercontrol.html" translate="no">QQuickRenderControl</a>.</p>
<!-- @@@fromPaintDevice -->
<!-- $$$fromRhiRenderTarget[overload1]$$$fromRhiRenderTargetQRhiRenderTarget* -->
<h3 class="fn" translate="no" id="fromRhiRenderTarget"><code class="details extra" translate="no">[static, since 6.6]</code> <span class="type"><a href="qquickrendertarget.html#QQuickRenderTarget" translate="no">QQuickRenderTarget</a></span> QQuickRenderTarget::<span class="name">fromRhiRenderTarget</span>(<span class="type"><a href="../qtgui/qrhirendertarget.html" translate="no">QRhiRenderTarget</a></span> *<i>renderTarget</i>)</h3>
<p>Returns a new <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> referencing an existing <i translate="no">renderTarget</i>.</p>
<p><i translate="no">renderTarget</i> will in most cases be a <a href="../qtgui/qrhitexturerendertarget.html" translate="no">QRhiTextureRenderTarget</a>, which allows directing the Qt Quick scene's rendering into a <a href="../qtgui/qrhitexture.html" translate="no">QRhiTexture</a>.</p>
<div class="admonition note">
<p><b>Note: </b>the resulting <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> does not own <i translate="no">renderTarget</i> and any underlying native resources, it merely contains references and the associated metadata of the size and sample count. It is the caller's responsibility to ensure that the referenced resources exists as long as necessary.</p>
</div>
<p>This function was introduced in Qt 6.6.</p>
<p><b>See also </b><a href="qquickwindow.html#setRenderTarget" translate="no">QQuickWindow::setRenderTarget</a>() and <a href="qquickrendercontrol.html" translate="no">QQuickRenderControl</a>.</p>
<!-- @@@fromRhiRenderTarget -->
<!-- $$$fromVulkanImage[overload1]$$$fromVulkanImageVkImageVkImageLayoutVkFormatconstQSize&int -->
<h3 class="fn" translate="no" id="fromVulkanImage"><code class="details extra" translate="no">[static, since 6.4]</code> <span class="type"><a href="qquickrendertarget.html#QQuickRenderTarget" translate="no">QQuickRenderTarget</a></span> QQuickRenderTarget::<span class="name">fromVulkanImage</span>(<span class="type">VkImage</span> <i>image</i>, <span class="type">VkImageLayout</span> <i>layout</i>, <span class="type">VkFormat</span> <i>format</i>, const <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> &amp;<i>pixelSize</i>, <span class="type">int</span> <i>sampleCount</i> = 1)</h3>
<p>Returns a new <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> referencing a Vulkan image object specified by <i translate="no">image</i>. The current <i translate="no">layout</i> of the image must be provided as well.</p>
<p><i translate="no">format</i> specifies the VkFormat of the image. Only image formats that are supported by Qt's rendering infrastructure should be used.</p>
<p><i translate="no">pixelSize</i> specifies the size of the image, in pixels. Currently only 2D textures are supported.</p>
<p><i translate="no">sampleCount</i> specifies the number of samples. 0 or 1 means no multisampling, while a value like 4 or 8 states that the native object is a multisample texture.</p>
<p>The image is used as the first color attachment of the render target used by the Qt Quick scenegraph. A depth-stencil buffer, if applicable, is created and used automatically.</p>
<div class="admonition note">
<p><b>Note: </b>the resulting <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> does not own any native resources, it merely contains references and the associated metadata of the size and sample count. It is the caller's responsibility to ensure that the native resource exists as long as necessary.</p>
</div>
<p>This function was introduced in Qt 6.4.</p>
<p><b>See also </b><a href="qquickwindow.html#setRenderTarget" translate="no">QQuickWindow::setRenderTarget</a>() and <a href="qquickrendercontrol.html" translate="no">QQuickRenderControl</a>.</p>
<!-- @@@fromVulkanImage -->
<!-- $$$fromVulkanImage$$$fromVulkanImageVkImageVkImageLayoutconstQSize&int -->
<h3 class="fn" translate="no" id="fromVulkanImage-1"><code class="details extra" translate="no">[static]</code> <span class="type"><a href="qquickrendertarget.html#QQuickRenderTarget" translate="no">QQuickRenderTarget</a></span> QQuickRenderTarget::<span class="name">fromVulkanImage</span>(<span class="type">VkImage</span> <i>image</i>, <span class="type">VkImageLayout</span> <i>layout</i>, const <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> &amp;<i>pixelSize</i>, <span class="type">int</span> <i>sampleCount</i> = 1)</h3>
<p>This is an overloaded function.</p>
<p>Returns a new <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> referencing a Vulkan image object specified by <i translate="no">image</i>. The image is assumed to have a format of VK_FORMAT_R8G8B8A8_UNORM.</p>
<p><i translate="no">pixelSize</i> specifies the size of the image, in pixels. Currently only 2D textures are supported.</p>
<p><i translate="no">sampleCount</i> specifies the number of samples. 0 or 1 means no multisampling, while a value like 4 or 8 states that the native object is a multisample texture.</p>
<p>The texture is used as the first color attachment of the render target used by the Qt Quick scenegraph. A depth-stencil buffer, if applicable, is created and used automatically.</p>
<div class="admonition note">
<p><b>Note: </b>the resulting <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> does not own any native resources, it merely contains references and the associated metadata of the size and sample count. It is the caller's responsibility to ensure that the native resource exists as long as necessary.</p>
</div>
<p><b>See also </b><a href="qquickwindow.html#setRenderTarget" translate="no">QQuickWindow::setRenderTarget</a>() and <a href="qquickrendercontrol.html" translate="no">QQuickRenderControl</a>.</p>
<!-- @@@fromVulkanImage -->
<!-- $$$fromVulkanImage$$$fromVulkanImageVkImageVkImageLayoutVkFormatVkFormatQSizeintintQQuickRenderTarget::Flags -->
<h3 class="fn" translate="no" id="fromVulkanImage-2"><code class="details extra" translate="no">[static, since 6.8]</code> <span class="type"><a href="qquickrendertarget.html#QQuickRenderTarget" translate="no">QQuickRenderTarget</a></span> QQuickRenderTarget::<span class="name">fromVulkanImage</span>(<span class="type">VkImage</span> <i>image</i>, <span class="type">VkImageLayout</span> <i>layout</i>, <span class="type">VkFormat</span> <i>format</i>, <span class="type">VkFormat</span> <i>viewFormat</i>, <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> <i>pixelSize</i>, <span class="type">int</span> <i>sampleCount</i>, <span class="type">int</span> <i>arraySize</i>, <span class="type"><a href="qquickrendertarget.html#Flag-enum" translate="no">QQuickRenderTarget::Flags</a></span> <i>flags</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a new <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> referencing a Vulkan image object specified by <i translate="no">image</i>. The current <i translate="no">layout</i> of the image must be provided as well. The image must be either a 2D texture or 2D texture array.</p>
<p><i translate="no">format</i> specifies the VkFormat of the image. Only image formats that are supported by Qt's rendering infrastructure should be used.</p>
<p><i translate="no">viewFormat</i> is usually set to the same value as <i translate="no">format</i>. In some cases, such as when rendering into a texture with a <code translate="no">_SRGB</code> format and the implicit linear-&gt;sRGB conversion on shader writes is not wanted, the value can be different. (for example, a <i translate="no">format</i> of <code translate="no">VK_FORMAT_R8G8B8A8_SRGB</code> and <i translate="no">viewFormat</i> of <code translate="no">VK_FORMAT_R8G8B8A8_UNORM</code>).</p>
<p><i translate="no">pixelSize</i> specifies the size of the image, in pixels. Currently only 2D textures are supported.</p>
<p><i translate="no">sampleCount</i> specifies the number of samples. 0 or 1 means no multisampling, while a value like 4 or 8 states that the native object is a multisample texture, except when <i translate="no">flags</i> contains <a href="qquickrendertarget.html#Flag-enum" translate="no">MultisampleResolve</a>. In that case, <i translate="no">image</i> is assumed to be a non-multisample 2D texture or 2D texture array, and <i translate="no">sampleCount</i> defines the number of samples desired. The resulting <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> will use an intermediate, automatically created multisample texture (or texture array) as its color attachment, and will resolve the samples into <i translate="no">image</i>. This is the recommended approach to perform MSAA when the native Vulkan image is not already multisample.</p>
<p>The number of array elements (layers) is given in <i translate="no">arraySize</i>. When greater than 1, it implies multiview rendering (<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_multiview.html">VK_KHR_multiview</a>), which can be relevant with VR/AR especially. <i translate="no">arraySize</i> is the number of views, typically <code translate="no">2</code>. See <a href="qsgmaterial.html#viewCount" translate="no">QSGMaterial::viewCount</a>() for details on enabling multiview rendering within the Qt Quick scenegraph.</p>
<p>The texture is used as the first color attachment of the render target used by the Qt Quick scenegraph. A depth-stencil buffer, if applicable, is created and used automatically. When the color buffer is multisample, the depth-stencil buffer will automatically be multisample too. For multiview rendering, the depth-stencil texture will automatically be made an array with a matching <i translate="no">arraySize</i>.</p>
<div class="admonition note">
<p><b>Note: </b>the resulting <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> does not own any native resources, it merely contains references and the associated metadata of the size and sample count. It is the caller's responsibility to ensure that the native resource exists as long as necessary.</p>
</div>
<p>This function was introduced in Qt 6.8.</p>
<p><b>See also </b><a href="qquickwindow.html#setRenderTarget" translate="no">QQuickWindow::setRenderTarget</a>() and <a href="qquickrendercontrol.html" translate="no">QQuickRenderControl</a>.</p>
<!-- @@@fromVulkanImage -->
<!-- $$$isNull[overload1]$$$isNull -->
<h3 class="fn" translate="no" id="isNull"><span class="type">bool</span> QQuickRenderTarget::<span class="name">isNull</span>() const</h3>
<p>Returns true if this <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a> is default constructed, referencing no native objects.</p>
<!-- @@@isNull -->
<!-- $$$mirrorVertically[overload1]$$$mirrorVertically -->
<h3 class="fn" translate="no" id="mirrorVertically"><code class="details extra" translate="no">[since 6.4]</code> <span class="type">bool</span> QQuickRenderTarget::<span class="name">mirrorVertically</span>() const</h3>
<p>Returns Returns whether the render target is mirrored vertically.</p>
<p>The default value is <code translate="no">false</code>.</p>
<p>This function was introduced in Qt 6.4.</p>
<p><b>See also </b><a href="qquickrendertarget.html#setMirrorVertically" translate="no">setMirrorVertically</a>().</p>
<!-- @@@mirrorVertically -->
<!-- $$$setDepthTexture[overload1]$$$setDepthTextureQRhiTexture* -->
<h3 class="fn" translate="no" id="setDepthTexture"><code class="details extra" translate="no">[since 6.8]</code> <span class="type">void</span> QQuickRenderTarget::<span class="name">setDepthTexture</span>(<span class="type"><a href="../qtgui/qrhitexture.html" translate="no">QRhiTexture</a></span> *<i>texture</i>)</h3>
<p>Requests using the given <i translate="no">texture</i> as the depth or depth-stencil buffer. Ownership of <i translate="no">texture</i> is not taken.</p>
<p>The request is only taken into account when relevant. For example, calling this function has no effect with <a href="qquickrendertarget.html#fromRhiRenderTarget" translate="no">fromRhiRenderTarget</a>(), <a href="qquickrendertarget.html#fromPaintDevice" translate="no">fromPaintDevice</a>(), or <a href="qquickrendertarget.html#fromOpenGLRenderBuffer" translate="no">fromOpenGLRenderBuffer</a>().</p>
<p>Normally a depth-stencil buffer is created automatically, transparently to the user of <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a>. Therefore, there is no need to call this function in most cases when working with <a href="qquickrendertarget.html" translate="no">QQuickRenderTarget</a>. In special circumstances, it can however become essential to be able to provide a texture to render depth (or depth and stencil) data into, instead of letting Qt Quick create its own intermediate textures or buffers. An example of this is <a href="https://www.khronos.org/openxr/">OpenXR</a> and its extensions such as <a href="https://registry.khronos.org/OpenXR/specs/1.0/html/xrspec.html#XR_KHR_composition_layer_depth">XR_KHR_composition_layer_depth</a>. In order to &quot;submit the depth buffer&quot; to the XR compositor, one has to, in practice, retrieve an already created depth (depth-stencil) texture from OpenXR (from the XrSwapchain) and use that texture as the render target for depth data. That would not be possible without this function.</p>
<div class="admonition note">
<p><b>Note: </b>The <i translate="no">texture</i> is always expected to be a non-multisample 2D texture or texture array (for multiview). If MSAA is involved, the samples are resolved into <i translate="no">texture</i> at the end of the render pass, regardless of having the <a href="qquickrendertarget.html#Flag-enum" translate="no">MultisampleResolve</a> flag set or not. MSAA is only supported for depth (depth-stencil) textures when the underlying 3D API supports this, and this support is not universally available. See <a href="../qtgui/qrhi.html#Feature-enum" translate="no">the relevant QRhi feature flag</a> for details. When this is not supported and multisampling is requested in combination with a custom depth texture, <i translate="no">texture</i> is not going to be touched during rendering and a warning is printed.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>When it comes to OpenGL and OpenGL ES, using depth textures is not functional on OpenGL ES 2.0 and requires at least OpenGL ES 3.0. Multisample (MSAA) support is not available without at least OpenGL ES 3.1, or OpenGL 3.0 on desktop.</p>
</div>
<p>This function was introduced in Qt 6.8.</p>
<p><b>See also </b><a href="qquickrendertarget.html#depthTexture" translate="no">depthTexture</a>().</p>
<!-- @@@setDepthTexture -->
<!-- $$$setDevicePixelRatio[overload1]$$$setDevicePixelRatioqreal -->
<h3 class="fn" translate="no" id="setDevicePixelRatio"><code class="details extra" translate="no">[since 6.3]</code> <span class="type">void</span> QQuickRenderTarget::<span class="name">setDevicePixelRatio</span>(<span class="type"><a href="../qtcore/qttypes.html#qreal-typedef" translate="no">qreal</a></span> <i>ratio</i>)</h3>
<p>Sets the device pixel ratio for this render target to <i translate="no">ratio</i>. This is the ratio between <i>device pixels</i> and <i>device independent pixels</i>.</p>
<p>Note that the specified device pixel ratio value will be ignored if <a href="qquickrendercontrol.html#renderWindow" translate="no">QQuickRenderControl::renderWindow</a>() is re-implemented to return a valid <a href="../qtgui/qwindow.html" translate="no">QWindow</a>.</p>
<p>This function was introduced in Qt 6.3.</p>
<p><b>See also </b><a href="qquickrendertarget.html#devicePixelRatio" translate="no">devicePixelRatio</a>().</p>
<!-- @@@setDevicePixelRatio -->
<!-- $$$setMirrorVertically[overload1]$$$setMirrorVerticallybool -->
<h3 class="fn" translate="no" id="setMirrorVertically"><code class="details extra" translate="no">[since 6.4]</code> <span class="type">void</span> QQuickRenderTarget::<span class="name">setMirrorVertically</span>(<span class="type">bool</span> <i>enable</i>)</h3>
<p>Sets the size of the render target contents should be mirrored vertically to <i translate="no">enable</i> when drawing. This allows easy integration of third-party rendering code that does not follow the standard expectations.</p>
<div class="admonition note">
<p><b>Note: </b>This function should not be used when using the <code translate="no">software</code> backend.</p>
</div>
<p>This function was introduced in Qt 6.4.</p>
<p><b>See also </b><a href="qquickrendertarget.html#mirrorVertically" translate="no">mirrorVertically</a>().</p>
<!-- @@@setMirrorVertically -->
</div>
<div class="relnonmem">
<h2>Related Non-Members</h2>
<!-- $$$operator!=[overload1]$$$operator!=constQQuickRenderTarget&constQQuickRenderTarget& -->
<h3 class="fn" translate="no" id="operator-not-eq"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> <span class="name">operator!=</span>(const <span class="type"><a href="qquickrendertarget.html#QQuickRenderTarget" translate="no">QQuickRenderTarget</a></span> &amp;<i>a</i>, const <span class="type"><a href="qquickrendertarget.html#QQuickRenderTarget" translate="no">QQuickRenderTarget</a></span> &amp;<i>b</i>)</h3>
<p>Returns true if <i translate="no">a</i> and <i translate="no">b</i> refer to a different set of native objects, or the associated data (size, sample count) does not match.</p>
<!-- @@@operator!= -->
<!-- $$$operator==[overload1]$$$operator==constQQuickRenderTarget&constQQuickRenderTarget& -->
<h3 class="fn" translate="no" id="operator-eq-eq"><code class="details extra" translate="no">[noexcept]</code> <span class="type">bool</span> <span class="name">operator==</span>(const <span class="type"><a href="qquickrendertarget.html#QQuickRenderTarget" translate="no">QQuickRenderTarget</a></span> &amp;<i>a</i>, const <span class="type"><a href="qquickrendertarget.html#QQuickRenderTarget" translate="no">QQuickRenderTarget</a></span> &amp;<i>b</i>)</h3>
<p>Returns true if <i translate="no">a</i> and <i translate="no">b</i> refer to the same set of native objects and have matching associated data (size, sample count).</p>
<!-- @@@operator== -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <abbr title="Copyright">&copy;</abbr> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
