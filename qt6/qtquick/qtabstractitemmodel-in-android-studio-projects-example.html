<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qtabstractitemmodel_in_android_studio_projects.qdoc -->
  <meta name="description" content="Shows how to handle complex data types and apply conditional formatting to a table view format using QtAbstractItemModel class and QtModelIndex class.">
  <title>Using QtAbstractItemModel in Android Studio Projects | Qt Quick | Qt 6.9.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li>Qt 6.9</li>
<li><a href="qtquick-index.html">Qt Quick</a></li>
<li><a href="qtquick-for-android.html">Qt Quick for Android</a></li>
<li>Using QtAbstractItemModel in Android Studio Projects</li>
<li id="buildversion"><a href="qtquick-index.html">Qt 6.9.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
  <link rel="prev" href="qml-in-android-studio-projects-example.html" />
  <link rel="next" href="qtabstractlistmoder-kotlin-example.html" />
<p class="naviNextPrevious headerNavi">
<a class="prevPage" href="qml-in-android-studio-projects-example.html">Qt Quick for Android Studio Projects</a>
<span class="naviSeparator">  &#9702;  </span>
<a class="nextPage" href="qtabstractlistmoder-kotlin-example.html">Exposing QtAbstractListModel to QML</a>
</p>
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#overview">Overview</a></li>
<li class="level1"><a href="#running-the-example">Running the example</a></li>
<li class="level1"><a href="#qml-project">QML project</a></li>
<li class="level1"><a href="#android-studio-project">Android Studio project</a></li>
<li class="level2"><a href="#data-model">Data Model</a></li>
<li class="level2"><a href="#main-activity">Main Activity</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">Using QtAbstractItemModel in Android Studio Projects</h1>
<!-- $$$qtabstractitemmodel-in-android-studio-projects-example.html-description -->
<div class="descr" id="details">
<h2 id="overview">Overview</h2>
<p class="centerAlign"><img src="images/qtabstractitemmodel_portrait.png" alt="" /></p><p>This example consists of two projects: an Android Studio project (qtabstractitemmodel_java) and a QML project (qtabstractitemmodel). You can import the QML project into an Android project.</p>
<p>The example shows how to handle complex data types between Java and QML. It demonstrates how to use the <code translate="no">QtAbstractItemModel</code> and <code translate="no">QtModelIndex</code> Java API classes. In QML, the data usage is demonstrated with the <a href="qml-qtquick-tableview.html" translate="no">TableView</a> item. In Java, data usage is demonstrated with a model of nested ArrayList items for rows and columns. For more information on how QML works, see <a href="../qtqml/qtqml-index.html">Qt Qml</a>.</p>
<h2 id="running-the-example">Running the example</h2>
<p>To run this example, you need Android Studio and Qt Tools for Android Studio on top of a standard Qt for Android installation. Open qtabstractitemmodel_java in Android Studio and follow the instructions in Qt Tools for Android Studio to import the <code translate="no">qtabstractitemmodel</code>.</p>
<h2 id="qml-project">QML project</h2>
<p>On the QML project side, the example uses a <a href="qml-qtquick-rectangle.html" translate="no">Rectangle</a> as the root object. The <code translate="no">dataModel</code> property variable holds the data model created and delivered from the Java side.</p>
<pre class="qml" translate="no">
 <span class="type"><a href="qml-qtquick-rectangle.html" translate="no">Rectangle</a></span> {
     <span class="name">id</span>: <span class="name">mainRectangle</span>

     property <span class="type">AbstractItemModel</span> <span class="name">dataModel</span>
</pre>
<p><a href="qml-qtquick-tableview.html" translate="no">TableView</a> displays our data model.</p>
<pre class="qml" translate="no">
     <span class="type"><a href="qml-qtquick-tableview.html" translate="no">TableView</a></span> {
         <span class="name">id</span>: <span class="name">tableView</span>

         <span class="name">model</span>: <span class="name">mainRectangle</span>.<span class="name">dataModel</span>

         <span class="type">anchors</span> {<span class="name">fill</span>: <span class="name">parent</span>; <span class="name">margins</span>: <span class="number">20</span>}
         <span class="name">columnSpacing</span>: <span class="number">4</span>
         <span class="name">rowSpacing</span>: <span class="number">6</span>
         <span class="name">boundsBehavior</span>: <span class="name">TableView</span>.<span class="name">OvershootBounds</span>
         <span class="name">clip</span>: <span class="number">true</span>

         <span class="name">ScrollBar</span>.vertical: <span class="name">ScrollBar</span> {
            <span class="name">policy</span>: <span class="name">ScrollBar</span>.<span class="name">AsNeeded</span>
         }
         <span class="name">ScrollBar</span>.horizontal: <span class="name">ScrollBar</span>{
            <span class="name">policy</span>: <span class="name">ScrollBar</span>.<span class="name">AsNeeded</span>
         }
</pre>
<p>On the <code translate="no">delegate</code> property, each cell item of the model is defined with a <a href="qml-qtquick-rectangle.html" translate="no">Rectangle</a> containing a <a href="qml-qtquick-textedit.html" translate="no">TextEdit</a>. The text property of the <code translate="no">TextEdit</code> is set using the <a href="../qtcore/qabstractitemmodel.html#data" translate="no">QAbstractItemModel::data</a>() which returns a value based on the given role and index.</p>
<p>Calling these methods from QML means the execution takes place in the Qt qtMainLoopThread thread context.</p>
<pre class="qml" translate="no">
         <span class="name">delegate</span>: <span class="name">Rectangle</span> {
             <span class="name">implicitWidth</span>: (<span class="name">tableView</span>.<span class="name">height</span> <span class="operator">&gt;</span> <span class="name">tableView</span>.<span class="name">width</span>) ? <span class="name">tableView</span>.<span class="name">width</span> <span class="operator">/</span> <span class="number">10</span> : <span class="name">tableView</span>.<span class="name">height</span> <span class="operator">/</span> <span class="number">5</span>
             <span class="name">implicitHeight</span>: <span class="name">implicitWidth</span>

             required property <span class="type"><a href="../qtqml/qml-var.html" translate="no">var</a></span> <span class="name">model</span>

             <span class="name">color</span>: <span class="string">&quot;#2CDE85&quot;</span>
             <span class="type">border</span> {<span class="name">color</span>: <span class="string">&quot;#00414A&quot;</span>; <span class="name">width</span>: <span class="number">2</span>}

             <span class="type"><a href="qml-qtquick-textedit.html" translate="no">TextEdit</a></span> {
                 <span class="comment">// Calls MyDataModel::data to get data based on the roles.</span>
                 <span class="comment">// Called in Qt qtMainLoopThread thread context.</span>
                 <span class="comment">//</span>
                 <span class="comment">// After editing is finished, call MyDataModel::setData()</span>
                 <span class="comment">// to update the value of selected cell.</span>
                 <span class="name">onEditingFinished</span>: <span class="name">parent</span>.<span class="name">model</span>.<span class="name">edit</span> <span class="operator">=</span> <span class="name">text</span>

                 <span class="name">text</span>: <span class="name">parent</span>.<span class="name">model</span>.<span class="name">display</span>
                 <span class="type"><a href="qml-font.html" translate="no">font</a></span> {<span class="name">pixelSize</span>: <span class="number">26</span>; <span class="name">bold</span>: <span class="number">true</span>}
                 <span class="name">padding</span>: <span class="number">5</span>
                 <span class="name">anchors</span>.fill: <span class="name">parent</span>
                 <span class="name">wrapMode</span>: <span class="name">TextEdit</span>.<span class="name">Wrap</span>
                 <span class="name">horizontalAlignment</span>: <span class="name">TextEdit</span>.<span class="name">AlignHCenter</span>
                 <span class="name">verticalAlignment</span>: <span class="name">TextEdit</span>.<span class="name">AlignVCenter</span>
             }
         }
</pre>
<p>In the case of editing the <a href="qml-qtquick-textedit.html" translate="no">TextEdit</a> field, <code translate="no">onEditingFinished()</code> handler sets the model's <code translate="no">edit</code> role value to the edited text. This calls the <a href="../qtcore/qabstractitemmodel.html#setData" translate="no">QAbstractItemModel::setData</a>() method, where the edited text of the cell is updated to the corresponding index of the model.</p>
<p>For more information see <a href="../qtcore/qabstractitemmodel.html" translate="no">QAbstractItemModel</a>.</p>
<h2 id="android-studio-project">Android Studio project</h2>
<p>The Android Studio project (qtabstractitemmodel_java) contains one Activity class <code translate="no">MainActivity</code> and <code translate="no">MyDataModel</code> class.</p>
<h3 id="data-model">Data Model</h3>
<p>The data model, <code translate="no">MyDataModel</code>, extends <code translate="no">QtAbstractItemModel</code> class. The <code translate="no">QtAbstractItemModel</code> is a wrapper for <a href="../qtcore/qabstractitemmodel.html" translate="no">QAbstractItemModel</a>.</p>
<p>As the methods of <code translate="no">MyDataModel</code> class are called from both, QML and Android sides, the execution occurs in both thread contexts, Qt qtMainLoopThread, and Android main thread contexts. You must ensure synchronization when accessing member variables in methods of the <code translate="no">MyDataModel</code> class.</p>
<p>First, the example initializes the model with a simple row and column mock data set. Note that this constructor method is called in the Android main thread context.</p>
<pre class="cpp" translate="no">
 /*
 * Initializes the two-dimensional array list with following content:
 * [] [] [] [] 1A 1B 1C 1D
 * [] [] [] [] 2A 2B 2C 2D
 * [] [] [] [] 3A 3B 3C 3D
 * [] [] [] [] 4A 4B 4C 4D
 * Threading: called in Android main thread context.
 */
 public MyDataModel() {
</pre>
<p>The example overrides the <code translate="no">QtAbstractItemModel</code> methods for different purposes. The columnCount() and rowCount() methods return the count of each in a model. The execution of each rowCount() occurs in both thread contexts, Qt qtMainLoopThread and Android main thread contexts.</p>
<pre class="cpp" translate="no">
 /*
 * Returns the count of columns.
 * Threading: called in Android main thread context.
 * Threading: called in Qt qtMainLoopThread thread context.
 */
 @Override
 synchronized public int columnCount(QtModelIndex qtModelIndex) {
     return m_columns;
 }

 /*
 * Returns the count of rows.
 * Threading: called in Android main thread context.
 * Threading: called in Qt qtMainLoopThread thread context.
 */
 @Override
 synchronized public int rowCount(QtModelIndex qtModelIndex) {
     return m_dataList.size();
 }
</pre>
<p>Method data() provides model data based on the role and index from Java to QML. The roleNames() method returns a hash matching numerical role values to their names as strings; in QML, we use these role names to fetch corresponding data from the model. The index() method returns the new model index. Method parent() should return a parent of the index. Still, as this example focuses on data without parent indices, we override the method and return an empty QtModelIndex(). As the methods are called from QML, the execution occurs in the Qt qtMainLoopThread thread context.</p>
<pre class="cpp" translate="no">
 /*
 * Returns the data to QML based on the roleNames
 * Threading: called in Qt qtMainLoopThread thread context.
 */
 @Override
 synchronized public Object data(QtModelIndex qtModelIndex, int role) {
     if (role == ROLE_DISPLAY) {
         Cell elementForEdit = m_dataList.get(qtModelIndex.row()).get(qtModelIndex.column());
         return elementForEdit.getValue();
     }
     Log.w(TAG, &quot;data(): unrecognized role: &quot; + role);
     return null;
 }

 /*
 * Defines what string i.e. role in QML side gets the data from Java side.
 * Threading: called in Qt qtMainLoopThread thread context.
 */
 @Override
 synchronized public HashMap&lt;Integer, String&gt; roleNames() {
     HashMap&lt;Integer, String&gt; roles = new HashMap&lt;&gt;();
     roles.put(ROLE_DISPLAY, &quot;display&quot;);
     roles.put(ROLE_EDIT, &quot;edit&quot;);
     return roles;
 }

 /*
 * Returns a new index model.
 * Threading: called in Qt qtMainLoopThread thread context.
 */
 @Override
 synchronized public QtModelIndex index(int row, int column, QtModelIndex parent) {
     return createIndex(row, column, 0);
 }

 /*
 * Returns a parent model.
 * Threading: not used called in this example.
 */
 @Override
 synchronized public QtModelIndex parent(QtModelIndex qtModelIndex) {
     return new QtModelIndex();
 }
</pre>
<p>The example overrides the <a href="../qtcore/qabstractitemmodel.html#setData" translate="no">QAbstractItemModel::setData</a>() method, which is called when model's data at <code translate="no">index</code> is set from the QML side of the application.</p>
<pre class="cpp" translate="no">
 /*
 * Gets called when model data is edited from QML side.
 * Sets the role data for the item at index to value,
 * if given index is valid and if data in given index truly changed.
 */
 @Override
 synchronized public boolean setData(QtModelIndex index, Object value, int role) {
     Cell cellAtIndex = m_dataList.get(index.row()).get(index.column());
     String cellValueAtIndex = cellAtIndex.getValue();
     if (!index.isValid() || role != ROLE_EDIT
             || Objects.equals(cellValueAtIndex, value.toString())) {
         return false;
     }
     cellAtIndex.setValue(value.toString());
     // Send dataChanged() when data was successfully set.
     dataChanged(index, index, new int[]{role});
     return true;
 }
</pre>
<p>The example implements methods on the model side for <code translate="no">MainActivity</code> UI interaction to add and remove rows and columns. Calls begin, end, insert, and remove rows to update model indexes, like beginInsertRow(). Because the example uses the <code translate="no">QtAbstractItemModel</code>, it must call beginInsertRows() and endInsertRows() every time it inserts new rows into the model. The same applies to removal. As the methods are called from the Android side, the execution takes place in the Android main thread context.</p>
<pre class="cpp" translate="no">
 /*
 * Adds a row.
 * Threading: called in Android main thread context.
 */
 synchronized public void addRow() {
     if (m_columns &gt; 0 &amp;&amp; m_dataList.size() &lt; MAX_ROWS_AND_COLUMNS) {
         beginInsertRows(new QtModelIndex(), m_dataList.size(), m_dataList.size());
         m_dataList.add(generateNewRow());
         endInsertRows();
     }
 }

 /*
 * Removes a row.
 * Threading: called in Android main thread context.
 */
 synchronized public void removeRow() {
     if (m_dataList.size() &gt; 1) {
         beginRemoveRows(new QtModelIndex(), m_dataList.size() - 1, m_dataList.size() - 1);
         m_dataList.remove(m_dataList.size() - 1);
         endRemoveRows();
     }
 }
</pre>
<p>The example implements methods on the model side for <code translate="no">MainActivity</code> UI interaction to add and remove columns. Calls begin, end, insert, and remove columns to update model indexes, like beginRemoveColumn(). The same context awareness applies as with the add and remove row methods.</p>
<pre class="cpp" translate="no">
 /*
 * Adds a column.
 * Threading: called in Android main thread context.
 */
 synchronized public void addColumn() {
     if (!m_dataList.isEmpty() &amp;&amp; m_columns &lt; MAX_ROWS_AND_COLUMNS) {
         beginInsertColumns(new QtModelIndex(), m_columns, m_columns);
         generateNewColumn();
         m_columns += 1;
         endInsertColumns();
     }
 }

 /*
 * Removes a column.
 * Threading: called in Android main thread context.
 */
 synchronized public void removeColumn() {
     if (m_columns &gt; 1) {
         int columnToRemove = m_columns - 1;
         beginRemoveColumns(new QtModelIndex(), columnToRemove, columnToRemove);
         for (int row = 0; row &lt; m_dataList.size(); row++)
             m_dataList.get(row).remove(columnToRemove);
         m_columns -= 1;
         endRemoveColumns();
     }
 }
</pre>
<h3 id="main-activity">Main Activity</h3>
<p><code translate="no">MainActivity</code> implements the <code translate="no">QtQmlStatusChangeListener</code> interface to get status updates when the QML is loaded. It is also the main Android activity.</p>
<p>The example creates and initializes the data model. See also <a href="qtquickview-android-class.html">QtQuickView</a></p>
<pre class="cpp" translate="no">
 private final MyDataModel m_model = new MyDataModel();
</pre>
<p>The example sets the UI button and its listeners to allow the users to interact with the model via the UI.</p>
<pre class="cpp" translate="no">
 /*
 * Returns the count of columns.
 * Threading: called in Android main thread context.
 * Threading: called in Qt qtMainLoopThread thread context.
 */
 @Override
 synchronized public int columnCount(QtModelIndex qtModelIndex) {
     return m_columns;
 }

 /*
 * Returns the count of rows.
 * Threading: called in Android main thread context.
 * Threading: called in Qt qtMainLoopThread thread context.
 */
 @Override
 synchronized public int rowCount(QtModelIndex qtModelIndex) {
     return m_dataList.size();
 }
</pre>
<p>The example starts loading the QML content. Loading happens in the background until the <code translate="no">ready</code> status is updated.</p>
<pre class="cpp" translate="no">
 /*
 * Returns the data to QML based on the roleNames
 * Threading: called in Qt qtMainLoopThread thread context.
 */
 @Override
 synchronized public Object data(QtModelIndex qtModelIndex, int role) {
     if (role == ROLE_DISPLAY) {
         Cell elementForEdit = m_dataList.get(qtModelIndex.row()).get(qtModelIndex.column());
         return elementForEdit.getValue();
     }
     Log.w(TAG, &quot;data(): unrecognized role: &quot; + role);
     return null;
 }

 /*
 * Defines what string i.e. role in QML side gets the data from Java side.
 * Threading: called in Qt qtMainLoopThread thread context.
 */
 @Override
 synchronized public HashMap&lt;Integer, String&gt; roleNames() {
     HashMap&lt;Integer, String&gt; roles = new HashMap&lt;&gt;();
     roles.put(ROLE_DISPLAY, &quot;display&quot;);
     roles.put(ROLE_EDIT, &quot;edit&quot;);
     return roles;
 }

 /*
 * Returns a new index model.
 * Threading: called in Qt qtMainLoopThread thread context.
 */
 @Override
 synchronized public QtModelIndex index(int row, int column, QtModelIndex parent) {
     return createIndex(row, column, 0);
 }

 /*
 * Returns a parent model.
 * Threading: not used called in this example.
 */
 @Override
 synchronized public QtModelIndex parent(QtModelIndex qtModelIndex) {
     return new QtModelIndex();
 }
</pre>
<p>The example sets the data model when the QML content is loaded, and the status is ready.</p>
<pre class="cpp" translate="no">
 /*
 * Gets called when model data is edited from QML side.
 * Sets the role data for the item at index to value,
 * if given index is valid and if data in given index truly changed.
 */
 @Override
 synchronized public boolean setData(QtModelIndex index, Object value, int role) {
     Cell cellAtIndex = m_dataList.get(index.row()).get(index.column());
     String cellValueAtIndex = cellAtIndex.getValue();
     if (!index.isValid() || role != ROLE_EDIT
             || Objects.equals(cellValueAtIndex, value.toString())) {
         return false;
     }
     cellAtIndex.setValue(value.toString());
     // Send dataChanged() when data was successfully set.
     dataChanged(index, index, new int[]{role});
     return true;
 }
</pre>
</div>
<!-- @@@qtabstractitemmodel-in-android-studio-projects-example.html -->
<p class="naviNextPrevious footerNavi">
<a class="prevPage" href="qml-in-android-studio-projects-example.html">Qt Quick for Android Studio Projects</a>
<span class="naviSeparator">  &#9702;  </span>
<a class="nextPage" href="qtabstractlistmoder-kotlin-example.html">Exposing QtAbstractListModel to QML</a>
</p>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <abbr title="Copyright">&copy;</abbr> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
