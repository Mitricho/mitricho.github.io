<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qabstractvideobuffer.cpp -->
  <meta name="description" content="The QAbstractVideoBuffer class is an abstraction for video data.">
  <title>QAbstractVideoBuffer Class | Qt Multimedia | Qt 6.9.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li>Qt 6.9</li>
<li><a href="qtmultimedia-index.html">Qt Multimedia</a></li>
<li><a href="qtmultimedia-modules.html">C++ Classes</a></li>
<li><a href="qtmultimedia-module.html" translate="no">QtMultimedia</a></li>
<li>QAbstractVideoBuffer</li>
<li id="buildversion"><a href="qtmultimedia-index.html">Qt 6.9.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QAbstractVideoBuffer Class</h1>
<!-- $$$QAbstractVideoBuffer-brief -->
<p>The QAbstractVideoBuffer class is an abstraction for video data. <a href="#details">More...</a></p>
<!-- @@@QAbstractVideoBuffer -->
<div class="table"><table class="alignedsummary requisites" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign"> <code translate="no">#include &lt;QAbstractVideoBuffer&gt;</code></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> <code translate="no">find_package(Qt6 REQUIRED COMPONENTS Multimedia)</code><br/>
<code translate="no">target_link_libraries(mytarget PRIVATE Qt6::Multimedia)</code></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> <code translate="no">QT += multimedia</code></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 6.8</td></tr>
</table></div>
<ul>
<li><a href="qabstractvideobuffer-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> struct </td><td class="memItemRight bottomAlign"><b><a href="qabstractvideobuffer-mapdata.html" translate="no">MapData</a></b></td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qabstractvideobuffer.html#dtor.QAbstractVideoBuffer" translate="no">~QAbstractVideoBuffer</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QVideoFrameFormat </td><td class="memItemRight bottomAlign"><b><a href="qabstractvideobuffer.html#format" translate="no">format</a></b>() const = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QAbstractVideoBuffer::MapData </td><td class="memItemRight bottomAlign"><b><a href="qabstractvideobuffer.html#map" translate="no">map</a></b>(QVideoFrame::MapMode <i>mode</i>) = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qabstractvideobuffer.html#unmap" translate="no">unmap</a></b>()</td></tr>
</table></div>
<!-- $$$QAbstractVideoBuffer-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>The <a href="qvideoframe.html" translate="no">QVideoFrame</a> class makes use of a QAbstractVideoBuffer internally to reference a buffer of video data. Creating a subclass of QAbstractVideoBuffer allows you to construct video frames from preallocated or static buffers. The subclass can contain a hardware buffer, and implement access to the data by mapping the buffer to CPU memory.</p>
<p>The contents of a buffer can be accessed by mapping the buffer to memory using the <a href="qabstractvideobuffer.html#map" translate="no">map</a>() function, which returns a structure containing information about plane layout of the current video data.</p>
</div>
<p><b>See also </b><a href="qvideoframe.html" translate="no">QVideoFrame</a>, <a href="qvideoframeformat.html" translate="no">QVideoFrameFormat</a>, and <a href="qvideoframe.html#MapMode-enum" translate="no">QVideoFrame::MapMode</a>.</p>
<!-- @@@QAbstractVideoBuffer -->
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$~QAbstractVideoBuffer[overload1]$$$~QAbstractVideoBuffer -->
<h3 class="fn" translate="no" id="dtor.QAbstractVideoBuffer"><code class="details extra" translate="no">[virtual noexcept]</code> QAbstractVideoBuffer::<span class="name">~QAbstractVideoBuffer</span>()</h3>
<p>Destroys a video buffer.</p>
<!-- @@@~QAbstractVideoBuffer -->
<!-- $$$format[overload1]$$$format -->
<h3 class="fn" translate="no" id="format"><code class="details extra" translate="no">[pure virtual]</code> <span class="type"><a href="qvideoframeformat.html" translate="no">QVideoFrameFormat</a></span> QAbstractVideoBuffer::<span class="name">format</span>() const</h3>
<p>Gets <a href="qvideoframeformat.html" translate="no">QVideoFrameFormat</a> of the underlying video buffer.</p>
<p>The format must be available upon construction of <a href="qvideoframe.html" translate="no">QVideoFrame</a>. <a href="qvideoframe.html" translate="no">QVideoFrame</a> will contain won instance of the given format, that can be detached and modified.</p>
<!-- @@@format -->
<!-- $$$map[overload1]$$$mapQVideoFrame::MapMode -->
<h3 class="fn" translate="no" id="map"><code class="details extra" translate="no">[pure virtual]</code> <span class="type"><a href="qabstractvideobuffer-mapdata.html" translate="no">QAbstractVideoBuffer::MapData</a></span> QAbstractVideoBuffer::<span class="name">map</span>(<span class="type"><a href="qvideoframe.html#MapMode-enum" translate="no">QVideoFrame::MapMode</a></span> <i>mode</i>)</h3>
<p>Maps the planes of a video buffer to memory.</p>
<p>Returns a <a href="qabstractvideobuffer-mapdata.html" translate="no">MapData</a> structure that contains information about the plane layout of the mapped current video data. If the mapping fails, the method returns the default structure. For CPU memory buffers, the data is considered as already mapped, so the function just returns the plane layout of the preallocated underlying data.</p>
<p>The map <i translate="no">mode</i> indicates whether the contents of the mapped memory should be read from and/or written to the buffer. If the map mode includes the <code translate="no">QVideoFrame::ReadOnly</code> flag the mapped memory will be populated with the content of the buffer when initially mapped. If the map mode includes the <code translate="no">QVideoFrame::WriteOnly</code> flag the content of the possibly modified mapped memory will be written back to the buffer when unmapped.</p>
<p>When access to the data is no longer needed, the <a href="qabstractvideobuffer.html#unmap" translate="no">unmap</a> function is called to release the mapped memory and possibly update the buffer contents.</p>
<p>If the format of the video data is multiplanar, the method may map the whole pixel data as a single plane. In this case, mapping a buffer with <a href="qvideoframe.html" translate="no">QVideoFrame</a> will calculate additional planes from the specified line stride of the first plane, the frame height, and the data size.</p>
<!-- @@@map -->
<!-- $$$unmap[overload1]$$$unmap -->
<h3 class="fn" translate="no" id="unmap"><code class="details extra" translate="no">[virtual]</code> <span class="type">void</span> QAbstractVideoBuffer::<span class="name">unmap</span>()</h3>
<p>Releases the memory mapped by the <a href="qabstractvideobuffer.html#map" translate="no">map</a>() function.</p>
<p>If the <a href="qvideoframe.html#MapMode-enum" translate="no">MapMode</a> included the <code translate="no">QVideoFrame::WriteOnly</code> flag this will write the current content of the mapped memory back to the video frame.</p>
<p>For CPU video buffers, the function may be not overridden. The default implementation of <code translate="no">unmap</code> does nothing.</p>
<p><b>See also </b><a href="qabstractvideobuffer.html#map" translate="no">map</a>().</p>
<!-- @@@unmap -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <abbr title="Copyright">&copy;</abbr> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
