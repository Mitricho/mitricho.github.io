<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qvideoframeinput.cpp -->
  <meta name="description" content="The QVideoFrameInput class is used for providing custom video frames to QMediaRecorder or a video output through QMediaCaptureSession.">
  <title>QVideoFrameInput Class | Qt Multimedia | Qt 6.9.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li>Qt 6.9</li>
<li><a href="qtmultimedia-index.html">Qt Multimedia</a></li>
<li><a href="qtmultimedia-modules.html">C++ Classes</a></li>
<li><a href="qtmultimedia-module.html" translate="no">QtMultimedia</a></li>
<li>QVideoFrameInput</li>
<li id="buildversion"><a href="qtmultimedia-index.html">Qt 6.9.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#signals">Signals</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QVideoFrameInput Class</h1>
<!-- $$$QVideoFrameInput-brief -->
<p>The QVideoFrameInput class is used for providing custom video frames to <a href="qmediarecorder.html" translate="no">QMediaRecorder</a> or a video output through <a href="qmediacapturesession.html" translate="no">QMediaCaptureSession</a>. <a href="#details">More...</a></p>
<!-- @@@QVideoFrameInput -->
<div class="table"><table class="alignedsummary requisites" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign"> <code translate="no">#include &lt;QVideoFrameInput&gt;</code></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> <code translate="no">find_package(Qt6 REQUIRED COMPONENTS Multimedia)</code><br/>
<code translate="no">target_link_libraries(mytarget PRIVATE Qt6::Multimedia)</code></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> <code translate="no">QT += multimedia</code></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 6.8</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="../qtcore/qobject.html" translate="no">QObject</a></td></tr>
</table></div>
<ul>
<li><a href="qvideoframeinput-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvideoframeinput.html#QVideoFrameInput" translate="no">QVideoFrameInput</a></b>(QObject *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qvideoframeinput.html#QVideoFrameInput-1" translate="no">QVideoFrameInput</a></b>(const QVideoFrameFormat &amp;<i>format</i>, QObject *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qvideoframeinput.html#dtor.QVideoFrameInput" translate="no">~QVideoFrameInput</a></b>() override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMediaCaptureSession *</td><td class="memItemRight bottomAlign"><b><a href="qvideoframeinput.html#captureSession" translate="no">captureSession</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVideoFrameFormat </td><td class="memItemRight bottomAlign"><b><a href="qvideoframeinput.html#format" translate="no">format</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qvideoframeinput.html#sendVideoFrame" translate="no">sendVideoFrame</a></b>(const QVideoFrame &amp;<i>frame</i>)</td></tr>
</table></div>
<h2 id="signals">Signals</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qvideoframeinput.html#readyToSendVideoFrame" translate="no">readyToSendVideoFrame</a></b>()</td></tr>
</table></div>
<!-- $$$QVideoFrameInput-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>QVideoFrameInput is only supported with the FFmpeg backend.</p>
<p>Custom video frames can be recorded by connecting a <a href="qvideoframeinput.html" translate="no">QVideoFrameInput</a> and a <a href="qmediarecorder.html" translate="no">QMediaRecorder</a> to a <a href="qmediacapturesession.html" translate="no">QMediaCaptureSession</a>. For a pull mode implementation, call <a href="qvideoframeinput.html#sendVideoFrame" translate="no">sendVideoFrame</a>() in response to the <a href="qvideoframeinput.html#readyToSendVideoFrame" translate="no">readyToSendVideoFrame</a>() signal. In the snippet below this is done by connecting the signal to a slot in a custom media generator class. The slot function emits another signal with a new video frame, which is connected to <a href="qvideoframeinput.html#sendVideoFrame" translate="no">sendVideoFrame</a>():</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qmediacapturesession.html" translate="no">QMediaCaptureSession</a></span> session;
 <span class="type"><a href="qmediarecorder.html" translate="no">QMediaRecorder</a></span> recorder;
 <span class="type"><a href="qvideoframeinput.html#QVideoFrameInput" translate="no">QVideoFrameInput</a></span> videoInput;

 session<span class="operator">.</span>setRecorder(<span class="operator">&amp;</span>recorder);
 session<span class="operator">.</span>setVideoFrameInput(<span class="operator">&amp;</span>videoInput);

 MediaGenerator generator; <span class="comment">// Custom class providing video frames</span>

 connect(<span class="operator">&amp;</span>videoInput<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="qvideoframeinput.html#QVideoFrameInput" translate="no">QVideoFrameInput</a></span><span class="operator">::</span>readyToSendVideoFrame<span class="operator">,</span>
         <span class="operator">&amp;</span>generator<span class="operator">,</span> <span class="operator">&amp;</span>MediaGenerator<span class="operator">::</span>nextVideoFrame);
 connect(<span class="operator">&amp;</span>generator<span class="operator">,</span> <span class="operator">&amp;</span>MediaGenerator<span class="operator">::</span>videoFrameReady<span class="operator">,</span>
         <span class="operator">&amp;</span>videoInput<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="qvideoframeinput.html#QVideoFrameInput" translate="no">QVideoFrameInput</a></span><span class="operator">::</span>sendVideoFrame);

 recorder<span class="operator">.</span>record();
</pre>
<p>Here's a minimal implementation of the slot function that provides video frames:</p>
<pre class="cpp" translate="no">
 <span class="type">void</span> MediaGenerator<span class="operator">::</span>nextVideoFrame()
 {
     <span class="type"><a href="qvideoframe.html" translate="no">QVideoFrame</a></span> frame <span class="operator">=</span> nextFrame();
     <span class="keyword">emit</span> videoFrameReady(frame);
 }
</pre>
<p>For more details see <a href="qvideoframeinput.html#readyToSendVideoFrame" translate="no">readyToSendVideoFrame</a>() and <a href="qvideoframeinput.html#sendVideoFrame" translate="no">sendVideoFrame</a>().</p>
</div>
<p><b>See also </b><a href="qmediarecorder.html" translate="no">QMediaRecorder</a>, <a href="qmediacapturesession.html" translate="no">QMediaCaptureSession</a>, and <a href="qvideosink.html" translate="no">QVideoSink</a>.</p>
<!-- @@@QVideoFrameInput -->
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QVideoFrameInput[overload1]$$$QVideoFrameInputQObject* -->
<h3 class="fn" translate="no" id="QVideoFrameInput"><code class="details extra" translate="no">[explicit]</code> QVideoFrameInput::<span class="name">QVideoFrameInput</span>(<span class="type"><a href="../qtcore/qobject.html#QObject" translate="no">QObject</a></span> *<i>parent</i> = nullptr)</h3>
<p>Constructs a new QVideoFrameInput object with <i translate="no">parent</i>.</p>
<!-- @@@QVideoFrameInput -->
<!-- $$$QVideoFrameInput$$$QVideoFrameInputconstQVideoFrameFormat&QObject* -->
<h3 class="fn" translate="no" id="QVideoFrameInput-1"><code class="details extra" translate="no">[explicit]</code> QVideoFrameInput::<span class="name">QVideoFrameInput</span>(const <span class="type"><a href="qvideoframeformat.html" translate="no">QVideoFrameFormat</a></span> &amp;<i>format</i>, <span class="type"><a href="../qtcore/qobject.html#QObject" translate="no">QObject</a></span> *<i>parent</i> = nullptr)</h3>
<p>Constructs a new QVideoFrameInput object with video frame <i translate="no">format</i> and <i translate="no">parent</i>.</p>
<p>The specified <i translate="no">format</i> will work as a hint for the initialization of the matching video encoder upon invoking <a href="qmediarecorder.html#record" translate="no">QMediaRecorder::record</a>(). If the format is not specified or not valid, the video encoder will be initialized upon sending the first frame. Sending of video frames with another pixel format and size after initialization of the matching video encoder might cause a performance penalty during recording.</p>
<p>We recommend specifying the format if you know in advance what kind of frames you're going to send.</p>
<!-- @@@QVideoFrameInput -->
<!-- $$$~QVideoFrameInput[overload1]$$$~QVideoFrameInput -->
<h3 class="fn" translate="no" id="dtor.QVideoFrameInput"><code class="details extra" translate="no">[override virtual noexcept]</code> QVideoFrameInput::<span class="name">~QVideoFrameInput</span>()</h3>
<p>Destroys the object.</p>
<!-- @@@~QVideoFrameInput -->
<!-- $$$captureSession[overload1]$$$captureSession -->
<h3 class="fn" translate="no" id="captureSession"><span class="type"><a href="qmediacapturesession.html" translate="no">QMediaCaptureSession</a></span> *QVideoFrameInput::<span class="name">captureSession</span>() const</h3>
<p>Returns the capture session this video frame input is connected to, or a <code translate="no">nullptr</code> if the video frame input is not connected to a capture session.</p>
<p>Use <a href="qmediacapturesession.html#videoFrameInput-prop" translate="no">QMediaCaptureSession::setVideoFrameInput</a>() to connect the video frame input to a session.</p>
<!-- @@@captureSession -->
<!-- $$$format[overload1]$$$format -->
<h3 class="fn" translate="no" id="format"><span class="type"><a href="qvideoframeformat.html" translate="no">QVideoFrameFormat</a></span> QVideoFrameInput::<span class="name">format</span>() const</h3>
<p>Returns the video frame format that was specified upon construction of the video frame input.</p>
<!-- @@@format -->
<!-- $$$readyToSendVideoFrame[overload1]$$$readyToSendVideoFrame -->
<h3 class="fn" translate="no" id="readyToSendVideoFrame"><code class="details extra" translate="no">[signal]</code> <span class="type">void</span> QVideoFrameInput::<span class="name">readyToSendVideoFrame</span>()</h3>
<p>Signals that a new frame can be sent to the video frame input. After receiving the signal, if you have frames to be sent, invoke <a href="qvideoframeinput.html#sendVideoFrame" translate="no">sendVideoFrame</a> once or in a loop until it returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="qvideoframeinput.html#sendVideoFrame" translate="no">sendVideoFrame</a>().</p>
<!-- @@@readyToSendVideoFrame -->
<!-- $$$sendVideoFrame[overload1]$$$sendVideoFrameconstQVideoFrame& -->
<h3 class="fn" translate="no" id="sendVideoFrame"><span class="type">bool</span> QVideoFrameInput::<span class="name">sendVideoFrame</span>(const <span class="type"><a href="qvideoframe.html" translate="no">QVideoFrame</a></span> &amp;<i>frame</i>)</h3>
<p>Sends <a href="qvideoframe.html" translate="no">QVideoFrame</a> to <a href="qmediarecorder.html" translate="no">QMediaRecorder</a> or a video output through <a href="qmediacapturesession.html" translate="no">QMediaCaptureSession</a>.</p>
<p>Returns <code translate="no">true</code> if the specified <i translate="no">frame</i> has been sent successfully to the destination. Returns <code translate="no">false</code>, if the frame hasn't been sent, which can happen if the instance is not assigned to <a href="qmediacapturesession.html" translate="no">QMediaCaptureSession</a>, the session doesn't have video outputs or a media recorder, the media recorder is not started or its queue is full. The signal <a href="qvideoframeinput.html#readyToSendVideoFrame" translate="no">readyToSendVideoFrame</a> will be sent as soon as the destination is able to handle a new frame.</p>
<p>Sending of an empty video frame is treated by <a href="qmediarecorder.html" translate="no">QMediaRecorder</a> as an end of the input stream. <a href="qmediarecorder.html" translate="no">QMediaRecorder</a> stops the recording automatically if <a href="qmediarecorder.html#autoStop-prop" translate="no">QMediaRecorder::autoStop</a> is <code translate="no">true</code> and all the inputs have reported the end of the stream.</p>
<!-- @@@sendVideoFrame -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <abbr title="Copyright">&copy;</abbr> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
